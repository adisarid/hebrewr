[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "המדריך העברי למשתמש ב-R",
    "section": "",
    "text": "הקדמה\nR שפה נפלאה, היא התחילה כשפה סטטיסטית, וגם כיום זה השימוש המרכזי שלה. בפועל אפשר לעשות בה כמעט הכל. החל מניתוח נתונים ועד בניית אפליקציות ואוטומציות מורכבות. אצלנו בעסק (מכון שריד) אנחנו משתמשים ב-R לניתוח נתונים, הצגת תוצאות עם דשבורדים בזמן אמת, הפקת דוחות Power Point בלחיצת כפתור, אוטומציות של תהליכים שונים בעסק, ועוד הרבה - היא הפכה לכלי עבודה שימושי והחליפה הרבה מאוד מהדברים שהיינו עושים בעבר עם כלים אחרים.\nללומדים את השפה יש מקורות רבים ומגוונים - ספרים, סרטוני YouTube, בלוגים, ועוד. העניין הוא שרוב המקורות שישנם כתובים באנגלית. זה מה שהביא אותי לכתוב את הספר הזה, ולעזור לקהל הקוראים שיותר נוח לו ללמוד R בעברית.\nהתוכן שבספר שלפניכם מבוסס על מספר קורסים שלימדתי בשנים האחרונות, כולל הכשרות מקצועיות בחברות סטארטאפ, וקורסי לימוד לתואר ראשון שנתתי באוניברסיטה.\nלמי מיועד הספר?\nאם אתם עובדים היום עם נתונים ומשתמשים ב-Excel או בכל כלי אחר, ומעוניינים לעבור לכלי חזק משמעותית שיגדיל את הגמישות, סל היכולות שלכם, ומהירות העבודה שלכם.\nאם אתם סטודנטים שלומדים מקצוע כמותי, כגון מבוא לסטטיסטיקה או קורס מתקדם בסטטיסטיקה.\nאם אתם עוברים מכלי סטטיסטי אחר (כגון SAS, SPSS, או אחרים) ומעוניינים למנף את הכלים והיכולות שיש ל-R להציע.\nהספר מתאים גם לכאלו שיודעים R ברמה בינונית ורוצים לחזק את הבסיס, או כאלו שרוצים להשתפשף בידיעות שלהם על החבילות שנלמדות בספר (כמו tidyverse).\nהספר אינו נועד להחליף ספרי תיאוריה סטטיסטית, הוא אינו מכסה תיאוריה סטטיסטית לעומק, אלא בעיקר מדגים כיצד ניתן לממש כלים סטטיסטיים שונים באמצעות R.\nלמה R ולא Python?\nכמו שמרמזת הכותרת, יש היום שתי שפות שמובילות בתחום ה-Data Science, הן R ו-Python. בנקודה הזו אין שחור ולבן, טוב יותר או פחות. אני עובד בשתי השפות, ולי באופן אישי יש העדפה חזקה לשימוש ב-R, פשוט כי היא מרגישה לי יותר טבעית, זה כנראה נגזרת של העובדה שזה מה שלמדתי בהתחלה, וזה מה שהתמקצעתי בו. בפועל בשתי השפות יש כלים רבים ושימושיים, ובכל הקשור במשימות של ניתוח נתונים, שתי השפות נותנות מענה טוב מאוד.\nמבין שתיהן Python יותר נפוצה משום שהיא נפוצה כשפת תכנות (באופן כללי), בעוד ש-R מוכוונת יותר לתחום הסטטיסטיקה. בפועל, שתיהן עושות את העבודה, וכדאי להתאים את השפה לצורך. לדוגמה R הרבה פעמים נוחה יותר לביצוע ניתוח נתונים, אבל ל-Python עשוי להיות יתרון במעבר ל-Production (הטמעה במערכות).\nהדיון של בחירה בשפה מסוימת צריך להיגזר מהמשימה הנדרשת, ההקשר העסקי, ועוד הרבה שיקולים אחרים. ככלל למי שמשתלב בתוך ארגון כדאי לדעת שיש ב-R חבילות שמאפשרות להפעיל גם קוד Python מתוך R (חבילת reticulate), שתאפשר להשתלב עם R גם בתוך ארגון שעובד מסורתית עם Python.\nמה בספר?\nבפרק 1 נראה מבוא קצר לתהליך ניתוח הנתונים ונלמד מהם הכלים הנדרשים על מנת להתקין את R. לאחר מכן נצלול, בפרק 2 לבסיס של R כשפת תכנות. הפרק מתייחס לחלקים ב-R שמגיעים בגרסה ה”ערומה ביותר” מה שמכונה גם Base R.\nבפרק 3 נלמד את הבסיס של חבילות tidyverse ואיך הן מרחיבות את Base-R והופכות את הקוד שלנו ליותר קריא, ואת הכתיבה ליותר נוחה. אנחנו נתמקד בעיקר בשלבי הכנת הנתונים לקראת ניתוח, ואז בפרק 4 נלמד על ויז’ואליזציות באמצעות חבילת ggplot2. בפרק 5 נטפל במניפולציות קצת יותר מתקדמות כמו חיבור טבלאות ושינוי מבנה טבלאות.\nלעולם הסטטיסטי ניכנס בפרק 6 עם מבחני השערה, ובפרק 7 עם רגרסיה לינארית.\nלאחר מכן נצלול קצת יותר לעומק עם מודלים מתקדמים מעולם ה-Data Science תוך שימוש בחבילת tidymodels בפרק 8.\nהנוסח שלפניכם הוא טיוטה, ולכן חלקים מסוימים עוד חסרים ממנו, וחלקים מסוימים עוד ישתנו. מי שמוצא טעות בספר, מוזמן לפנות אלי בטוויטר @SaridResearch, או להציע עדכונים באמצעות Pull request או לפתוח Issue ב-github."
  },
  {
    "objectID": "01-introduction.html#תהליך-ניתוח-נתונים",
    "href": "01-introduction.html#תהליך-ניתוח-נתונים",
    "title": "1  מבוא",
    "section": "1.1 תהליך ניתוח נתונים",
    "text": "1.1 תהליך ניתוח נתונים\nבספר הזה אני מאמץ את נקודת ההשקפה של (Wickham and Grolemund 2016) שמציגים את אבני הבניין של עבודת מדען הנתונים כפי שמומחש באיור הבא:\n\n\n\n\n\nהמחשה של תהליך ניתוח הנתונים\n\n\nכל תהליך ניתוח נתונים מורכב מיבוא סט הנתונים, סידור שלהם בצורה שנוח לעבוד איתה, לאחר מכן מחקר על הנתונים, שהוא תהליך איטרטיבי (חוזר על עצמו) שמורכב מהתמרות שונות על הנתונים (טרנספורמציות), המחשות בתרשימים (ויז’ואליזציות), ומידול של הנתונים. לבסוף, התהליך עובר למסמך, מצגת או אמצעי אחר, ומוצג למקבלי החלטות.\nבספר זה נדון בשלבים של יבוא הנתונים, סידור, וכלל שלבי המחקר (טרנספורמציות, ויז’ואליזציות, ומידול). אך ראשית, לפני שנתחיל בצעדים הראשונים (למידת בסיס השפה), נראה כיצד להתקין את R."
  },
  {
    "objectID": "01-introduction.html#איך-מתקינים-את-r",
    "href": "01-introduction.html#איך-מתקינים-את-r",
    "title": "1  מבוא",
    "section": "1.2 איך מתקינים את R?",
    "text": "1.2 איך מתקינים את R?\nהתקנת התוכנה פשוטה מאוד. R היא שפה בקוד פתוח (Open Source) מה שאומר שכל אחד יכול להתקין אותה ללא עלות. כמו כן, ישנה סביבת פיתוח, גם היא חינמית ובקוד פתוח, הנקראת RStudio IDE.\nעל מנת להתקין את R עליכם להיכנס לכתובת https://cran.r-project.org/ ולבחור בגרסה המתאימה למערכת ההפעלה שלכם. לאחר מכן, כדי להתקין את RStudio היכנסו לכתובת https://rstudio.com/products/rstudio/download/. הגרסה החינמית של RStudio נקראת RStudio Desktop והיא זמינה לכל צורך (כולל לשימוש במסגרת מסחרית).\nהסיבה שאנחנו מתקינים גם את R וגם את RStudio היא שבהתקנת R בלבד, מקבלים ממשק משתמש בסיסי ביותר, בעוד שלאחר התקנת RStudio ניתן יהיה לעבוד עם ממשק משתמש נוח שיש לו הרבה אפשרויות שיקלו עליכם את הלמידה ואת העבודה השוטפת ב-R."
  },
  {
    "objectID": "01-introduction.html#איך-משתמשים-ב-rstudio",
    "href": "01-introduction.html#איך-משתמשים-ב-rstudio",
    "title": "1  מבוא",
    "section": "1.3 איך משתמשים ב-RStudio?",
    "text": "1.3 איך משתמשים ב-RStudio?\nלאחר ההתקנה, כשתפעילו את RStudio, תראו חלון המפוצל לשלושה (או אולי ארבעה) חלקים. החלק הגדול בצד שמאל הוא ה-Console, הוא סביבת ה-R המריצה את הקוד שלכם. אתם יכולים לנסות לרשום בו קוד ולראות מה קורה, לדוגמה תנסו לרשום 2+2 וללחוץ Enter או לרשום pi וללחוץ Enter.\n\n2+2\n\n[1] 4\n\npi\n\n[1] 3.141593\n\n\nבצד ימין למעלה ישנה חלונית המחולקת לטאבים. בין הטאבים שמופיעים בה תוכלו לראות את:\n\nEnvironment - משתנים או פונקציות שנטענו לסביבה\nHistory - היסטורית הפקודות שהרצתם\nConnections - חיבורים למקורות נתונים\nTutorial - הצגה של מדריכים שונים שמלמדים איך להשתמש בחבילות של R\n\nבצד ימין למטה תופיעה חלונית נוספת המחולקת גם היא לטאבים:\n\nFiles - תוכן התיקייה הנוכחית\nPlots - תרשימים שנכין יופיעו בטאב זה\nPackages - חבילות שזמינות לנו או שנטענו לסביבה (יסומנו ב-V)\nHelp - חלונית עזרה על פקודות\nViewer - צפיה בתכנים שונים שנכין (בעיקר תכנים אינטראקטיביים כמו טבלאות html תרשימים אינטראקטיביים, ואפליקציות).\n\nבתוך משתמשים מתחילים נשתמש בחלק קטן מאלו, אך ככל שיעבור זמן תראו שאתם משתמשים ביותר ויותר אפשרויות, וגם אפשרויות נוספות שכרגע אינן מופיעות לכם.\nעוד כמה פינות חשובות שנמצאות ב-RStudio:\n\nאם תלחצו על Help->Cheat sheets תוכלו לראות רשימה של “שליפים”. דפים שימושיים שמרכזים פקודות שונות של R וחבילות של R. לדוגמה, אחד מהשליפים ששם נקרא RStudio IDE Cheat Sheet, והוא מכיל הרבה הסברים נוספים על הממשק משתמש של RStudio.\nבתפריט File -> New File ישנה אפשרות לפתוח קובץ חדש. מומלץ שתנסו לפתוח קובץ חדש מסוג R Script, שישמש אותנו לפרק הבא.\n\nשימו לב: לאחר שפתחתם Script חדש, וכתבתם בו קוד, על מנת להריץ את הקוד צריך לסמן אותו וללחוץ Ctrl+Enter. זה יגרום ל-R להריץ את כל הקוד המסומן.\nכעת אנחנו מוכנים לפרק הבא, שבו נלמד את בסיס השפה, מה שמכונה גם Base R.\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \"O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "02-base-R.html#השמת-משתנים-פעולות-אריתמטיות-ופונקציות",
    "href": "02-base-R.html#השמת-משתנים-פעולות-אריתמטיות-ופונקציות",
    "title": "2  תחביר בסיסי",
    "section": "2.1 השמת משתנים, פעולות אריתמטיות ופונקציות",
    "text": "2.1 השמת משתנים, פעולות אריתמטיות ופונקציות\nניתן להריץ ב-R פעולות אריתמטיות (חיבור, חיסור, כפל, חילוק), פונקציות, ולהגדיר משתנים שונים. לדוגמה, הקוד הבא מגדיר משתנה a משתנה b ומכניס את הסכום שלהם למשתנה חדש שיקרא a_plus_b.\n\na <- 5\nb <- 3\na_plus_b <- a + b\na_plus_b\n\n[1] 8\n\n\nשימו לב שההשמה לתוך משתנה מתבצעת עם האופרטור ->, ניתן גם להשתמש ב= לצורך השמה, כתיב זה פחות נפוץ. לדוגמה:\n\na_plus_b = a + b  # this form of assignment `=` is less common, don't use it (use `<-`)\n\n\n2.1.1 קביעת שמות משתנים\nקודם השתמשנו בשמות a, b , ו-a_plus_b כדי לקבוע משתנים. ככלל, מומלץ להשתמש בשמות קצרים בעלי משמעות. שמות משתנים חייבים להתחיל באות באנגלית, ויכולים להכיל אותיות, מספרים, קו תחתון, ונקודה. לדוגמה gender, age, raw_data, וכו’.\n\n\n2.1.2 סוגי משתנים\nבבסיס השפה יש כמה סוגי משתנים, שקובעים מה סוג הערכים שהמשתנה יכול לקבל:\n\nמספר שלם (Integer)\nמספר רציף (Double)\nמחרוזת (Character)\nמשתנה קטגוריות (Factor)\nתאריך (Date)\nמשתנה לוגי (Logical)\n\nכל משתנה חדש אנחנו מגדירים ב-R הוא למעשה וקטור. אגב, גם כשאנחנו מגדירים משתנה כערך בודד, בעצם הוא וקטור עם איבר אחד. אנחנו יכולים להשתמש בפקודה c (קיצור של המילה combine) כדי לשלב וקטורים שונים.\nנראה דוגמאות להגדרות של וקטורים מסוגים שונים.\n\nsome_integer <- c(1L, 2L, 3L)  # The L sign stands for \"Long integer\"\nsome_integer\n\n[1] 1 2 3\n\nsome_double <- c(1, 2, pi, exp(1))\nsome_double\n\n[1] 1.000000 2.000000 3.141593 2.718282\n\nsome_character <- c(\"This\", \"is\", \"a\", \"character\", \"vector\")\nsome_character\n\n[1] \"This\"      \"is\"        \"a\"         \"character\" \"vector\"   \n\nsome_factor <- factor(c(\"Apples\", \"Oranges\", \"Paers\", \"Mangos\", \"Apples\", \"Oranges\"))\nsome_factor\n\n[1] Apples  Oranges Paers   Mangos  Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\nsome_date <- c(Sys.Date(), as.Date(\"1993-08-01\"))\nsome_date\n\n[1] \"2023-08-08\" \"1993-08-01\"\n\nsome_logical <- c(TRUE, FALSE, FALSE, TRUE) # can also use c(T, F, F, T) is the same\nsome_logical\n\n[1]  TRUE FALSE FALSE  TRUE\n\n\nלמשתני קטגוריות יש שימוש חשוב בסטטיסטיקה שעוד נראה אותו בפרקים הבאים, ולכן הוא מובחן ממשתנה מחרוזת ומקבל מקום של כבוד. כפי שניתן לראות, כאשר מדפיסים אותו, R מדווח גם על הרמות השונות שכלולות בו.\nשימוש בפקודה typeof(some_variable) יציג את סוג המשתנה.\n\ntypeof(some_integer)\n\n[1] \"integer\"\n\ntypeof(some_double)\n\n[1] \"double\"\n\ntypeof(some_character)\n\n[1] \"character\"\n\ntypeof(some_date)\n\n[1] \"double\"\n\ntypeof(some_factor)\n\n[1] \"integer\"\n\ntypeof(some_logical)\n\n[1] \"logical\"\n\n\nניתן לשים לב ש-R מחשיב את המשתנה הקטגוריאלי כמספר שלם (integer) ואת התאריך כמספר רציף (double).\n\n\n\nבאמצעות הפקודה c והפקודה typeof בדקו מה קורה כאשר מחברים משתנים מסוגים שונים אחד לשני. האם התוצאה הגיונית? מה ההיגיון? האם יש מקרים בהם התוצאה של חיבור משתנים עשויה להטעות?\n\n\nבדקו את c(some_factor, some_character) ודוגמאות נוספות.\n\n\n\n\n\n2.1.3 קריאה לתתי וקטורים\nב-R ניתן לקרוא לחלק מסוים מתוך וקטור. לדוגמה, אם אנחנו רוצים רק את שני האיברים הראשונים מתוך הוקטור some_factor או את האיבר הראשון והרביעי מתוך some_character נשתמש בכתיב:\n\nsome_factor[1:2]\n\n[1] Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\nsome_character[c(1,4)]\n\n[1] \"This\"      \"character\""
  },
  {
    "objectID": "02-base-R.html#רשימה-list",
    "href": "02-base-R.html#רשימה-list",
    "title": "2  תחביר בסיסי",
    "section": "2.2 רשימה (list)",
    "text": "2.2 רשימה (list)\nכעת נדון במבנה נתונים שנקרא רשימה (list). רשימה היא אובייקט מרכזי ב-R שמאפשר לנו לאחד משתנים ווקטורים מסוגים שונים, לתוך dataset שיאפשר לנו בהמשך לנתח נתונים. ישנן מספר דרכים להגדיר רשימה, אחת מהן באמצעות הפקודה list. לדוגמה, הרשימה הבאה תכיל את כל הוקטורים שהגדרנו עד כה, מבלי שהם יאבדו מהמשמעות שלהם (כפי שקורה כשמנסים לעשות חיבור רגיל).\n\nmy_list <- list(my_int = some_integer,\n                my_double = some_double,\n                my_character = some_character,\n                my_factor = some_factor,\n                my_date = some_date)\nmy_list\n\n$my_int\n[1] 1 2 3\n\n$my_double\n[1] 1.000000 2.000000 3.141593 2.718282\n\n$my_character\n[1] \"This\"      \"is\"        \"a\"         \"character\" \"vector\"   \n\n$my_factor\n[1] Apples  Oranges Paers   Mangos  Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\n$my_date\n[1] \"2023-08-08\" \"1993-08-01\"\n\ntypeof(my_list)\n\n[1] \"list\"\n\n\nכדי לקרוא לוקטור מסוים מתוך רשימה ניתן להשתמש ב-$ באופן הבא:\n\nmy_list$my_int\n\n[1] 1 2 3\n\n\nהחלק הסופי בהצגה שלנו הוא רשימה מסוג מאוד מסוים, data.frame. מבנה נתונים זה הוא רשימה שבה כל הוקטורים באותו האורך. הוקטורים יכולים להיות מסוגים שונים כפי שציינו, ומה שחשוב ב-data.frame הוא שהוא הולך להיות אבן הפינה שלנו בכל ניתוח נתונים סטטיסטי. בינתיים נסתפק בהדגמה קצרה של הגדרת data.frame אך נרחיב עליו בפרקים הבאים.\n\nmy_data <- data.frame(name = c(\"Danny\", \"Moshe\", \"Iris\", \"Ronit\"),\n                      favorite_fruit = factor(c(\"Mango\", \"Apple\", \"Apple\", \"Paer\")),\n                      age = c(25L, 32L, 22L, 30L),\n                      height = c(1.8, 1.75, 1.6, 1.68),\n                      married = c(F, T, F, T))\nmy_data\n\n   name favorite_fruit age height married\n1 Danny          Mango  25   1.80   FALSE\n2 Moshe          Apple  32   1.75    TRUE\n3  Iris          Apple  22   1.60   FALSE\n4 Ronit           Paer  30   1.68    TRUE\n\ntypeof(my_data)\n\n[1] \"list\""
  },
  {
    "objectID": "02-base-R.html#שימוש-בפונקציות",
    "href": "02-base-R.html#שימוש-בפונקציות",
    "title": "2  תחביר בסיסי",
    "section": "2.3 שימוש בפונקציות",
    "text": "2.3 שימוש בפונקציות\nניתן גם להפעיל פונקציות שונות, לדוגמה לוגריתם, פונקציות טריגונומטריות. למעשה בסעיף הקודם כבר ראינו מספר פונקציות כגון c ו-typeof. כעת נראה עוד מספר דוגמאות.\nנסו להריץ את הקוד הבא, ולאחר מכן לענות על השאלות שמתחת למקטע הקוד. יש לשים לב שעל מנת להריץ את הפקודות בסוף המקטע (שקשורות ב-my_data נדרש קודם להגדיר את my_data כפי שהוגדר במקטע הקוד הקודם.\n\nlog(100)  # natural logarithm\nlog10(100)  # base 10 logarithm \nsin(pi)  # sin(pi) is 0 but may give you a surprising answer, why?\nsqrt(4)  # square root of 4\nmean(my_data$age)\nsd(my_data$age)\nsummary(my_data)\n\n\n\n\nשאלה למחשבה: בחלק מהמחשבים התשובה שמתקבלת ל-(()) שונה מ-0. למה לדעתך?\n\n\n\n\n\n\nהפקודה האחרונה שהרצנו בדוגמה היא פקודת summary. מה עושה הפקודה summary עבור כל סוג עמודה שהיא מוצאת בdata.frame?\n\n\n\nככלל, הפעלת פונקציה ב-R תיראה כך:\n\n# some code which defines the variable `bar` and then\nsome_result <- some_function(foo = bar)\n\n# or simply\nsome_result <- some_function(bar)\n\nכאשר some_result יחזיק את התוצאה של הפונקציה. הפונקציה עצמה נקראת some_function, היא מקבלת ארגומנט (משתנה) יחיד שנקרא foo ואנחנו משתמשים במשתנה שערכו bar שנכנס לארגומנט.\nכדי להמחיש נראה דוגמה נוספת, הפעם עם פונקציה פשוטה שגם נגדיר בעצמנו. נסו לעיין בקוד ולהבין מה המשמעות של כל שורה בקוד. שלושת השורות הראשונות בקוד מגדירות פונקציה חדשה, וההמשך מריץ אותה.\n\n# define a new function which adds a number\none_plus <- function(number){\n  number + 1\n}\n# use the function:\none_plus(1)\n\n[1] 2\n\none_plus(one_plus(1))\n\n[1] 3"
  },
  {
    "objectID": "02-base-R.html#אופרטורים",
    "href": "02-base-R.html#אופרטורים",
    "title": "2  תחביר בסיסי",
    "section": "2.4 אופרטורים",
    "text": "2.4 אופרטורים\nאופרטורים משמשים כדי להגדיר תנאים לוגיים שונים, לדוגמה אם אנחנו רוצים לבדוק את נכונותם של שני תנאים או יותר. ב-R נשתמש בתו כפול || כדי לציין “או” לוגי (or), ונשתמש בתו כפול && על מנת לציין “וגם” לוגי (and).\n\na <- 5\nb <- 6\n\n(a < 3) && (b >= 3)\n\n[1] FALSE\n\n(a >= 5) || (b > 10)\n\n[1] TRUE\n\n\nישנם גם פעולות לוגיות וקטוריות: כמו שניתן לחבר שני וקטורים, ניתן גם לבצע פעולות לוגיות איבר-איבר. פעולות אלו מבוצעות על ידי תו בודד: | או &.\n\nv1 <- c(T, T, F, F)\nv2 <- c(T, F, T, F)\n\nv1 | v2\n\n[1]  TRUE  TRUE  TRUE FALSE\n\nv1 & v2\n\n[1]  TRUE FALSE FALSE FALSE\n\n\n\n\n\nנסו לבחון מה קורה במקרה של v1 || v2 או v1 && v2. מה החוקיות?\n\n\n\nאופרטור נוסף הוא אופרטור השלילה (not), נשתמש בתו ! על מנת לייצג אותו. לדוגמה:\n\n!c(T, F)\n\n[1] FALSE  TRUE\n\n!v1\n\n[1] FALSE FALSE  TRUE  TRUE\n\na==5\n\n[1] TRUE\n\n!(a==5)\n\n[1] FALSE\n\n\nשימו לב שבדוגמה האחרונה השתמשנו באופרטור נוסף אשר בודק אם שני אובייקטים הם בעלי אותו הערך. אופרטור זו מצויין עם שיוויון כפול ==. ניתן גם להשוות שני משתנים זה לזה או להשוות שני וקטורים (איבר-איבר) באופן הבא:\n\na == b\n\n[1] FALSE\n\nc(1, 2, 3) == c(2, 1 , 3)\n\n[1] FALSE FALSE  TRUE\n\n\nישנם אופרטורים נוספים ב-R, אך בינתיים נסתפק באופרטורים שצוינו לעיל. כעת, לאחר שלמדנו על אופרטורים לוגיים, באפשרותנו ללמוד על התניות (if cluases) ועל לולאות (loops)."
  },
  {
    "objectID": "02-base-R.html#התניות",
    "href": "02-base-R.html#התניות",
    "title": "2  תחביר בסיסי",
    "section": "2.5 התניות",
    "text": "2.5 התניות\nבמקרים רבים אנחנו רוצים להתנות פעולות מסוימות בקיומו של תנאי כלשהו. ניתן לבצע התניה זו באמצעות הפקודות if, else if, else.\nהמבנה הכללי של התניות יראה כך:\n\nif (condition1) {\n  # some code which evaluates if condition1 == TRUE\n} else if (condition2) {\n  # some code which evaluates if condition1 == FALSE and condition2 == TRUE\n} else {\n  # some code which evaluates if condition1 == FALSE and condition2 == FALSE\n}\n\nעל מנת להדגים, נשתמש בדוגמה הבאה: נניח שאנחנו רוצים לבדוק אם ערך מסוים הוא מספר או לא. נוכל להשתמש בשילוב של if והפונקציה is.numeric:\n\nsome_value <- 100\n\nif (is.numeric(some_value)) {\n  cat(\"This is indeed a numeric value!\")\n} else {\n  cat(\"This is not a numeric value!\")\n}\n\nThis is indeed a numeric value!\n\nsome_value <- \"foobar\"\n\nif (is.numeric(some_value)) {\n  cat(\"This is indeed a numeric value!\")\n} else {\n  cat(\"This is not a numeric value!\")\n}\n\nThis is not a numeric value!\n\n\nאפשר גם להשתמש בהתניות בתוך התניות, כלומר בתוך פקודת if להגדיר פקודת if נוספת.\n\n\n\nנסו להרחיב את הדוגמה הקודמת, כך שבמידה ו-some_value הוא מספר המתחלק ב-2 אז יודפס “some_value is even” ובמידה ואינו מתחלק ב-2 יודפס “some_value is odd”.\n\n\nנסו למצוא יותר מדרך אחת לביצוע הרחבה זו."
  },
  {
    "objectID": "02-base-R.html#לולאות",
    "href": "02-base-R.html#לולאות",
    "title": "2  תחביר בסיסי",
    "section": "2.6 לולאות",
    "text": "2.6 לולאות\nלולאות הן דרך נוחה כדי לגרום למחשב לעשות הרבה חזרות של אותה הפעולה (רק בשינוי ערכים מסוימים). ב-R ישנם סוגים שונים של לולאות, המתאפיינים בפקודות שונות אבל גם בזמן ריצה (יעילות) שונה.\n\nלולאות for\nלולאות while\nלולאות repeat break next\nלולאות באמצעות תכנות פונקציונלי (כדוגמת פקודת lapply, או פקודות מחבילות אחרות כמו map שנמצאת בחבילת purrr)\n\nעדיף להימנע ככל שניתן משימוש בכל סוגי הלולאות for, while, ו-repeat בעבודה עם R. לולאות אלו מאוד לא יעילות וזמן הריצה שלהן ארוך. תכנות פונקציונלי הוא יותר יעיל, אך דורש קצת יותר “התרגלות”. בכל זאת, נדגים את אופן הפעולה של לולאת for.\nעל מנת להגדיר לולאת for עלינו להגדיר ראשית את טווח הפעולה של הלולאה. לדוגמה, לולאה שרצה על המספרים 1 עד 100 תוגדר באופן הבא:\n\nfor (i in 1:100){\n  # do some action\n  # you can use i for that but don't have to\n}\n\nטווח הפעולה של הלולאה לא חייב להיות מספרי, אפשר גם להשתמש באובייקטים נוספים. לדוגמה נשתמש בלולאה על סוגי פירות. בדוגמה הבאה נשלב גם שימוש בהתניות, כפי שלמדנו בסעיף הקודם. השילוב של לולאות והתניות די נפוץ בתכנות.\n\nfruits <- c(\"Mango\", \"Bannana\", \"Pineapple\", \"Orange\", \"Apple\", \"Prune\", \"Lemon\", \"Loquat\")\nmy_garden <- c(\"Mango\", \"Orange\", \"Lemon\", \"Loquat\")\n\nfor (current_fruit in fruits) {\n  if (current_fruit %in% my_garden) {\n    cat(\"\\nI grow\", current_fruit)\n  } else {\n    cat(\"\\nI don't grow\", current_fruit)\n  }\n}\n\n\nI grow Mango\nI don't grow Bannana\nI don't grow Pineapple\nI grow Orange\nI don't grow Apple\nI don't grow Prune\nI grow Lemon\nI grow Loquat\n\n\n\n\n\nבדוגמה הקודמת השתמשנו ב-in וגם ב-%in%.\n\n\nin נחשבת מילת מפתח, בעוד ש-%in% נחשבת אופרטור. עמדו על ההבדלים ביניהן וכתבו מה המשמעות של כל אחת, ומה התפקיד שלה בקוד.\n\n\n\nנדגים גם כיצד ניתן להחליף לולאה באמצעות פעולה וקטורית, ובאמצעות נוסחה מתמטית. נניח שאנחנו רוצים לחשב סכום של טור הנדסי, כלומר הסכום של \\(1, q, q^2, q^3, \\ldots\\) כאשר \\(q<1\\). נציג שלוש דרכים לבצע את הפעולה הזו: לולאה (הדרך הכי פחות יעילה), פעולה וקטורית (להיעזר בוקטור, כלומר מערך של מספרים), והדרך היעילה ביותר שהיא כמובן פשוט להשתמש בנוסחה של טור הנדסי (\\(\\frac{1}{1-q}\\)).\n\nq <- 1/2\n\nseries_sum_loop <- 0\n\nfor (element_i in 0:50){\n  series_sum_loop <- series_sum_loop + q^element_i\n}\n\nseries_sum_loop\n\n[1] 2\n\nseries_sum_vector <- sum(q^(0:50))\n\nseries_sum_vector\n\n[1] 2\n\nseries_sum_analytic <- 1/(1-q)\n\nseries_sum_analytic\n\n[1] 2\n\n\nחישוב של טור הנדסי הוא כמובן פעולה פשוטה, אבל לא בכל פעולה שנרצה לעשות תהיה נוסחה סגורה כמו שיש שלנו במקרה של טור הנדסי, וגם לא תמיד יהיה אפשר לבצע את הפעולה כפעולה וקטורית.\n\n\n\nסדרת פיבונצ’י היא סדרה של מספרים שבה כל איבר הוא הסכום של שני האיברים שקדמו לו. שני האיברים הראשונים מקבלים את הערך 1, ולכן האיברים הראשונים של הסדרה נראים כך:\n\n\n[ 1, 1, 2, 3, 5, 8, 13, 21, 34, ] היעזרו בקוד הבא על מנת לבנות לולאה שתדפיס את 50 האיברים הראשונים של סדרת פיבונצ’י. עליכם להשלים את הקוד במקומות בהם מופיע סימן שאלה.\n\n\n\n\n# Fibonachi code exercise, fill in the blanks (where you see `?`)\ntotal <- ?\n\nelement_i_minus1 <- 1\nelement_i_minus2 <- 1\n\nfor (? in 3:total){\n  next_element <- element_i_minus1 + ?\n  element_i_minus2 <- element_i_minus1\n  ? <- next_element\n  \n  cat(\"\\n\", ?)\n}"
  },
  {
    "objectID": "02-base-R.html#סיכום",
    "href": "02-base-R.html#סיכום",
    "title": "2  תחביר בסיסי",
    "section": "2.7 סיכום",
    "text": "2.7 סיכום\nבפרק זה למדנו את התחביר הבסיסי של שפת R.\n\nראינו כיצד עובדת השמת משתנים\nלמדנו על סוגי משתנים שונים\nראינו כיצד לקרוא לתתי וקטורים (חלק מוקטור)\nלמדנו על אובייקטים מסוג רשימה (list)\nלמדנו על פונקציות שונות - כיצד להפעיל אותן וכיצד להגדיר פונקציות חדשות\nלמדנו על אופרטורים (וגם, או, לא - NOT, והשוואה)\nלמדנו על התניות (אם… אז… אחרת)\nלמדנו על לולאות (מסוג for), והזכרנו סוגים נוספים.\n\nעד כה הכלים שתיארנו הם כלים כלליים, במובן שבמרבית שפות התכנון ישנן מקבילות דומות. בפרק הבא נתעמק בכלים ייעודיים אשר נבנו ומשמשים לניתוח נתונים סטטיסטי (או ליתר דיוק בהכנת נתונים לניתוח נתונים סטטיסטיקה)."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#קצת-פילוסופיה",
    "href": "03-data-munging-tidyverse.html#קצת-פילוסופיה",
    "title": "3  הכנת נתונים",
    "section": "3.1 קצת פילוסופיה",
    "text": "3.1 קצת פילוסופיה\nהחבילה ב-R שנקראת tidyverse היא למעשה “חבילה של חבילות”.\nהיא מכילה מקבץ חבילות לעבודה עם נתונים כמו dplyr, וכמו tidyr שהן חבילות מאוד שימושיות במניפולציה על נתונים, וסידור נתונים, אבל היא מכילה גם חבילות שממוקדות סביב עולמות תוכן אחרים, כמו stringr לעבודה עם מחרוזות, lubridate לעבודה עם תאריכים, ו-forcats לעבודה עם פקטורים. כפי שחדי העין ישימו לב, לרוב שם של חבילה ירמוז לגבי מהות החבילה (לעיתים עם האות r איפשהו, ולעיתים עם קורטוב של הומור). הפירוט המלא של תוכן החבילה tidyverseוהחבילות שמוכלות בה זמין בקישור.\nעל מנת להתקין את החבילה נשתמש בפקודה install.packages(\"tidyverse\"), ועל מנת לטעון אותה לאחר ההתקנה, נשתמש בפקודה library(tidyverse). שימו לב שבהתקנה צריך להשתמש במרכאות אבל בקריאה לאחר מכן אין צורך במרכאות. את ההתקנה צריך לעשות רק פעם אחת (והיא לוקחת המון זמן), ואת הקריאה לספריה צריך לעשות כל פעם שמפעילים מחדש את R.\nכשלב יסודי, מה שחשוב להבין בעבודה עם נתונים זה שהשאיפה היא שתמיד נשאף להגיע ולעבוד במבנה מסודר שבו:\n\nכל עמודה היא משתנה.\nכל שורה היא תצפית.\nכל תא הוא ערך של משתנה עבור תצפית מסוימות.\n\nאם הדאטה המקורי שלנו לא במבנה הזה - אז כהכנה נרצה להביא אותו למבנה כזה, ואם הוא כבר במבנה המסודר הזה, אז כל פעולה שנעשה, עדיין תשמור את הדאטה במבנה מסודר. המבנה הזה מכונה באנגלית tidy (ומכאן השם tidyverse). אנחנו פשוט נכנה אותו פה מבנה “מסודר”.\nניתן שתי דוגמאות לדאטה, אחד מסודר ואחר לא מסודר. נתחיל בדוגמה לדאטה לא מסודר.\n\n3.1.1 דאטה untidy\nהלשכה המרכזית לסטטיסטיקה מנגישה הרבה נתונים לציבור באמצעות האתר שלה https://www.cbs.gov.il\nמרבית הנתונים שמונגשים לציבור דרך האתר בקבצי אקסל הינם בפורמט לא מסודר. לדוגמה, קובץ שהורדתי מהכתובת הזו והוא עוסק בנפח תנועה מסביב לכנרת בחג הפסח וסוכות.\nזה קובץ אקסל, והוא נראה כך:\n\n\n\nדאטה לא-מסודר מאתר הלשכה המרכזית לסטטיסטיקה\n\n\nאיפה הבעיות עם הדאטה? נראה מה הסעיפים שאינם מתקיימים:\n\nכל עמודה היא משתנה - מתקיים באופן חלקי. משום שיש עמודות מסוימות כמו עמודות H-K שהן ממוזגות מה שהופך אותם ל”לא בדיוק משתנה יחיד”. מדובר בקבוצת משתנים ותכונה שמתארת אותם. בפרט, היינו מצפים לראות שורת כותרת אחת שמתארת את שמות המשתנים (מה שמכונה באנגלית headers), אבל בפועל יש פה הרבה שורות כותרות.\nכל שורה היא תצפית - לא מתקיים בכלל. יש שורות ריקות (כמו שורה 5), ויש שורות שאינן תצפית אלא מתארות תכונות של מקבץ תצפיות (כגון שורה 6 ושורה 14).\nכל תא הוא ערך של משתנה עבור תצפית מסוימת - לא מתקיים. ראו סעיף קודם - מדובר בתאים שמכילים ערכים שמתארים מקבץ תצפיות.\n\nכמו כן, יש עוד כל מיני חריגות לא ברורות בקובץ כגון תאים שמודגשים במסגרת גבול שחורה (מבלי שברור מה המסגרת אומרת), יש תאים שמכילים שתי נקודות (לא ברור מה זה, האם ערך חסר?), שמות המשתנים לעיתים מפוצלים על פני שתי שורות (כמו לדוגמה “ערב פסח” בעמודה F), ועוד בעיות.\nבסיכומו של עניין - אילו היינו רוצים לקלוט קובץ כזה לתוך R על מנת לחלץ את המספרים שבו, היינו צריכים להתאמץ רבות על מנת להפוך את הקובץ למסודר. באופן כללי, ניתן לומר שקבצי אקסל הם מתכון לאסון כי הם מעודדים את המשתמשים לבנות קבצים לא-מסודרים על ידי ביצוע פעולות כמו מיזוג תאים, צביעה של תאים (שזה אינדיקציה לקידוד מידע כלשהו, אבל קידוד שקשה להבין אותו ב”שפת הנתונים”), ועוד שאר בעיות שאין זה המקום לתאר.\n\n\n3.1.2 דאטה tidy\nהנה דוגמה לדאטה מסודר מתוך חבילת palmerpenguins. חבילה זו מכילה נתונים של שלושה זנים של פינגוינים, ואנחנו עוד נשתמש בה בהמשך הספר. לכרגע רק נראה איך נראות עשרת השורות הראשונות בטבלת הנתונים (הסבר על הקוד והתוצר שרואים מצורף מטה):\n\npalmerpenguins::penguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n\n\nאנחנו רואים שהאובייקט הוא מסוג tibble (טבלה שהיא גרסה מודרנית יותר של ה-data.frame הבסיסי ב-R). לטבלה הזו יש 344 תצפיות (פינגוינים), ויש לה 8 עמודות (משתנים) שכוללים את הזן של הפינגוין, מאיזה אי הוא, אורך ועומד המקור, אורך הכנף, מסה, מין, והשנה שבה נצפתה הדגימה. הדאטה הזה מסודר ועומד בכללים שהגדרנו.\nלגבי הקוד עצמו שבו השתמשנו: השימוש בנקודותיים :: אומר ל-R לקחת את האובייקט penguins שנמצא בתוך חבילת palmerpenguins (אפשר גם היה לפצל את הקוד וקודם להשתמש ב-library(palmerpenguins) ואז להריץ את head(penguins).\nאם תרצו להריץ את הקוד הזה אצלכם במחשב, יכול להיות שתצטרכו קודם להתקין את החבילה על ידי שימוש בפקודה install.packages(\"palmerpenguins\").\nכעת לאחר שלמדנו קצת על מה הוא דאטה מסודר, נראה איך אפשר לקרוא נתונים ו”להציץ” בנתונים, כדי לקבל מושג מה יש בנתונים ואיך לגשת אליהם."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#הצצה-ראשונית",
    "href": "03-data-munging-tidyverse.html#הצצה-ראשונית",
    "title": "3  הכנת נתונים",
    "section": "3.2 הצצה ראשונית",
    "text": "3.2 הצצה ראשונית\nבדרך כלל לפני הצצה ראשונית על הנתונים, אנחנו נידרש לקרוא אותם. קריאת הנתונים יכולה להתבצע ממגוון פורמטים. לדוגמה:\n\nקריאה מפורמט של CSV (Comma Separated Values, קרי קובץ טקסט המפריד ערכים באמצעות פסיקים), באמצעות פונקציות כגון read.csv, readr::read_csv.\nקריאה מפורמט של אקסל באמצעות פונקציה כגון: readxl::read_excel.\nקריאה מפורמט של תוכנות סטטיסטיות אחרות כגון SPSS או SAS באמצעות פקודות מחבילת haven.\nפורמטים וכלים נוספים.\n\nנתמקד בקבצי CSV, הפקודה המועדפת עלי היא readr::read_csv (בהשוואה ל-read.csv שנמצאת ב-Base R). הפקודה read_csv מעט מהירה ונוחה יותר מבחינת השליטה שהיא מאפשרת בקריאת הנתונים.\n\nקראו את התיעוד של read.csv ושל read_csv. איזה הבדלים אתם מזהים בין הפקודות?\nלצורך קריאת התיעוד ניתן לכתוב ב-Console ?read.csv, ?readr::read_csv.\n\nנקרא כעת את טבלת הPenguins שראינו בחלק הקודם. שימו לב שאנחנו משתמשים במיקום קובץ באינטרנט, אבל ניתן גם לקרוא קבצים שנמצאים מקומית על המחשב.\n\nlibrary(readr)\npenguins <- read_csv(\"https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv\")\n\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (5): bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nעל מנת להציץ בדאטה יש מספר פקודות שניתן להשתמש בהן:\n\nהפקודה View (עם V גדולה) - פקודה זו מתאימה לדאטה בגודל קטן עד בינוני, והיא מציגה טבלה עם הנתונים.\nהפקודה glimpse תציג את הערכים הראשונים של כל אחד מהמשתנים, כמו גם את שמות המשתנים, ואת סוגם.\nהפקודה head תציג טבלה המוגבלת לשש התצפיות הראשונות. אפשר להשתמש בארגומנט של הפונקציה על מנת להציג יותר שורות. הפקודה tail עובדת באופן דומה (רק מתחתית הטבלה).\nלכתוב ב-Console את שם הטבלה וללחוץ על Enter פשוט יציג את הטבלה (אם מדובר בtibble אז היא תוצג בפורמט קומפקטי ונוח).\n\n\nlibrary(tidyverse)\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <dbl> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\nhead(penguins)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>   <chr>              <dbl>         <dbl>             <dbl>       <dbl>\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex <chr>, year <dbl>\n\nhead(penguins, 10)\n\n# A tibble: 10 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <dbl>       <dbl>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 2 more variables: sex <chr>, year <dbl>\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>              <dbl>         <dbl>             <dbl>       <dbl>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <chr>, year <dbl>\n\n\n\nעברו על הפלט וודאו שאתם מצליחים להבין אילו חלקים בכל אחד מהפלטים מספק את המידע: סוג המשתנה, שם המשתנה, גודל הטבלה.\n\nבמבט על הפלט של כל אחת מהפקודות להלן ניתן כבר להבין את הפרטים הבאים:\n\nהאובייקט שאנחנו בוחנים הוא טבלה מסוג tibble, בגודל של 344 שורות (תצפיות), ו-8 עמודות (משתנים).\nסוגי המשתנים הם מחרוזות (character - chr), מספרים ממשיים (double - dbl).\n\nמחרוזות: species, island, sex\nמספרים ממשיים: bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year.\n\n\nכעת, לאחר שלמדנו איך להבין את מבנה הדאטה באופן ראשוני, נציג פונקציות שמשמשות לשינוי משתנים (טרנספורמציות)."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#טרנספורמציות",
    "href": "03-data-munging-tidyverse.html#טרנספורמציות",
    "title": "3  הכנת נתונים",
    "section": "3.3 טרנספורמציות",
    "text": "3.3 טרנספורמציות\nטרנספורמציה היא פעולה (פונקציה) על משתנה או צירוף של משתנים המניבה משתנה עם ערך חדש. היא יכולה להיות פעולה מתמטית פשוטה כמו לוגריתם, פונקציה טריגונומטרית, או מכפלה בסקלר (ערך כלשהו).\nגם פעולה על מחרוזת היא טרנספורמציה, כגון החזרת אורך המחרוזת או חלק ממחרוזת.\nטרנספורמציות ב-R יבוצעו באמצעות הפקודה mutate, והן יכולות לדרוס ערך קיים או להוסיף משתנה חדש לטבלה. התוצאה תוחזר בטבלה חדשה לגמרי (ולא תדרוס את הטבלה שהוזנה לתוך הפונציה mutate.\nבנוסף, על מנת להפעיל את הטרנספורמציה עם פקודת mutate (ובאופן כללי בשימוש ב-tidyverse) נשתמש באופרטור הנקרא pipe (מקטרת או צינור) ומטרתו להפוך את הקוד ליותר ברור. ישנם שני אופרטורים מסוג pipe: %>% ו-|>. בספר זה נשתמש בנוסח הראשון (הנוסח השני נמצא ב-Base R החל מגרסה 4.0.0).\nלהלן דוגמה המייצרת משתנה חדש (עמודה נוספת) ל-penguins, של משקל בקילוגרמים.\n\nnew_penguins <- penguins %>% \n  mutate(body_mass_kg = body_mass_g/1000)\n\nglimpse(new_penguins)\n\nRows: 344\nColumns: 9\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <dbl> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      <dbl> 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…\n\n\nכפי שניתן לראות האובייקט new_penguins דומה מאוד לאובייקט המקורי penguins (שלא השתנה). האובייקט החדש מכיל עמודה נוספת שהיא המשקל של התצפית בק”ג.\nהאופרטור pipe מסמן ל-R להכניס את הדאטה penguins כארגומנט ראשון בפונקציה mutate. זה שקול לכתיב הבא: mutate(penguins, body_mass_kg = body_mass_g/1000). היתרון בשימוש ב-pipe יבוא לידי ביטוי כאשר נרצה לשרשר מספר רב של פקודות, וללא שימוש ב-pipe נצטרך להכניס פונקציה בתוך פונקציה או להגדיר הרבה אובייקטי ביניים.\nלהלן דוגמה נוספת, הפעם עם טרנספורמציה של מחרוזת, באמצעות פונקציה str_sub (מחבילת stringr) אשר דורסת את המשתנה sex והופכת male ל-m ו-female ל-f. המשתנה נדרס משום שהשם שהגדרנו בתוך הפקודה mutate הינו השם של המשתנה הקיים במקום שם משתנה חדש כפי שעשינו בדוגמה של משקל התצפית.\n\nnew_gender_penguin <- new_penguins %>% \n  mutate(sex = str_sub(sex, start = 1, end = 1))\n\nglimpse(new_gender_penguin)\n\nRows: 344\nColumns: 9\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <dbl> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"m\", \"f\", \"f\", NA, \"f\", \"m\", \"f\", \"m\", NA, NA, NA, N…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      <dbl> 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…"
  },
  {
    "objectID": "03-data-munging-tidyverse.html#שמות-ובחירה",
    "href": "03-data-munging-tidyverse.html#שמות-ובחירה",
    "title": "3  הכנת נתונים",
    "section": "3.4 שמות ובחירה",
    "text": "3.4 שמות ובחירה\nבחירת ושינוי שם משתנים היא פעולה שקוראת הרבה במהלך ניתוח נתונים, ובפרט אם הקובץ המקורי שלנו הוא עם כותרות (headers) בעברית, אז אחד הדברים הראשונים שנרצה לעשות הוא לשנות את שמות העמודות לאנגלית, על מנת שיהיה יותר קל לעבוד עם הנתונים.\nעל מנת לבחור משתנים ניתן להשתמש בפונקציה select ועל מנת לשנות שמות של משתנים ניתן להשתמש בפונקציה rename, לדוגמה, הקוד הבא משנה את שם המשתנה sex ל-gender ואז בוחר אותו.\n\npenguin_gender <- new_gender_penguin %>% \n  select(sex) %>% \n  rename(gender = sex)\n\nglimpse(penguin_gender)\n\nRows: 344\nColumns: 1\n$ gender <chr> \"m\", \"f\", \"f\", NA, \"f\", \"m\", \"f\", \"m\", NA, NA, NA, NA, \"f\", \"m\"…\n\n\nכאשר עובדים עם קובץ שבו כותרות המקור היו בעברית, נצטרך להשתמש ב-Back ticks (המרכאה שנמצאת מעל מקש ה-Tab) על מנת לבחור או לשנות את שם המשתנה. לדוגמה נניח שיש לנו שם של משתנה שנקרא”מגדר” ואנחנו רוצים לשנות אותו ל-gender\n\nmy_hebrew_data %>% \n  rename(gender = `מגדר`)\n\nלאחר שינוי השם ל-gender ניתן יהיה לוותר על ה-Back ticks."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#בחירה-מתקדמת",
    "href": "03-data-munging-tidyverse.html#בחירה-מתקדמת",
    "title": "3  הכנת נתונים",
    "section": "3.5 בחירה מתקדמת",
    "text": "3.5 בחירה מתקדמת\nישנן פונקציות עזר שמאפשרות לנו לבחור בצורה חכמה את המשתנים שעליהם ברצוננו להכיל פעולות מסוימות (כגון טרנספורמציות, שינוי שם, או אפילו רק לבחור משתנים בצורה חכמה). הפונקציות המרכזיות שישמשו אותנו בבחירת משתנים מתקדמת הינן:\n\nwhere כדי להכיל תנאים על סוג המשתנה, לדוגמה משתנה שהוא מספרי או תווים;\nends_with, starts_with, contains, any_of, matches כדי לבחור משתנים לפי תת-מחרוזת שמופיעה בהם;\nacross על מנת להחיל טרנספורמציות על כל המשתנים שעונים על קריטריונים שהוגדרו עם הפונקציות לעיל.\n\nנמחיש באמצעות שתי דוגמאות.\nדוגמה ראשונה: נניח שברצוננו לחלק ב-10 את כל המשתנים שמסתיימים ב-“mm” (בעצם להחליף מיחידות של מילימטר ליחידות של ס”מ). אז ניעזר בפונקציה ends_with(\"mm\") בשביל לזהות את המשתנים הללו, ובפונקציה across על מנת להפעיל עליהם את הטרנספורמציה ~{.x/10} (שזו דרך סימבולית לבנות פונקציה שמחלקת מספר ב-10). התוצאה הסופית תיראה כך. לבסוף נרצה לשנות את “mm” ל- ”cm”.\n\npenguin_cm <- penguins %>% \n  mutate(across(ends_with(\"mm\"), ~{.x/10})) %>% \n  rename_with(~str_replace(.x, \"mm\", \"cm\"),\n              ends_with(\"mm\"))\n\nglimpse(penguin_cm)\n\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_cm    <dbl> 3.91, 3.95, 4.03, NA, 3.67, 3.93, 3.89, 3.92, 3.41, …\n$ bill_depth_cm     <dbl> 1.87, 1.74, 1.80, NA, 1.93, 2.06, 1.78, 1.96, 1.81, …\n$ flipper_length_cm <dbl> 18.1, 18.6, 19.5, NA, 19.3, 19.0, 18.1, 19.5, 19.3, …\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nשימו לב שהשתמשנו בפונקציה rename_with שמאפשרת להגדיר שינוי של קבוצת משתנים בבת אחת במקום משתנים ספציפיים אחד-אחד (המתבצע באמצעות rename).\nדוגמה שניה: נניח שברצוננו לחתוך את כל המשתנים שהן מחרוזות רק לשלושת התווים הראשונים שלהם. הפונקציה באמצעותה חותכים מחרוזות היא str_sub ונשתמש ב-where(is.character) בשביל לאתר את כל המשתנים שהם מחרוזות. נפעיל זאת על התוצאה של החישוב מהדוגמה הקודמת (על מנת לקבל טבלה חדשה שמכילה את כל השינויים במצטבר), באופן הבא:\n\npenguin_short <- penguin_cm %>% \n  mutate(across(where(is.character),\n                ~str_sub(.x, start = 1L, end = 3L)))\n\nglimpse(penguin_short)\n\nRows: 344\nColumns: 8\n$ species           <chr> \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ad…\n$ island            <chr> \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"To…\n$ bill_length_cm    <dbl> 3.91, 3.95, 4.03, NA, 3.67, 3.93, 3.89, 3.92, 3.41, …\n$ bill_depth_cm     <dbl> 1.87, 1.74, 1.80, NA, 1.93, 2.06, 1.78, 1.96, 1.81, …\n$ flipper_length_cm <dbl> 18.1, 18.6, 19.5, NA, 19.3, 19.0, 18.1, 19.5, 19.3, …\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"mal\", \"fem\", \"fem\", NA, \"fem\", \"mal\", \"fem\", \"mal\",…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\nעדכנו את הטבלה כך שלכל המשתנים שהינם מסוג מחרוזת תתווסף הסיומת “_chr”.\nבצעו זאת בשתי דרכים:\n\nבאמצעות rename;\nבבת אחת על ידי שימוש ב-where, וב-paste0, בתוך פקודת rename_with.\n\nכעת השתמשו בפונקציה mutate על מנת להמיר את המשתנה body_mass_g מגרמים לקילוגרמים. בצעו זאת בשתי דרכים:\n\nבאמצעות mutate על ידי רשימת הטרנספורמציה ישירות על המשתנה;\nבאמצעות mutate על ידי שימוש בפונקציות בחירה (לדוגמה ends_with(\"_g\"), ביחד עם across)."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#פעולות-סינון",
    "href": "03-data-munging-tidyverse.html#פעולות-סינון",
    "title": "3  הכנת נתונים",
    "section": "3.6 פעולות סינון",
    "text": "3.6 פעולות סינון\nפעולה נפוצה בניתוח נתונים היא סינון של הנתונים לפי קריטריונים מסוימים. הפקודה שמסייעת לנו בסינון נקראת filter, ואפשר להגדיר באמצעותה קריטריונים או שילוב של קריטריונים שונים.\nלדוגמה, הקוד הבא יסנן מתוך הדאטה רק פינגויינים שחיים באי Dream:\n\npenguins %>% \n  filter(island == \"Dream\")\n\n# A tibble: 124 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>           <dbl>         <dbl>             <dbl>       <dbl>\n 1 Adelie  Dream            39.5          16.7               178        3250\n 2 Adelie  Dream            37.2          18.1               178        3900\n 3 Adelie  Dream            39.5          17.8               188        3300\n 4 Adelie  Dream            40.9          18.9               184        3900\n 5 Adelie  Dream            36.4          17                 195        3325\n 6 Adelie  Dream            39.2          21.1               196        4150\n 7 Adelie  Dream            38.8          20                 190        3950\n 8 Adelie  Dream            42.2          18.5               180        3550\n 9 Adelie  Dream            37.6          19.3               181        3300\n10 Adelie  Dream            39.8          19.1               184        4650\n# ℹ 114 more rows\n# ℹ 2 more variables: sex <chr>, year <dbl>\n\n\nדוגמה נוספת לחיתוך מורכב יותר היא להחזיר את כל הפינגויינים ממין זכר או מין לא ידוע שחיים באי Dream:\n\npenguins %>% \n  filter(!is.na(sex) | sex == \"male\") %>% \n  filter(island == \"Dream\")\n\n# A tibble: 123 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <chr>   <chr>           <dbl>         <dbl>             <dbl>       <dbl>\n 1 Adelie  Dream            39.5          16.7               178        3250\n 2 Adelie  Dream            37.2          18.1               178        3900\n 3 Adelie  Dream            39.5          17.8               188        3300\n 4 Adelie  Dream            40.9          18.9               184        3900\n 5 Adelie  Dream            36.4          17                 195        3325\n 6 Adelie  Dream            39.2          21.1               196        4150\n 7 Adelie  Dream            38.8          20                 190        3950\n 8 Adelie  Dream            42.2          18.5               180        3550\n 9 Adelie  Dream            37.6          19.3               181        3300\n10 Adelie  Dream            39.8          19.1               184        4650\n# ℹ 113 more rows\n# ℹ 2 more variables: sex <chr>, year <dbl>\n\n\nבדוגמה זו ביצענו שני חיתוכים אחד אחרי השני, כאשר הראשון מכיל אופרטור “או” (תנאי מגדר שווה זכר או ערך חסר), והחיתוך השני נותר כפי שהיה בדוגמה הקודמת. בצורה כזו קיבלנו הפעלה של שני התנאים (“וגם”).\nניתן גם להשתמש במספר ארגומנטים בתוך פקודת filter אחת (הפרדה עם פסיק), וניתן גם להשתמש באופרטור &. לדוגמה, שתי הגרסאות הבאות יניבו את אותה התוצאה:\n\npenguins %>% \n  filter(!is.na(sex) | sex == \"male\",\n         island == \"Dream\") \n\npenguins %>% \n  filter((!is.na(sex) | sex == \"male\") &\n         island == \"Dream\") \n\n\nהיעזרו בפקודה filter וכתבו קוד שיחלץ את כל הפינגווינים מסוג Adelie או Chinstrap, בשלוש דרכים שונות:\n\nעל ידי שימוש באופרטור %in% (בתוך…)\nעל ידי שימוש באופרטור != (שונה מ…)\nעל ידי שימוש באופרטור | (או)"
  },
  {
    "objectID": "03-data-munging-tidyverse.html#פעולות-לפי-קיבוצים",
    "href": "03-data-munging-tidyverse.html#פעולות-לפי-קיבוצים",
    "title": "3  הכנת נתונים",
    "section": "3.7 פעולות לפי קיבוצים",
    "text": "3.7 פעולות לפי קיבוצים\nבעת ניתוח נתונים, פעולה המבוצעת באופן תדיר היא פעולת סיכום לפי קיבוצים. היא שימושית במצבים בהם אנחנו רוצים להפעיל פונקציה וקטורית, כזו שמקבלת וקטור ומחזירה ערך בודד (כגון: ממוצע, מינימום, מקסימום, סטיית תקן, חציון, סכום, וכו’). פעולה לפי קיבוץ תאפשר לנו לקבל בבת אחת את הפעלת הפונקציה הוקטורית על פני קבוצות שונות המובחנות בנתונים.\nנמשיך עם דוגמת הפינגווינים. נניח שאנחנו רוצים להשוות בין הזנים השונים, ועבור כל זן פינגווינים לחשב את המשקל הממוצע, סטיית התקן, משקל מינימלי ומשקל מקסימלי בין התצפיות. הקוד הבא מטפל בחישובים הללו, ויש לו שתי פונקציות חשובות שנסביר עליהן: group_by ו-summarize.\n\npenguins %>% \n  filter(!is.na(body_mass_g)) %>% \n  group_by(species) %>% \n  summarize(avg_mass = mean(body_mass_g),\n            min_mass = min(body_mass_g),\n            max_mass = max(body_mass_g),\n            sd_mass = sd(body_mass_g))\n\n# A tibble: 3 × 5\n  species   avg_mass min_mass max_mass sd_mass\n  <chr>        <dbl>    <dbl>    <dbl>   <dbl>\n1 Adelie       3701.     2850     4775    459.\n2 Chinstrap    3733.     2700     4800    384.\n3 Gentoo       5076.     3950     6300    504.\n\n\nקיבלנו טבלה בעלת שלוש שורות, כל שורה מתייחסת לזן מסוים של פינגויינים, ומציגה את המשקל הממוצע, מינימלי, מקסימלי, וסטיית תקן.\nמשמעות שרשרת הפקודות:\n\nהפקודה הראשונה filter משמשת כדי להוציא החוצה תצפיות חסרות.\nהפקודה הבאה group_by מנחה לבצע את החישובים שאחריה לפי הקיבוץ המוגדר (במקרה זה לפי המשתנה species.\nהפקודה האחרונה בשרשרת, summarize, מזכירה קצת את mutate עליה הסברנו בחלק של טרנספורמציות, אבל מכיוון שבמקרה זה מדובר בחישובים שמקבלים וקטור ומחזירים מספר, אנחנו צריכים להשתמש בה. היא יודעת לעבוד עם הקיבוצים שהוגדרו ולהחזיר את החישובים המבוקשים. בתוך הפקודה summarize אנחנו מגדירים איזה חישובים אנחנו רוצים, וגם מהם שמות המשתנים החדשים. בדוגמה הגדרנו את avg_mass כמשתנה חדש שהוא תוצאת החישוב של הפונקציה mean על המשתנה המקורי שנקרא body_mass_g, וכנ”ל עבור יתר המשתנים (min_mass, max_mass, sd_mass).\n\nבפקודה group_by ניתן להגדיר קיבוצים לפי מספר משתנים.\n\nשנו את הקוד בדוגמה האחרונה כך שתתקבל טבלה עם שש שורות, הכוללת חישובים עבור כל זן ומין הפינגויין.\n\n\nהסבירו מדוע הקוד הבא אינו עובד:\n\npenguins %>% \n  filter(!is.na(body_mass_g)) %>% \n  group_by(species) %>% \n  summarize(avg_mass = mean(body_mass_g)) %>% \n  summarize(min_mass = min(body_mass_g))\n\n\n\n3.7.1 פעולות סיכום מורכבות\nאת הפונקציה across הכרנו כבר בשלב מוקדם יותר בפרק זה (כשהסברנו על הפוקנציה mutate). באופן אמצעות שימוש בפקודה across ניתן להגדיר פעולות סיכום מורכבות על פני קיבוצים שונים ועל פני מספר משתנים רב. לדוגמה, נניח שאנו רוצים לקבל ממוצע של כל המשתנים הנומריים על פני סוגים שונים של פינגווינים. נוכל לעשות זאת באמצעות הקוד הבא:\n\npenguins %>% \n  filter(!is.na(body_mass_g)) %>% \n  group_by(species) %>% \n  summarize(across(bill_length_mm:body_mass_g,\n                   mean))\n\n# A tibble: 3 × 5\n  species   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <chr>              <dbl>         <dbl>             <dbl>       <dbl>\n1 Adelie              38.8          18.3              190.       3701.\n2 Chinstrap           48.8          18.4              196.       3733.\n3 Gentoo              47.5          15.0              217.       5076.\n\n\n\nיש הרבה הכללות שניתן לעשות עם הקוד הקודם, לדוגמה באופן בחירת המשתנים עליהם עובדת הפקודה, בהגדרת הפונקציה, או בהגדרת הרבה פונקציות בבת אחת.\nכדוגמה שממנפת הרבה מהגמישות אליה ניתן להגיע אנחנו מצרפים את הקוד הבא. הקוד מחשב עבור כל המשתנים שמסתיימים ב \"_mm\" ממוצע, וסטיית תקן, תוך שהחישובים מתעלמים מערכים חסרים באמצעות שימוש בארגומנט na.rm=TRUE של הפונקציות mean, sd. הקוד משתמש בקיבוץ לפי סוג הפינגויין והאי ממנו הגיע.\nנסו לנתח ולהבין כל שורה מהקוד ועל מה היא אחראית.\n\npenguins %>% \n  group_by(species, island) %>% \n  summarize(across(ends_with(\"mm\"),\n                   list(avg = ~mean(., na.rm = T),\n                        sd = ~sd(., na.rm = T))))\n\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 8\n# Groups:   species [3]\n  species   island    bill_length_mm_avg bill_length_mm_sd bill_depth_mm_avg\n  <chr>     <chr>                  <dbl>             <dbl>             <dbl>\n1 Adelie    Biscoe                  39.0              2.48              18.4\n2 Adelie    Dream                   38.5              2.47              18.3\n3 Adelie    Torgersen               39.0              3.03              18.4\n4 Chinstrap Dream                   48.8              3.34              18.4\n5 Gentoo    Biscoe                  47.5              3.08              15.0\n# ℹ 3 more variables: bill_depth_mm_sd <dbl>, flipper_length_mm_avg <dbl>,\n#   flipper_length_mm_sd <dbl>"
  },
  {
    "objectID": "03-data-munging-tidyverse.html#סיכום",
    "href": "03-data-munging-tidyverse.html#סיכום",
    "title": "3  הכנת נתונים",
    "section": "3.8 סיכום",
    "text": "3.8 סיכום"
  },
  {
    "objectID": "04-visualizations-ggplot2.html#הבסיס",
    "href": "04-visualizations-ggplot2.html#הבסיס",
    "title": "4  ויז’ואליזציות",
    "section": "4.1 הבסיס",
    "text": "4.1 הבסיס\nנתחיל בגרף פשוט, ונתקדם ממנו לסדרה של גרפים.\n\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n\n\npenguins %>% \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm)) + \n  geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nראשית מבחינת הנתונים המוצגים, לא ניתן להבחין בקשר משמעותי. במידה מסוימת נראה שעליה במשתנה bill_length_mm מעידה על ירידה במשתנה bill_depth_mm (כי ככל שמתקדמים בציר ה-x יש ירידה קלה של התצפיות בציר ה-y). זוהי מסקנה שגויה, ותיכף נבין למה, אבל לפני כן, עוד מספר הסברים\nהודעת האזהרה שמופיעה מעל הגרף מיידעת אותנו שיש שתי שורות שאינן באות לידי ביטוי בתרשים בשל ערכים חסרים (חסר נתון על אורך או עומק או שניהם).\nבנוגע לתחביר:\n\nהפונקציה ggplot מגדירה תרשים.\nהארגומנט הראשון שלה הוא הדאטה עצמו (penguins), שנכנס באמצעות האופרטור %>%.\nהארגומנט השני נכנס כפונקציה aes() שמגדירה אסטטיקות. במקרה זה מוגדרים שני מיפויי אסטטיקות, לציר x ולציר y.\nלאחר מכן יש חיבור + על מנת להוסיף שכבה של גיאומטריה מסוג נקודה geom_point, וקיבלנו גרף."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#מיפויים-נוספים",
    "href": "04-visualizations-ggplot2.html#מיפויים-נוספים",
    "title": "4  ויז’ואליזציות",
    "section": "4.2 מיפויים נוספים",
    "text": "4.2 מיפויים נוספים\nכעת ניזכר שבדאטה מיוצגים שלושה זנים של פינגויינים, וייתכן שהקשר גם מושפע מעובדה זו. נוסיף מיפוי של זן הפינגויין לצבע של הנקודות. הוספה זו תתבצע עם הארגומנט color=species:\n\npenguins %>% \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             color = species)) + \n  geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nכעת לאחר הוספת הצבע ניתן להבחין בבירור בכך שבכל אחד מהזנים עליה במשתנה bill_length_mm מביאה לעלייה במשתנה bill_depth_mm (וזה בעצם הפוך למה שחשבנו כשהסתכלנו על התרשים מבלי לחלק לזנים של הפינגויינים השונים). זו תובנה מאוד משמעותית, שנקראת בשפה המקצועית “אינטראקציה”. יש אינטראקציה בין אורך המקור לבין זן הפינגויין בהשפעתם על עומק המקור. ניגע באינטראקציות גם בהמשך (בפרק על רגרסיה לינארית).\n\nכדאי להכיר - “פרדוס סימפסון”: התופעה שבה הבחנו בשינוי המשמעות של הקשר בין המשתנים כאשר מוסיפים אינטראקציה או זיהוי של הקבוצה, תוארה על ידי סימפסון (Simpson 1951). אחד מהגילגולים המודרנים של הפרדוקס הזה נמצא בדאטהסט שנוצר על ידי סימולציה ונקרא Datasaurus dozen (ראו Murray and Wilson 2021).\nב-Datasaurus משתמשים בסימולציה כדי לייצר שנים עשר קבוצות שבפני עצמן נראות זהות בפרמטרים מסוימים (ממוצע בציר x, ממוצע בציר y, סטיית תקן, קורלציה, וכו’), אבל כשמציגים את הנקודות בדיאגרמת פיזור, באופן מובחן בין הקבוצות, מקבלים את התרשים הבא:\n\nlibrary(datasauRus)\ndatasaurus_dozen %>% \n  group_by(dataset) %>% \n  summarize(mean(x),\n            mean(y),\n            sd(x),\n            sd(y),\n            cor(x, y))\n\n# A tibble: 13 × 6\n   dataset    `mean(x)` `mean(y)` `sd(x)` `sd(y)` `cor(x, y)`\n   <chr>          <dbl>     <dbl>   <dbl>   <dbl>       <dbl>\n 1 away            54.3      47.8    16.8    26.9     -0.0641\n 2 bullseye        54.3      47.8    16.8    26.9     -0.0686\n 3 circle          54.3      47.8    16.8    26.9     -0.0683\n 4 dino            54.3      47.8    16.8    26.9     -0.0645\n 5 dots            54.3      47.8    16.8    26.9     -0.0603\n 6 h_lines         54.3      47.8    16.8    26.9     -0.0617\n 7 high_lines      54.3      47.8    16.8    26.9     -0.0685\n 8 slant_down      54.3      47.8    16.8    26.9     -0.0690\n 9 slant_up        54.3      47.8    16.8    26.9     -0.0686\n10 star            54.3      47.8    16.8    26.9     -0.0630\n11 v_lines         54.3      47.8    16.8    26.9     -0.0694\n12 wide_lines      54.3      47.8    16.8    26.9     -0.0666\n13 x_shape         54.3      47.8    16.8    26.9     -0.0656\n\ndatasaurus_dozen %>% \n  ggplot(aes(x = x, y = y)) + \n  geom_point() + \n  facet_wrap(~dataset)\n\n\n\n\nבתרשים זה השתמשנו גם בפונקציות שראינו קודם, וגם בפונקציה נוספת שנקראת facet_wrap שמפרקת את התרשים לתתי-תרשימים, בכל אחד נמצאים הנתונים של קבוצה אחרת (מהמשתנה dataset)."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#כותרות-גרף-וצירים",
    "href": "04-visualizations-ggplot2.html#כותרות-גרף-וצירים",
    "title": "4  ויז’ואליזציות",
    "section": "4.3 כותרות גרף וצירים",
    "text": "4.3 כותרות גרף וצירים\nכעת נייפה את הגרף עם כותרות:\n\npenguins %>% \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             color = species)) + \n  geom_point() + \n  xlab(\"Bill length [mm]\") + \n  ylab(\"Bill depth [mm]\") + \n  ggtitle(\"Relationship of bill length and depth in penguins\", \n          subtitle = \"Interaction with species\")\n\nWarning: Removed 2 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#הגדרת-תמות",
    "href": "04-visualizations-ggplot2.html#הגדרת-תמות",
    "title": "4  ויז’ואליזציות",
    "section": "4.4 הגדרת תמות",
    "text": "4.4 הגדרת תמות\nניתן להגדיר תמות (Themes) שיתנו לגרף חזות אחרת. בחבילת ggplot2 יש כמה תמות מוגדרות מראש שניתן להתחיל מהם וגם לעצב אותן מחדש. כדוגמה, נשתמש בתמה מסוג linedraw ונגדיר מחדש את מיקום המקרא ואת גודל הטקסט של הכותרות.\n\npenguins %>% \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             color = species)) + \n  geom_point() + \n  xlab(\"Bill length [mm]\") + \n  ylab(\"Bill depth [mm]\") + \n  ggtitle(\"Relationship of bill length and depth\", \n          subtitle = \"Interaction with species\") + \n  theme_linedraw() + \n  theme(legend.position = \"top\",\n        plot.title = element_text(size = 22),\n        axis.title = element_text(size = 15),\n        legend.box.background = element_rect(linetype = 1, linewidth = 1))\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nרוב הרכיבים בתוך התרשים נשלטים בתוך הפונקציהtheme באמצעות פונקציות הכוונה כגון element_text (מאפייני טקסט), element_rect (מאפייני תחום מרובע), element_line (מאפייני קווים), וכו’. בתיעוד הפקודה theme ניתן לעיין באפשרויות השונות.\n\n\nהשתמשו בפקודה facet_wrap כשכבה נוספת לתרשים הקודם על מנת לפצל את הזנים השונים לתתי-תרשימים. הדגמה לשימוש בפקודה נמצאת בחלק הקודם של פרק זה (בקוד שמסביר על פרדוקס סימפסון)."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#גיאומטריות-נוספות",
    "href": "04-visualizations-ggplot2.html#גיאומטריות-נוספות",
    "title": "4  ויז’ואליזציות",
    "section": "4.5 גיאומטריות נוספות",
    "text": "4.5 גיאומטריות נוספות\nנדגים מספר גיאומטריות נוספות מההיצע הרב שיש בחבילת ggplot2. שימו לב, בסוף הפרק מדריך שיסייע לכם להחליט באיזה תרשים כדאי להשתמש לפי סוג המשתנים או היחס בין משתנים שאתם רוצים להדגים.\n\n4.5.1 Boxplot\nדיאגרמה מסוג Boxplot עוזרת לנו להבין את צורת ההתפלגות. הדיאגרמה מציגה “קופסה” שתוחמת 50% מהנתונים (החלק התחתון של הקופסה הוא רבעון ראשון, והחלק העליון של הקופסה הוא רבעון שלישי). במרכזה של הקופסה מוצג החציון קקו עבה (מחלק את התצפיות לחצי-חצי). ערכי קיצון, אם ישנם, מופיעים כנקודות. במידה ומופיעה קופסה שאינה סימטרית סביב החציון, הדבר מעיד על כך שההתפלגות אינה התפלגות נורמלית.\nנציג את התפלגות המשקל של הפינגויינים בתרשים, בהפרדה לפי זן הפינגויינים, ומיד לאחריו נציג את החציון, ורבעונים של כל קבוצה.\n\npenguins %>% \n  ggplot(aes(y = body_mass_g, x = species)) + \n  geom_boxplot() + \n  ggtitle(\"Penguin weight\") + \n  xlab(\"Species\") + \n  ylab(\"Mass [grams]\")\n\nWarning: Removed 2 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\npenguins %>% \n  filter(!is.na(body_mass_g)) %>% \n  group_by(species) %>% \n  summarize(median_mass = median(body_mass_g),\n            q1_mass = quantile(body_mass_g, 0.25),\n            q3_mass = quantile(body_mass_g, 0.75))\n\n# A tibble: 3 × 4\n  species   median_mass q1_mass q3_mass\n  <fct>           <dbl>   <dbl>   <dbl>\n1 Adelie           3700   3350     4000\n2 Chinstrap        3700   3488.    3950\n3 Gentoo           5000   4700     5500\n\n\nאיך מזהים ערכי קיצון?\nערכי קיצון היא בעיה בפני עצמה ואפשר להקדיש לה פרק, ואפילו ספר שלם. יש לערכי קיצון השלכות משמעותיות במגוון שימושים, החל ממודלים (כמו רגרסיה שנלמד עליה בספר זה) וחישובים שונים (ממוצע לדוגמה מושפע מאוד מערכי קיצון), דרך זיהוי אנומליות.\nערכי הקיצון מחושבים כ-1.5*טווח בין רבעוני מהרבעון הראשון מטה או מהרבעון השלישי מעלה, כלומר נקודות אשר מרוחקות לפחות פי 1.5 הטווח הבין רבעוני (הטווח “הסביר”) ביחס לרבעונים.\nאם נמחיש זאת על קבוצת הפינגויינים מסוג Chinstrap. הרבעון הראשון מתקבל ב-3488 גרם, והרבעון השלישי מתקבל ב-3950 גרם. הטווח הבין רבעון לכן הינו 462. כלומר הטווח הבין רבעוני כפול 1.5 הינו 693.\nכלומר, כל נקודה שנמצאת מחוץ לתחום של [3950+693, 3488-693] תיחשב כערך חריג ותסומן כנקודה.\n\nextreme_hinges <- c(3488-693, 3950+693)\nextreme_hinges\n\n[1] 2795 4643\n\npenguins %>% \n  filter(species == \"Chinstrap\") %>% \n  filter(body_mass_g < extreme_hinges[1] | body_mass_g > extreme_hinges[2])\n\n# A tibble: 2 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  <fct>     <fct>           <dbl>         <dbl>             <int>       <int>\n1 Chinstrap Dream            52            20.7               210        4800\n2 Chinstrap Dream            46.9          16.6               192        2700\n# ℹ 2 more variables: sex <fct>, year <int>\n\n\n\n\n4.5.2 צפיפות\nתרשים נוסף שיכול לסייע בהבנת צורת ההתפלגות הינו תרשים שמציג את הצפיפות (תזכורת: פונקצית צפיפות הינה הפונקציה שהשטח שמתחת לה מהווה את פונקצית ההתפלגות. לגובה של פונקצית צפיפות אין משמעות בערך בפני עצמו, אלא רק בכך שסך האינטגרל מתחת לפונקצית הצפיפות שווה 1). הצפיפות יכולה להראות לנו האם ההתפלגות סימטרית, האם היא בעלת מודל אחד (פיק יחיד כמו בהתפלגות נורמלית) או בי-מודלית (שני פיקים, כמו בהרכבה של שתי התפלגויות נורמליות), וכן היא יכולה לסייע לנו להבין האם יש התפלגות אחרת שמתאימה לתיאור הנתונים. הפקודה שמייצרת גרף צפיפות היא geom_density.\n\npenguins %>% \n  ggplot(aes(x = body_mass_g, color = species)) + \n  geom_density() + \n  ggtitle(\"Penguin weight: density functions\") + \n  xlab(\"Body mass [grams]\") + \n  ylab(\"Density\")\n\nWarning: Removed 2 rows containing non-finite values (`stat_density()`).\n\n\n\n\n\nכמה הבדלים בולטים מהתרשים:\n\nניתן לראות שהשונות (הפיזור) במשקל הגוף גדול יותר בסוג Gentoo, וגם ב-Adelie קצת יותר מב-Chinstrap.\nניתן לראות שב-Gentoo יש התפלגות בי-מודלית (שתי גבעות).\nניתן לראות ששני הזנים Adelie ו-Chinstrap בעלי התפלגות סביב אותו משקל גוף.\n\n\nנסו לשער מה מקור ההתפלגות הבי-מודלית בפינגויינים מזן Gentoo. בדקו את השערתכם עם תרשימים מתאימים.\nרמז - נסו לבחון האם פיצול ה-Gentoo לפי משתנה נוסף מייצג שני גרפים בעלי דמיון רב יותר להתפלגות נורמלית (סימטרית ובעלת פיק יחיד).\n\n\n\n4.5.3 היסטוגרמה\nהיסטוגרמה הוא גרף נוסף שנועד להציג התפלגות של משתנים רציפים, על ידי שבירה של הערכים הרציפים לערכים בדידים (קבוצות טווחים), בשונה מהגרפים הקודמים.\nבנייה של היסטגרמה תתבצע באמצעות הפונקציה geom_histogram.\n\npenguins %>% \n  ggplot(aes(x = body_mass_g, fill = species)) + \n  geom_histogram() + \n  ggtitle(\"Penguin weight: histogram\") + \n  xlab(\"Body mass [grams]\") + \n  ylab(\"Counts [# observations]\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\nניתן לשלוט במספר העמודות (ה-bins) על ידי הגדרה של הארגומנט bins= בתוך הפונקציה geom_histogram. הערך ברירת המחדל הינו 30 בינים.\n\n\n4.5.4 בארים\nבארים הם גרף עמודות. יש שתי גיאומטריות שמסייעות לנו בגרף עמודות: geom_bar ו-geom_col. ההבדל המרכזי ביניהן הוא ש-geom_bar מקבלת דאטה גולמי וסופרת, בעוד ש-geom_col מקבלת מוצר סופי. נמחיש זאת בדוגמה שמתארת את מספר התצפיות מכל סוג:\n\npenguins %>% \n  ggplot(aes(species)) + \n  geom_bar() + \n  ggtitle(\"Number of penguins of eash species (geom_bar)\")\n\n\n\npenguins %>% \n  count(species) %>% \n  ggplot(aes(x = species, y = n)) + \n  geom_col() + \n  ggtitle(\"Number of penguins of eash species (geom_col)\")\n\n\n\n\nשתי הפקודות עם אותו הפלט בדיוק. אני באופן אישי מעדיף את השימוש ב-geom_col משום שיותר קל לעשות לה debug (בכך שנראה מה הדאטה שנכנס פנימה).\nגרף בארים יכול להציג גם יותר ממשתנה אחד, לדוגמה אפשר להשתמש בו על מנת להציג את ההתפלגות של משתנה מסוים כפונקציה של משתנים אחר (קשר בין שני משתנים בדידים). נדגים זאת בתרשים הבא שיציג את התפלגות הדגימות של זנים שונים כפונקציה של מגדר.\n\npenguins %>% \n  filter(!is.na(sex)) %>% \n  count(species, sex) %>% \n  ggplot(aes(x = sex, fill = species, y = n)) + \n  geom_col(position = position_fill()) + \n  ggtitle(\"Distribution of species for each gender\") + \n  scale_y_continuous(labels = scales::percent) + \n  ylab(\"Proportion [%]\") + \n  xlab(\"Sex\")\n\n\n\n\nניתן לראות מהתרשים שהתפלגות הדגימה של הזנים דומה בין שני המגדרים תמהיל של כ-20% מסוג Chinstrap, 36% מסוג Gentoo, והיתר ממין Adelie.\nהפונקציה position_fill מגדירה שיש לערום את הבארים אחד על השני כך שיסתכמו ל-100%, ישנן שתי אפשרויות נוספות: position_dodge, ו-position_stack.\n\nנסו להחליף את הפונקציה position_fill בפונקציות האחרות (position_dodge, position_stack). באילו מקרים תשמשו בכל אחת מהפונקציות הללו?\n\n\nצרו תרשים הפוך שבו מוצגת התפלגות המין של הפנגויינים לפי הזן (להפוך את התפקידים של ציר ה-x והמילוי של העמודות)."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#שליפים",
    "href": "04-visualizations-ggplot2.html#שליפים",
    "title": "4  ויז’ואליזציות",
    "section": "4.7 שליפים",
    "text": "4.7 שליפים\nמכיוון שחבילת ggplot2 היא חבילה עשירה מאוד בפיצ’רים, אנחנו לא מתיימרים להציג את כלל מנעד היכולות שלה. בכל מקרה, ובמיוחד בשלבי הלמידה וההתנסויות הראשונות עם יצירת תרשימים, מומלץ להיעזר גם ב-Cheatsheet שהפיקו בחברת Posit (לשעבר RStudio), שמאפשר לראות מה סוג התרשים הנדרש לכל סיטואציה (לדוגמה, איזה תרשים, ומה הקוד של תרשים, שיציג “קשר בין שני משתנים אחד רציף והשני בדיד”). קישור ל-Cheatsheet."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#סיכום",
    "href": "04-visualizations-ggplot2.html#סיכום",
    "title": "4  ויז’ואליזציות",
    "section": "4.7 סיכום",
    "text": "4.7 סיכום\nבפרק זה למדנו להפיק תרשימים באמצעות חבילת ggplot2. דנו בייחודיות של החבילה בהיבט התיאוריה שמבססת אותה (the grammar of graphics), והבנו כיצד יש לתכנן תרשים (באמצעות מיפויים, גיאומטריות, והגדרות נוספות).\nראינו דוגמאות לגיאומטריות מסוימות כגון boxplot, היסטוגרמה, צפיפויות, וגרף בארים.\nלבסוף ראינו כיצד ניתן לתכנן תרשים באמצעות בחינה של סוגי המשתנים והקשרים שאנחנו רוצים לזהות, וראינו דוגמה לתרשים אשר קושר בין ארבעה משתנים שונים, ומבוסס על מודל של רגרסיה לינארית.\n\n\n\n\nMurray, Lori L., and John G. Wilson. 2021. “Generating Data Sets for Teaching the Importance of Regression Analysis.” Decision Sciences Journal of Innovative Education 19 (2): 157–66. https://doi.org/10.1111/dsji.12233.\n\n\nSimpson, E. H. 1951. “The Interpretation of Interaction in Contingency Tables.” Journal of the Royal Statistical Society: Series B (Methodological) 13 (2): 238–41. https://doi.org/10.1111/j.2517-6161.1951.tb00088.x.\n\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics 19 (1): 3–28. https://doi.org/10.1198/jcgs.2009.07098."
  },
  {
    "objectID": "05-pivot-and-join.html#מבנה-רחבארוך",
    "href": "05-pivot-and-join.html#מבנה-רחבארוך",
    "title": "5  מבנה וחיבור נתונים",
    "section": "5.1 מבנה רחב/ארוך",
    "text": "5.1 מבנה רחב/ארוך\nאחת מהפעולות השימושיות היא העברה של דאטה בין פורמט ארוך לפורמט רחב. לדוגמה כשרוצים שמשתנים מסוימים יהפכו לתצפיות נוספות, או להיפך. נדגים זאת עם הנתונים של penguins, שראינו בפרקים הקודמים. נוסיף שינוי קטן לקובץ שמזהה כל תצפית באמצעות מזהה penguin_id לשם כך אנו משתמשים בפונקציה seq_along שפשוט נותנת וקטור של מספר רץ בהתאם לתצפיות.\n\n5.1.1 רחב לארוך\nהמבנה הסטנדרטי של הקובץ הוא מבנה רחב - כל פינגויין מופיע בשורה אחת עם כל המשתנים שלו. נניח שאנחנו רוצים להפוך את המבנה לארוך, ושכל פינגויין יופיע מספר פעמים בטבלה, בהתאם לסוג המידע המדווח עליו. לצורך זה נשתמש ב-pivot_longer. הנה תזכורת על המבנה הקיים, והקוד שהופך את המבנה למבנה ארוך:\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\npenguins_w_id <- penguins %>% \n  mutate(penguin_id = seq_along(species))\n\npenguins_w_id\n\n# A tibble: 344 × 9\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 3 more variables: sex <fct>, year <int>, penguin_id <int>\n\nlonger_penguins <- penguins_w_id %>% \n  select(penguin_id, species, contains(\"_mm\")) %>% \n  pivot_longer(cols = -c(species, penguin_id),\n               names_to = \"measurement_type\",\n               values_to = \"measurement_value\")\n\nlonger_penguins\n\n# A tibble: 1,032 × 4\n   penguin_id species measurement_type  measurement_value\n        <int> <fct>   <chr>                         <dbl>\n 1          1 Adelie  bill_length_mm                 39.1\n 2          1 Adelie  bill_depth_mm                  18.7\n 3          1 Adelie  flipper_length_mm             181  \n 4          2 Adelie  bill_length_mm                 39.5\n 5          2 Adelie  bill_depth_mm                  17.4\n 6          2 Adelie  flipper_length_mm             186  \n 7          3 Adelie  bill_length_mm                 40.3\n 8          3 Adelie  bill_depth_mm                  18  \n 9          3 Adelie  flipper_length_mm             195  \n10          4 Adelie  bill_length_mm                 NA  \n# ℹ 1,022 more rows\n\n\nהארגומנט הראשון קובע את המשתנים שהולכים לעבור “pivot”. במקרה הזה הגדרנו אותו על דרך השלילה (-species אומר שכל המשתנים צריכים להשתתף ב-pivot למעט המשתנה species שנותר כעמודה מופרדת).\nהארגומנט names_to קובע את שם העמודה שתכיל את שמות המשתנים במקור, והארגומנט values_to קובע את שם העמודה שתכיל את הערכים שהכילו המשתנים במקור.\n\n\n5.1.2 ארוך לרחב\nהפעולה ההפוכה (הפיכת טבלה ארוכה לטבלה רחבה) יכולה להיעשות באמצעות הפונקציה pivot_wider, באופן הבא:\n\nlonger_penguins %>% \n  pivot_wider(id_cols = c(species, penguin_id),\n              names_from = measurement_type,\n              values_from = measurement_value)\n\n# A tibble: 344 × 5\n   species penguin_id bill_length_mm bill_depth_mm flipper_length_mm\n   <fct>        <int>          <dbl>         <dbl>             <dbl>\n 1 Adelie           1           39.1          18.7               181\n 2 Adelie           2           39.5          17.4               186\n 3 Adelie           3           40.3          18                 195\n 4 Adelie           4           NA            NA                  NA\n 5 Adelie           5           36.7          19.3               193\n 6 Adelie           6           39.3          20.6               190\n 7 Adelie           7           38.9          17.8               181\n 8 Adelie           8           39.2          19.6               195\n 9 Adelie           9           34.1          18.1               193\n10 Adelie          10           42            20.2               190\n# ℹ 334 more rows\n\n\nהתחביר של הפקודה מאוד דומה לתחביר של הפקודה הקודמת. שימו לב שבמקרה זה אפשר להגדיר את שמות המשתנים ללא מרכאות, משום שאלו משתנים קיימים ב-longer_penguins והפקודה יודעת לבחור אותם גם ללא ציון שלהם במרכאות.\n\nנסו להריץ את אותן הפקודות (pivot_longer ואז pivot_wider) על penguins (במקום על penguins_id).\nמה שונה בפלט של כל אחת מהפקודות, ומדוע?"
  },
  {
    "objectID": "05-pivot-and-join.html#חיבור-טבלאות",
    "href": "05-pivot-and-join.html#חיבור-טבלאות",
    "title": "5  מבנה וחיבור נתונים",
    "section": "5.2 חיבור טבלאות",
    "text": "5.2 חיבור טבלאות\nלעיתים בעבודה עם נתונים נדרש חיבור של נתונים ממקורות שונים (או מאותו מקור המאוחסן בטבלאות שונות). זה מאוד מקובל בעבודה עם דאטהבייס. לדוגמה (בהפשטה) חשבו על חברת אשראי שמצד אחד מאחסנת נתונים על לקוחות (גיל, מגדר, כתובת), ומצד שני מאחסנת נתונים של טראנזקציות (פעולות, קרי, חיובי אשראי. שדות כגון מיקום החיוב וסכום החיוב).\nאין סיבה שהטבלה שמאחסנת נתונים של טראנזקציות תכיל גם נתונים של גיל, מגדר, וכתובת, משום שאלו לרוב לא משתנים בין חיוב לחיוב.\nאבל יש מקרים שבהם נרצה לחבר בין הנתונים כדי לנתח אותם ביחד. לדוגמה בשביל לחשב מה ממוצע ההוצאה של גברים לעומת נשים. זה דורש חיבור של טבלת הנתונים על לקוחות עם טבלת הטראנזקציות.\nנדגים זאת בדוגמה קטנה שבה שתי טבלאות. בטבלה הראשונה נתונים על ארבעה לקוחות פיקטיביים של חברת אשראי. אנחנו נשתמש בפקודה tribble כדי להגדיר את הטבלה בקוד.\n\ncustomers <- tribble(~customer_id, ~gender, ~home_address,\n                     1, \"גבר\", \"חיפה\",\n                     2, \"אשה\", \"תל-אביב\",\n                     3, \"גבר\", \"תל-אביב\",\n                     4, \"אשה\", \"חיפה\")\n\ncustomers\n\n# A tibble: 4 × 3\n  customer_id gender home_address\n        <dbl> <chr>  <chr>       \n1           1 גבר    חיפה        \n2           2 אשה    תל-אביב     \n3           3 גבר    תל-אביב     \n4           4 אשה    חיפה        \n\n\nכעת נגדיר טבלה נוספת של הרכישות שביצעו הלקוחות:\n\ntransactions <- tribble(~customer_id, ~expense, ~dealer,    \n                        1, 80, \"Motty's Shawarma\", \n                        1, 12, \"Marina's coffee\",\n                        2, 350, \"Dekek fuel\",\n                        4, 35, \"Train\",\n                        4, 12, \"Rokadin's Crossons\")\n\nניתן לראות שיש לקוחות שביצעו שתי עסקאות, יש לקוחות שביצעו עסקה אחת, ויש לקוחות שלא ביצעו עסקאות בכלל. אנחנו רוצים לחשב כמה כסף בסך הכל הוציאו לקוחות שמתגוררים בחיפה לעומת לקוחות שמתגוררים בתל-אביב.\nנשתמש בפקודה left_join שמחברת בין טבלאות. המשתנה המשותף הוא customer_id והוא יאפשר לנו לחבר בין הטבלאות.\n\ncustomers_transactions <- transactions %>%    \n  left_join(customers)\n\nJoining with `by = join_by(customer_id)`\n\ncustomers_transactions\n\n# A tibble: 5 × 5\n  customer_id expense dealer             gender home_address\n        <dbl>   <dbl> <chr>              <chr>  <chr>       \n1           1      80 Motty's Shawarma   גבר    חיפה        \n2           1      12 Marina's coffee    גבר    חיפה        \n3           2     350 Dekek fuel         אשה    תל-אביב     \n4           4      35 Train              אשה    חיפה        \n5           4      12 Rokadin's Crossons אשה    חיפה        \n\n\nהטבלה המאוחדת מציגה עבור כל עסקה מה המגדר של הלקוח ואיפה גר (בשתי העמודות האחרונות). כעת נוכל להשתמש בפקודות שלמדנו בפרק זה לפעולות לפי קיבוצים:\n\ncustomers_transactions %>%    \n  group_by(home_address) %>%    \n  summarize(total_expense = sum(expense))\n\n# A tibble: 2 × 2\n  home_address total_expense\n  <chr>                <dbl>\n1 חיפה                   139\n2 תל-אביב                350\n\n\nמעבר לפקודה שבה השתמשנו left_join יש עוד פקודות חיבור. הפקודה right_join עושה את אותו הדבר רק במקום לחבר את הטבלה השניה לראשונה היא מחברת את הראשונה לשניה:\n\ncustomers %>%    \n  right_join(transactions)\n\nJoining with `by = join_by(customer_id)`\n\n\n# A tibble: 5 × 5\n  customer_id gender home_address expense dealer            \n        <dbl> <chr>  <chr>          <dbl> <chr>             \n1           1 גבר    חיפה              80 Motty's Shawarma  \n2           1 גבר    חיפה              12 Marina's coffee   \n3           2 אשה    תל-אביב          350 Dekek fuel        \n4           4 אשה    חיפה              35 Train             \n5           4 אשה    חיפה              12 Rokadin's Crossons\n\n\nהפקודה full_join תשמר ערכים שאין להם התאמה באחת הטבלאות. לדוגמה לקוח מספר 3 (והם יופיעו עם ערך חסר):\n\ncustomers %>%    \n  full_join(transactions)\n\nJoining with `by = join_by(customer_id)`\n\n\n# A tibble: 6 × 5\n  customer_id gender home_address expense dealer            \n        <dbl> <chr>  <chr>          <dbl> <chr>             \n1           1 גבר    חיפה              80 Motty's Shawarma  \n2           1 גבר    חיפה              12 Marina's coffee   \n3           2 אשה    תל-אביב          350 Dekek fuel        \n4           3 גבר    תל-אביב           NA <NA>              \n5           4 אשה    חיפה              35 Train             \n6           4 אשה    חיפה              12 Rokadin's Crossons\n\n\nשימו לב, הפקודות הללו מזהות לבד מהם המשתנים החופפים ומחברות בהתאם. ניתן גם להגדיר חפיפות אם שמות המשתנים אינם זהים בין שתי הטבלאות, על ידי שימוש בארגומנט by.\n\nלגבי שיבושי עברית/אנגלית בקוד ובפלט… 😮‍💨\nבהתייחס לטבלת ה-customers שבה הגדרנו ערכי שדות בעברית: שימו לב שהשדה gender הוגדר לפני השדה home_address אבל מכיוון שאנחנו משתמשים בעברית בהמשך שורות הקוד, זה נראה “כאילו” התוכן של מגדר מופיע אחרי התוכן של עיר (הפוך).\nכמו כן גם הטקסט עצמו בעברית בפלט משתבש.\nזה בגלל עניין היישור של הקוד משמאל לימין. זו בעיה נפוצה, כשמערבים עברית ואנגלית בקוד, ולוקח זמן להתרגל אליה. תתחילו להתאמן.\nעוד על עברית ב-R תוכלו למצוא בפרק 10.\n\n\n5.2.1 סינון מטבלה באמצעות join\nניתן להשתמש בפקודות anti_join ו-semi_join על מנת לסנן שורות. למעשה פקודות אלו אינן מחברות נתונים, אלא רק מסננות שורות.\nלדוגמה, הקוד הבא משתמש ב-anti_join בשביל לחלץ את הלקוחות שאינם מופיעים בטבלת הפעולות:\n\ncustomers %>%      \n  anti_join(transactions)\n\nJoining with `by = join_by(customer_id)`\n\n\n# A tibble: 1 × 3\n  customer_id gender home_address\n        <dbl> <chr>  <chr>       \n1           3 גבר    תל-אביב     \n\n\nלא התווספו שדות לטבלת הלקוחות. קיבלנו רק את לקוח 3 שלא הופיעו עבורו פעולות.\n\nהשתמשו בפקודה semi_join במקום anti_join. מה עושה הפקודה?"
  },
  {
    "objectID": "06-hypothesis-tests.html",
    "href": "06-hypothesis-tests.html",
    "title": "6  מבחני השערות",
    "section": "",
    "text": "בפרק זה נלמד על מבחני השערות פשוטים שניתן להפעיל ב-R. מטבע הדברים, מכיוון ש-R היא שפה סטטיסטית יש ערב רב של מבחני השערות פרמטרים וא-פרמטריים, שבוחנים השערות שונות במצבים שונים, אבל בספר זה נתמקד במבחני ההשערות שיימצאו בקורס מבוא לסטטיסטיקה (ואולי עוד קצת)."
  },
  {
    "objectID": "07-linear-regression.html",
    "href": "07-linear-regression.html",
    "title": "7  רגרסיה לינארית",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "08-advanced-models.html",
    "href": "08-advanced-models.html",
    "title": "8  מודלים",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "09-purrr.html",
    "href": "09-purrr.html",
    "title": "9  לולאות מיוחדות",
    "section": "",
    "text": "פרק על purrr ופרק על tidy evaluation.\nTBD."
  },
  {
    "objectID": "10-hebrew-in-R.html#שימוש-ב-ide",
    "href": "10-hebrew-in-R.html#שימוש-ב-ide",
    "title": "10  עברית ב-R",
    "section": "10.1 שימוש ב-IDE",
    "text": "10.1 שימוש ב-IDE\nה-IDE הנפוץ לשימוש ב-R הוא RStudio IDE (סביבת פיתוח - Integrated Development Environment). שילוב של עברית ב-IDE דורש קצת מיומנות והתרגלות, לדוגמה, כך נראית כתיבת שורות אלו ב-IDE:\n\n\n\nכתיבה בעברית ב-RStudio IDE\n\n\nכפי שניתן לראות, למרות שהשורות עצמן בספר מיושרות לימין (כמו שצריך בעברית), בכעת הכתיבה השורות לא מיושרות, וסדר המשפט מתהפך כאשר משלבים עברית ואנגלית. בחלק השלישי של הפרק נסביר איך “קורה הקסם” שהתוצר עצמו כן מיושר לימין. אבל הנה כמה טיפים שיעזרו לכם לשלב עברית בעבודה השוטפת עם RStudio:\n\nעבודה עם ה-Visual Editor: בכתיבת מסמכים (מסוג RMarkdown או quarto) לעבוד עם ה-Visual editor במקום ה-Source editor (בצד שמאל למעלה בחירה ב-Visual). איכשהו, העורך הויזואלי מצליח לסדר קצת יותר טוב את העברית, ובמקרה ונדרש לערוך מסמך, מצליח לשים את הסמן במקום הנכון. בצילום המסך הבא מוצג עורך קוד המקור (באדום מסומן הכפתור שמאפשר לעבור לעורך הויזואלי). אם תנסו לשים את הסמן במקום המתאים בעורך קוד המקור תראו שהוא מציב את הסמן במקום הלא נכון.\n\n\n\n\nמעבר לעורך ויזואלי\n\n\nלצערנו, העורך הויזואלי זמין רק במסמכים מסוג RMarkdown ו-quarto. בכתיבת סקריפט רגיל (קובץ קוד בלבד עם סיומת .R), חייבים להשתמש בעורך קוד המקור, מה שמוביל אותנו לנקודה השניה:\n\nשימוש בשבירת שורות כשנדרש לשלב עברית בקוד: כאשר כותבים קוד ונדרש לשלב עברית, עדיף לשבור שורה (בכתיבת קוד לרוב שבירת שורה לא משפיעה על הפונקציונליות של הקוד), ואת העברית לשים בשורה נפרדת. זה יקל על עריכת הקוד במידה וצריך. לדוגמה, הקוד הבא מכיל שבירת שורה, ולכן יקל על עריכות במידה ונדרשות:\n\n\nlibrary(tidyverse)\n\n\nmy_table %>% \n  filter(my_var == \n           \"המשתנה שלי\")\n\nבמקום הקוד:\n\nmy_table %>% \n  filter(my_var == \"המשתנה שלי\")\n\n\nשמירת קבצים באנגלית: תעשו לעצמכם ולאחרים טובה, ולכל הקבצים (והתיקיות) תתנו שמות באנגלית ולא בעברית.\nשמות משתנים באנגלית: אם יש לכם קובץ נתונים שבו שמות המשתנים (הכותרות) הם בעברית, מומלץ להעביר את כולם לאנגלית, לעבוד באנגלית, ואם צריך להעביר לעברית בסוף (לצורך דיווח ו/או תרשימים). יש דרכים שונות להחליף שמות, לדוגמה הגדרה בתוך הפקודה שקוראת את הקובץ. הפקודה read_csv ו-readxl::read_excel תומכות שתיהן בארגומנט שנקרא col_names ומאפשר להגדיר שמות (אבל השימוש בארגומנט מניח שסדר העמודות עקבי וידוע מראש). הדוגמה הבאה מחליפה שמות של עמודות באמצעות הפקודה rename, שמגדירה שם של עמודה באופן מדויק, גם אם הסדר שלהן אינו לפי סדר ההגדרה.\n\n\ninit_tbl <- tibble(`שם` = \n                     c(\"איתן\",\n                       \"נעמי\",\n                       \"אביב\"),\n                   `גיל` = \n                     c(11, 9, 5))\n\n\n\ninit_tbl\n\n# A tibble: 3 × 2\n  שם      גיל\n  <chr> <dbl>\n1 איתן     11\n2 נעמי      9\n3 אביב      5\n\n\n\n\ninit_tbl %>% \n  rename(age = `גיל`,\n         name = `שם`)\n\n# A tibble: 3 × 2\n  name    age\n  <chr> <dbl>\n1 איתן     11\n2 נעמי      9\n3 אביב      5\n\n\nשימו לב אגב שבפלט הטקסט בעברית מופיע הפוך, אבל העתיקו את הקוד ונסו. ניתן להשתמש בפקודה View על מנת לראות את התוצר הסופי בצורה מסודרת (פשוט הוסיפו %>% View() בסוף השורה האחרונה של הקוד)."
  },
  {
    "objectID": "10-hebrew-in-R.html#קידוד-קבצים",
    "href": "10-hebrew-in-R.html#קידוד-קבצים",
    "title": "10  עברית ב-R",
    "section": "10.2 קידוד קבצים",
    "text": "10.2 קידוד קבצים\nקבצי טקסט בפורמטים שונים (כגון txt או csv) יכולים להכיל אינדיקציה לקידוד, שמאפשרת לתוכנות שונות (ביניהן R ו-Excel) להבין איך לפתוח את הקובץ כך שניתן יהיה לקרוא אותו באופן תקין.\n\n10.2.1 קריאת קבצים\nנתייחס לפקודת read_csv (פקודות אחרות בחבילת readr עובדות באופן דומה). כברירת מחדל, הפקודה תצליח לקרוא טוב קבצים ששמורים עם קידוד של UTF-8, ולרוב הקבצים זה מספיק.\nבמידה והקריאה אינה עובדת, ניתן להיעזר בפקודה guess_encoding גם היא מחבילת readr.\nלדוגמה:\n\nguess_encoding(\"files/utf8_encoding_example_file.csv\")\n\n# A tibble: 2 × 2\n  encoding confidence\n  <chr>         <dbl>\n1 UTF-8          1   \n2 KOI8-R         0.98\n\n\nניתן לראות שהפקודה guess_encoding מצליחה לזהות שהקידוד הוא UTF-8, וקריאה “רגילה” של הקובץ (בלי ארגומנטים מיוחדים) תצליח:\n\n\nread_csv(\"files/utf8_encoding_example_file.csv\")\n\n# A tibble: 2 × 1\n  שלום \n  <chr>\n1 יום  \n2 טוב  \n\n\n\nלעומת זאת, הקובץ הבא מקודד בקידוד אחר (קידוד iso8859-8), הפקודה guess_encoding מזהה קידוד שגוי, והשימוש בו לא יניב תוצאות רצויות:\n\nguess_encoding(\"files/iso8859-8_encoding_example_file.csv\")\n\n# A tibble: 1 × 2\n  encoding     confidence\n  <chr>             <dbl>\n1 windows-1251        0.5\n\nread_csv(\"files/iso8859-8_encoding_example_file.csv\", \n         locale = locale(encoding = \"windows-1251\"))\n\n# A tibble: 2 × 1\n  щмен \n  <chr>\n1 йен  \n2 иеб  \n\n\nהקובץ הראשון מקודד ב-UTF-8 ולכן שימוש פשוט בפקודה read_csv קורא אותו באופן תקין. הקובץ השני שמור בפורמט ISO-8859-8 (והפקודה גם לא מצליחה “לנחש” אותו), ולכן יותר מאתגר לקרוא אותו בלי ידע מוקדם על הקידוד. הפעלת פקודת הקריאה על הקובץ השני מבלי הגדרה מתאימה של הקידוד, תציג טקסט שגוי או הודעת שגיאה של Error: Invalid multibyte sequence. הטקסט בעברית בדוגמאות להלן יופיע משמאל לימין (הפוך), אבל אם תנסו להריץ אותו ב-R תראו שהנתונים נקראים באופן תקין, בפקודה הראשונה והשלישית להלן:\n\n\nread_csv(\"files/iso8859-8_encoding_example_file.csv\", \n         locale = locale(encoding = \"ISO-8859-8\"))\n\n# A tibble: 2 × 1\n  שלום \n  <chr>\n1 יום  \n2 טוב  \n\n\n\nלידיעה, יש מספר פורמטים רלוונטיים לקריאת עברית, הראשונים שאני ממליץ לנסות הם UTF-8 (כלומר בלי ארגומנטים מיוחדים), אחריו Windows-1255, ואחריו ISO-8859-8, כמובן תוך שילוב הפקודה guess_encoding שיכולה להיות שימושית לעיתים.\n\n\n10.2.2 שמירת קבצים\nעל מנת לשמור קבצים עם קידוד, מומלץ להשתמש בפקודה write_excel_csv במקום הפקודה write_csv, במיוחד אם מתכננים לקרוא את הקובץ שנשמר באמצעות אקסל. הפקודה של write_excel_csv כוללת “הנחיות קידוד” כך שפתיחה באקסל תציג עברית באופן תקין (התוצר הוא עדיין קובץ טקסט). לעומת זאת, שמירה של write_csv עם נתונים בעברית, תציג ג’יבריש בעת פתיחת אקסל רגילה (אגב, אפשר לייבא נתונים באקסל ולהגדיר UTF-8 כקידוד, ואז ניתן לקרוא גם קבצים כאלו באופן תקין).\n\nפורמט אקסל (קובץ xlsx) הוא פורמט נוח מבחינת קידוד, משום שהוא שומר את הקידוד באופן מובנה. עם זאת, הוא פורמט פחות נוח לעבודה בהרבה מקרים. ניתן לקרוא קבצי אקסל באמצעות readxl::read_excel ואז לא צריך להתעסק עם קידוד. שמירה של קבצי אקסל תיעשה באמצעות אחת מהפקודות הבאות openxlsx::write.xlsx או writexl::write_xlsx.\nלא נכביר במילים על הבעיות שיש עם אקסל וקבצי דאטה, אבל לא חסרות כאלו (לדוגמה, ההתייחסות של אקסל לכל דבר שרק “נראה כמו תאריך” כתאריך, הגמישות לתת למשתמשים להפוך את הקובץ ל-untidy כמו לדוגמה על ידי מיזוג תאים, או קידוד משמעויות שונות באמצעות צביעה, מה שכמובן מקשה על עבודת מדען הנתונים)."
  },
  {
    "objectID": "10-hebrew-in-R.html#יישור-לימין",
    "href": "10-hebrew-in-R.html#יישור-לימין",
    "title": "10  עברית ב-R",
    "section": "10.3 יישור לימין",
    "text": "10.3 יישור לימין\nתוצרים ב-R המבוססים על html, קרי, מסמכים שהם תוצר של RMarkdown, quarto, ואפליקציות shiny, יציגו עברית בכיוון הפוך (משמאל לימין), אלא אם יוגדר להם עיצוב מתאים.\nעיצוב ב-html נשלט על ידי קוד CSS (Cascade Style Sheet). לדוגמה, לספר זה יש עיצוב המוגדר בקובץ style.css ובו מופיע (בין היתר) הקוד הבא:\n\nbody {\n  direction: rtl;\n}\n\nהקוד שולט בכל התגיות שנמצאות בתוך גוף המסמך (תגיות html שמופיעות בין <body> לבין התגית הסוגרת </body>. התכונה אותה אנחנו רוצים לעדכן נקראת כיוון (direction), והוא יכול לקבל שני ערכים (כברירת מחדל שמאל לימין ltr, ובאמצעות הקוד אנחנו משנים אותו ל-rtl.\nבשביל להטמיע זאת במסמך quarto או RMarkdown רק צריך להוסיף את הקוד הבא במסמך:\n```{css}\nbody {\n   direction: rtl;\n}\n```\nניתן לקרוא מידע נוסף לגבי שילוב CSS במקורות הבאים:\n\nלגבי שימוש ב-CSS במסמכי quarto\n\nquarto.org\n\nשילוב CSS במסמכי RMarkdown\n\n(Xie, Allaire, and Grolemund 2018)\n\nשילוב CSS באפליקציות Shiny\n\n(Wickham 2021)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "על הכותב",
    "section": "",
    "text": "כותב הספר הוא ד\"ר עדי שריד, שותף ומנהל מחלקת חקר הביצועים ומדעי הנתונים במכון שריד. לעדי יש דוקטורט מטעם המחלקה להנדסת תעשייה באוניברסיטת תל-אביב, תואר שני בחקר ביצועים מאוניברסיטת תל-אביב, ותואר ראשון במתמטיקה עם סטטיסטיקה וחקר ביצועים מהטכניון.\nעדי לימד ומלמד R במגוון מסגרות: באוניברסיטה במסגרת קורסים כגון מבוא לסטטיסטיקה, ניתוח נתונים, וקורסים פרטיים במכללות ובחברות הייטק. את הניסיון בהכשרה בלימוד R מביא איתו עדי לספר הנוכחי שנועד לתת מענה ללומדים את R ששפת האם שלהם היא עברית.\nלפרטים נוספים adisarid.github.io."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "מקורות",
    "section": "",
    "text": "Murray, Lori L., and John G. Wilson. 2021. “Generating Data Sets\nfor Teaching the Importance of Regression Analysis.” Decision\nSciences Journal of Innovative Education 19 (2): 157–66. https://doi.org/10.1111/dsji.12233.\n\n\nSimpson, E. H. 1951. “The Interpretation of Interaction in\nContingency Tables.” Journal of the Royal Statistical\nSociety: Series B (Methodological) 13 (2): 238–41. https://doi.org/10.1111/j.2517-6161.1951.tb00088.x.\n\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.”\nJournal of Computational and Graphical Statistics 19 (1): 3–28.\nhttps://doi.org/10.1198/jcgs.2009.07098.\n\n\n———. 2021. Mastering Shiny. \" O’Reilly Media, Inc.\".\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. \"O’Reilly\nMedia, Inc.\".\n\n\nXie, Yihui, Joseph J Allaire, and Garrett Grolemund. 2018. R\nMarkdown: The Definitive Guide. CRC Press."
  },
  {
    "objectID": "10-hebrew-in-R.html#סיכום",
    "href": "10-hebrew-in-R.html#סיכום",
    "title": "10  עברית ב-R",
    "section": "10.4 סיכום",
    "text": "10.4 סיכום\nבפרק זה למדנו טיפים וטריקים שיעזרו לנו בפרויקטים בהם עלינו לשלב עברית ואנגלית. בפרט:\n\nשימוש בסביבת הפיתוח RStudio תוך שילוב עברית.\nקידודים של קבצים בעברית (בקריאה ובכתיבה של קבצים).\nיישור לימין בתוצרי ניתוח שכוללים html, באמצעות שימוש ב-CSS.\n\n\n\n\n\nWickham, Hadley. 2021. Mastering Shiny. \" O’Reilly Media, Inc.\".\n\n\nXie, Yihui, Joseph J Allaire, and Garrett Grolemund. 2018. R Markdown: The Definitive Guide. CRC Press."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#איך-בוחרים-את-סוג-התרשים",
    "href": "04-visualizations-ggplot2.html#איך-בוחרים-את-סוג-התרשים",
    "title": "4  ויז’ואליזציות",
    "section": "4.6 איך בוחרים את סוג התרשים",
    "text": "4.6 איך בוחרים את סוג התרשים\nעל מנת לייצר תרשים טוב, עליכם לענות על השאלות הבאות:\n\nכמה משתנים אנחנו רוצים לתאר בתרשים (האם אנחנו רוצים לתאר התפלגות של משתנה אחד, קשר בין שני משתנים, או אולי קשר בין שלושה משתנים)?\nמהם סוגי המשתנים שאנחנו מתארים (בדידים או רציפים)?\nאילו גיאומטריות יכולות לשמש אותנו לתיאור זה, ואיזה משתנה ימופה לאן (לאיזו אסטטיקה)?\n\n\n4.6.1 “גיליון ה”שליפים\nמכיוון שחבילת ggplot2 היא חבילה עשירה מאוד בפיצ’רים, אנחנו לא מתיימרים להציג את כלל מנעד היכולות שלה. בכל מקרה, ובמיוחד בשלבי הלמידה וההתנסויות הראשונות עם יצירת תרשימים, מומלץ להיעזר גם ב-Cheatsheet שהפיקו בחברת Posit (לשעבר RStudio), שמאפשר לראות מה סוג התרשים הנדרש לכל סיטואציה (לדוגמה, איזה תרשים, ומה הקוד של תרשים, שיציג “קשר בין שני משתנים אחד רציף והשני בדיד”). קישור ל-Cheatsheet."
  },
  {
    "objectID": "04-visualizations-ggplot2.html#בחירת-התרשים",
    "href": "04-visualizations-ggplot2.html#בחירת-התרשים",
    "title": "4  ויז’ואליזציות",
    "section": "4.6 בחירת התרשים",
    "text": "4.6 בחירת התרשים\nעל מנת לייצר תרשים טוב, עליכם לענות על השאלות הבאות:\n\nכמה משתנים אנחנו רוצים לתאר בתרשים (האם אנחנו רוצים לתאר התפלגות של משתנה אחד, קשר בין שני משתנים, או אולי קשר בין שלושה משתנים)?\nמהם סוגי המשתנים שאנחנו מתארים (בדידים או רציפים)?\nאילו גיאומטריות יכולות לשמש אותנו לתיאור זה, ואיזה משתנה ימופה לאן (לאיזו אסטטיקה)?\n\nהחלקים 1-2 נובעים מהבנה טובה של הדאטה, והצורך המחקרי/העסקי שלכם. בשביל חלק 3 תוכלו להיעזר ב-Cheatsheet שהכינו בחברת Posit (לשעבר RStudio). הוא מאפשר להבין לכל סיטואציה איזה סוג תרשים ידרש: קישור ל-Cheatsheet.\nעברנו את התהליך הזה בדוגמאות שכבר ראינו בפרק זה, מבלי לציין זאת:\n\nב-Boxplot תיארנו קשר בין שני משתנים: המסה של הפינגויין (משתנה רציף) כתלות בזן של הפינגויין (משתנה בדיד), ולשם כך השתמשנו ב-geom_boxplot.\nגם בצפיפות וגם בהיסטוגרמה תיארנו קשר זה של משתנה רציף למשתנה בדיד (רק צורת הצגה שונה- geom_density או geom_histogram בהתאמה).\n\nכל אחת מהדוגמאות הנ”ל יכלו לשמש אותנו גם על מנת לתאר התפלגות של משתנה רציף יחיד, וגם על מנת לתאר קשר בין משתנה בדיד לבין משתנה רציף.\n\nבתרשימי הבארים השתמשנו על מנת לתאר התפלגות של משתנה בדיד יחיד (כגון זני הפינגויינים במדגם), או קשר בין התפלגויות של שני משתנים בדידים (מין הפינגויין למול זן הפינגויין).\n\n\n4.6.1 דוגמה למתקדמים\nנדגים דוגמה נוספת, הפעם כזו שמתארת קשר בין ארבעה משתנים. הקשר בין אורך המקור, עומק המקור, ומשקל של הפינגויין. מכיוון שלמדנו שישנו הבדל בין זנים שונים, אז גם נבצע אבחנה בין הזנים.\n\nיש לנו שלושה משתנים רציפים (אורך, עומק, ומשקל)\nיש לנו משתנה בדיד (זן)\nמהסתכלות ב-Cheatsheet (פינה ימנית תחתונה בעמוד הראשון) נראה שישנן מספר גיאומטריות מתאימות geom_contour, geom_countour_filled, geom_raster, geom_tile.\n\nהמשתנה התלוי שלנו הוא המשקל, ואנחנו רוצים לחקור איך הוא מושפע ממימדי המקור. לכן נמפה את אורך ועומק המקור לצירים x ו-y, ואת המשקל לצבע. באמצעות facet_wrap נייצר שלושה תתי-תרשימים (אחר לכל זן פינגויין).\n\npenguins %>% \n  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, fill = body_mass_g)) + \n  geom_raster() +\n  facet_wrap(~species)\n\n\n\n\nכפי שניתן לראות יש לנו בעיית רזולוציה, מכיוון שיש יחסית מעט תצפיות, כל פינגויין מסומן כמלבן עם המשקל שלו מסומן כצבע. התרשים לא מאוד אינפורמטיבי, ולא כל כך תורם להבנה. יש לגיאומטריה של geom_raster ארגומנט שנקרא interpolate, שאמור לעשות אינטרפולציה בין נקודות, אבל גם אם נפעיל אותו נקבל גרף מטושטש ולא ברור (הנקודות רחוקות מדי אחת מהשניה).\nבמקרה זה, אפשר לבנות לנו “אינטרפולציה משלנו”. נתאים מודל (נשתמש במודל רגרסיה לינארית פשוטה), של אורך מקור, עומק מקור, וזן הפינגויין.\n\npenguins_model <- lm(body_mass_g ~ bill_length_mm + bill_depth_mm + species, \n                     data = penguins)\n\npenguin_ranges <- penguins %>% \n  group_by(species) %>% \n  summarize(across(c(bill_length_mm, bill_depth_mm), \n                   list(min = ~min(., na.rm = T),\n                        max = ~max(., na.rm = T))))\n\nהטבלה הבאה מציגה את טווחי אורך המקור, עומק המקור, ומשקל, עבור כל אחד מזני הפינגויינים.\n\n\ngt::gt(penguin_ranges)\n\n\n\n\n\n  \n    \n    \n      species\n      bill_length_mm_min\n      bill_length_mm_max\n      bill_depth_mm_min\n      bill_depth_mm_max\n    \n  \n  \n    Adelie\n32.1\n46.0\n15.5\n21.5\n    Chinstrap\n40.9\n58.0\n16.4\n20.8\n    Gentoo\n40.9\n59.6\n13.1\n17.3\n  \n  \n  \n\n\n\n\n\nנשתמש בנתוני הטבלה כדי לבנות טבלה חדשה שבה נמצאים כל הערכים האפשריים, וחיזוי שלהם על בסיס מודל הרגרסיה הלוגיסטית שבנינו.\n\nstep <- 0.5\npenguin_grid <- \n  expand_grid(length = seq(32.1, 46, step),\n              depth = seq(15.5, 21.5, step),\n              species = \"Adelie\") %>% \n  bind_rows(\n    expand_grid(length = seq(40.9, 58, step),\n                depth = seq(16.4, 20.8, step),\n                species = \"Chinstrap\"),\n    expand_grid(length = seq(40.9, 59.6, step),\n                depth = seq(13.1, 17.3, step),\n                species = \"Gentoo\")\n  ) %>% \n  rename(bill_length_mm = length,\n         bill_depth_mm = depth)\n\npenguin_grid$body_mass_g <- predict(penguins_model, newdata = penguin_grid)\n\npenguin_grid %>% \n  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, fill = body_mass_g)) + \n  geom_raster(interpolate = TRUE) + \n  scale_fill_viridis_c() + \n  facet_wrap(~species)\n\nWarning: Raster pixels are placed at uneven horizontal intervals and will be shifted\nℹ Consider using `geom_tile()` instead.\nRaster pixels are placed at uneven horizontal intervals and will be shifted\nℹ Consider using `geom_tile()` instead.\n\n\n\n\n\nכעת ניתן להצמיד פרשנות למודל על ידי עיון בגרף. נראה שסוג הפינגויין משפיע ביותר על המשקל: ל-Gentoo המשקל הגבוה ביותר, המתקבל כאשר האורך והעומק של המקור עולים (בפינה הימנית העליונה של התרשים הימני). פרטים של פינגויינים מזן ה-Chinstrap יכולים להיות בעלי מימדי מקור דומים, אך עדיין לא מגיעים לאותו המשקל כפי שנצפה ב-Gentoo.\nבכל המקרים עלייה במימדי המקור (עומק ואורך) מצביעה על עלייה במשקל (בגלל זה לפינה העליונה הימנית בכל אחד מתתי התרשימים נצבעת בצבע יותר בהיר)."
  }
]