[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "המדריך העברי למשתמש ב-R",
    "section": "",
    "text": "הקדמה\nR שפה נפלאה, היא התחילה כשפה סטטיסטית, וגם כיום זה השימוש המרכזי שלה. בפועל אפשר לעשות בה כמעט הכל. החל מניתוח נתונים ועד בניית אפליקציות ואוטומציות מורכבות. אצלנו בעסק (מכון שריד) אנחנו משתמשים ב-R לניתוח נתונים, הצגת תוצאות עם דשבורדים בזמן אמת, הפקת דוחות Power Point בלחיצת כפתור, אוטומציות של תהליכים שונים בעסק, ועוד הרבה - היא הפכה לכלי עבודה שימושי והחליפה הרבה מאוד מהדברים שהיינו עושים בעבר עם כלים אחרים.\nללומדים את השפה יש מקורות רבים ומגוונים - ספרים, סרטוני YouTube, בלוגים, ועוד. העניין הוא שרוב המקורות שישנם כתובים באנגלית. זה מה שהביא אותי לכתוב את הספר הזה, ולעזור לקהל הקוראים שיותר נוח לו ללמוד R בעברית.\nהתוכן שבספר שלפניכם מבוסס על מספר קורסים שלימדתי בשנים האחרונות, כולל הכשרות מקצועיות בחברות סטארטאפ, וקורסי לימוד לתואר ראשון שנתתי באוניברסיטה.\nלמי מיועד הספר?\nאם אתם עובדים היום עם נתונים ומשתמשים ב-Excel או בכל כלי אחר, ומעוניינים לעבור לכלי חזק משמעותית שיגדיל את הגמישות, סל היכולות שלכם, ומהירות העבודה שלכם.\nאם אתם סטודנטים שלומדים מקצוע כמותי, כגון מבוא לסטטיסטיקה או קורס מתקדם בסטטיסטיקה.\nאם אתם עוברים מכלי סטטיסטי אחר (כגון SAS, SPSS, או אחרים) ומעוניינים למנף את הכלים והיכולות שיש ל-R להציע.\nהספר מתאים גם לכאלו שיודעים R ברמה בינונית ורוצים לחזק את הבסיס, או כאלו שרוצים להשתפשף בידיעות שלהם על החבילות שנלמדות בספר (כמו tidyverse).\nהספר אינו נועד להחליף ספרי תיאוריה סטטיסטית, הוא אינו מכסה תיאוריה סטטיסטית לעומק, אלא בעיקר מדגים כיצד ניתן לממש כלים סטטיסטיים שונים באמצעות R.\nלמה R ולא Python?\nכמו שמרמזת הכותרת, יש היום שתי שפות שמובילות בתחום ה-Data Science, הן R ו-Python. בנקודה הזו אין שחור ולבן, טוב יותר או פחות. אני עובד בשתי השפות, ולי באופן אישי יש העדפה חזקה לשימוש ב-R, פשוט כי היא מרגישה לי יותר טבעית, זה כנראה נגזרת של העובדה שזה מה שלמדתי בהתחלה, וזה מה שהתמקצעתי בו. בפועל בשתי השפות יש כלים רבים ושימושיים, ובכל הקשור במשימות של ניתוח נתונים, שתי השפות נותנות מענה טוב מאוד.\nמבין שתיהן Python יותר נפוצה משום שהיא נפוצה כשפת תכנות (באופן כללי), בעוד ש-R מוכוונת יותר לתחום הסטטיסטיקה. בפועל, שתיהן עושות את העבודה, וכדאי להתאים את השפה לצורך. לדוגמה R הרבה פעמים נוחה יותר לביצוע ניתוח נתונים, אבל ל-Python עשוי להיות יתרון במעבר ל-Production (הטמעה במערכות).\nהדיון של בחירה בשפה מסוימת צריך להיגזר מהמשימה הנדרשת, ההקשר העסקי, ועוד הרבה שיקולים אחרים. ככלל למי שמשתלב בתוך ארגון כדאי לדעת שיש ב-R חבילות שמאפשרות להפעיל גם קוד Python מתוך R (חבילת reticulate), שתאפשר להשתלב עם R גם בתוך ארגון שעובד מסורתית עם Python.\nמה בספר?\nבפרק 1 נראה מבוא קצר לתהליך ניתוח הנתונים ונלמד מהם הכלים הנדרשים על מנת להתקין את R. לאחר מכן נצלול, בפרק 2 לבסיס של R כשפת תכנות. הפרק מתייחס לחלקים ב-R שמגיעים בגרסה ה”ערומה ביותר” מה שמכונה גם Base R.\nבפרק 3 נלמד את הבסיס של חבילות tidyverse ואיך הן מרחיבות את Base-R והופכות את הקוד שלנו ליותר קריא, ואת הכתיבה ליותר נוחה. אנחנו נתמקד בעיקר בשלבי הכנת הנתונים לקראת ניתוח, ואז בפרק 4 נלמד על ויז’ואליזציות באמצעות חבילת ggplot2. בפרק 5 נטפל במניפולציות קצת יותר מתקדמות כמו חיבור טבלאות ושינוי מבנה טבלאות.\nלעולם הסטטיסטי ניכנס בפרק 6 עם מבחני השערה, ובפרק 7 עם רגרסיה לינארית.\nלאחר מכן נצלול קצת יותר לעומק עם מודלים מתקדמים מעולם ה-Data Science תוך שימוש בחבילת tidymodels בפרק 8.\nבפרק 9 נחזור מהעולם הסטטיסטי לתכנות, ונתעמק קצת יותר בלולאות מתוכמות. בפרק 10 ניתן טיפים לכל מי שמשתמש ב-R וצריך לשלב את העבודה שלו עם עברית.\nהנוסח שלפניכם הוא טיוטה, ולכן חלקים מסוימים עוד חסרים ממנו, וחלקים מסוימים עוד ישתנו. מי שמוצא טעות בספר, מוזמן לפנות אלי בטוויטר @SaridResearch, או להציע עדכונים באמצעות Pull request או לפתוח Issue ב-github.\nספר זה זמין באופן חופשי באינטרנט, ללא עלות, תחת רישיון Creative Commons BY-NC-ND 4.0, מה שאומר שאפשר לשתף את הקישור לספר או לשתף ציטוטים מהספר תוך ציון המקור עם קישור לעמוד זה. לא ניתן להשתמש בתוכן למטרות מסחריות.\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד",
    "crumbs": [
      "הקדמה"
    ]
  },
  {
    "objectID": "01-introduction.html#תהליך-ניתוח-נתונים",
    "href": "01-introduction.html#תהליך-ניתוח-נתונים",
    "title": "1  מבוא",
    "section": "1.1 תהליך ניתוח נתונים",
    "text": "1.1 תהליך ניתוח נתונים\nבספר הזה אני מאמץ את נקודת ההשקפה של (Wickham and Grolemund 2016) שמציגים את אבני הבניין של עבודת מדען הנתונים כפי שמומחש באיור הבא:\n\n\n\nהמחשה של תהליך ניתוח הנתונים\n\n\nכל תהליך ניתוח נתונים מורכב מיבוא סט הנתונים, סידור שלהם בצורה שנוח לעבוד איתה, לאחר מכן מחקר על הנתונים, שהוא תהליך איטרטיבי (חוזר על עצמו) שמורכב מהתמרות שונות על הנתונים (טרנספורמציות), המחשות בתרשימים (ויז’ואליזציות), ומידול של הנתונים. לבסוף, התהליך עובר למסמך, מצגת או אמצעי אחר, ומוצג למקבלי החלטות.\nבספר זה נדון בשלבים של יבוא הנתונים, סידור, וכלל שלבי המחקר (טרנספורמציות, ויז’ואליזציות, ומידול). אך ראשית, לפני שנתחיל בצעדים הראשונים (למידת בסיס השפה), נראה כיצד להתקין את R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>מבוא</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#איך-מתקינים-את-r",
    "href": "01-introduction.html#איך-מתקינים-את-r",
    "title": "1  מבוא",
    "section": "1.2 איך מתקינים את R?",
    "text": "1.2 איך מתקינים את R?\nהתקנת התוכנה פשוטה מאוד. R היא שפה בקוד פתוח (Open Source) מה שאומר שכל אחד יכול להתקין אותה ללא עלות. כמו כן, ישנה סביבת פיתוח, גם היא חינמית ובקוד פתוח, הנקראת RStudio IDE.\nעל מנת להתקין את R עליכם להיכנס לכתובת https://cran.r-project.org/ ולבחור בגרסה המתאימה למערכת ההפעלה שלכם. לאחר מכן, כדי להתקין את RStudio היכנסו לכתובת https://rstudio.com/products/rstudio/download/. הגרסה החינמית של RStudio נקראת RStudio Desktop והיא זמינה לכל צורך (כולל לשימוש במסגרת מסחרית).\nהסיבה שאנחנו מתקינים גם את R וגם את RStudio היא שבהתקנת R בלבד, מקבלים ממשק משתמש בסיסי ביותר, בעוד שלאחר התקנת RStudio ניתן יהיה לעבוד עם ממשק משתמש נוח שיש לו הרבה אפשרויות שיקלו עליכם את הלמידה ואת העבודה השוטפת ב-R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>מבוא</span>"
    ]
  },
  {
    "objectID": "01-introduction.html#איך-משתמשים-ב-rstudio",
    "href": "01-introduction.html#איך-משתמשים-ב-rstudio",
    "title": "1  מבוא",
    "section": "1.3 איך משתמשים ב-RStudio?",
    "text": "1.3 איך משתמשים ב-RStudio?\nלאחר ההתקנה, כשתפעילו את RStudio, תראו חלון המפוצל לשלושה (או אולי ארבעה) חלקים. החלק הגדול בצד שמאל הוא ה-Console, הוא סביבת ה-R המריצה את הקוד שלכם. אתם יכולים לנסות לרשום בו קוד ולראות מה קורה, לדוגמה תנסו לרשום 2+2 וללחוץ Enter או לרשום pi וללחוץ Enter.\n\n2+2\n\n[1] 4\n\npi\n\n[1] 3.141593\n\n\nבצד ימין למעלה ישנה חלונית המחולקת לטאבים. בין הטאבים שמופיעים בה תוכלו לראות את:\n\nEnvironment - משתנים או פונקציות שנטענו לסביבה\nHistory - היסטורית הפקודות שהרצתם\nConnections - חיבורים למקורות נתונים\nTutorial - הצגה של מדריכים שונים שמלמדים איך להשתמש בחבילות של R\n\nבצד ימין למטה תופיעה חלונית נוספת המחולקת גם היא לטאבים:\n\nFiles - תוכן התיקייה הנוכחית\nPlots - תרשימים שנכין יופיעו בטאב זה\nPackages - חבילות שזמינות לנו או שנטענו לסביבה (יסומנו ב-V)\nHelp - חלונית עזרה על פקודות\nViewer - צפיה בתכנים שונים שנכין (בעיקר תכנים אינטראקטיביים כמו טבלאות html תרשימים אינטראקטיביים, ואפליקציות).\n\nבתוך משתמשים מתחילים נשתמש בחלק קטן מאלו, אך ככל שיעבור זמן תראו שאתם משתמשים ביותר ויותר אפשרויות, וגם אפשרויות נוספות שכרגע אינן מופיעות לכם.\nעוד כמה פינות חשובות שנמצאות ב-RStudio:\n\nאם תלחצו על Help-&gt;Cheat sheets תוכלו לראות רשימה של “שליפים”. דפים שימושיים שמרכזים פקודות שונות של R וחבילות של R. לדוגמה, אחד מהשליפים ששם נקרא RStudio IDE Cheat Sheet, והוא מכיל הרבה הסברים נוספים על הממשק משתמש של RStudio.\nבתפריט File -&gt; New File ישנה אפשרות לפתוח קובץ חדש. מומלץ שתנסו לפתוח קובץ חדש מסוג R Script, שישמש אותנו לפרק הבא.\n\nשימו לב: לאחר שפתחתם Script חדש, וכתבתם בו קוד, על מנת להריץ את הקוד צריך לסמן אותו וללחוץ Ctrl+Enter. זה יגרום ל-R להריץ את כל הקוד המסומן.\nכעת אנחנו מוכנים לפרק הבא, שבו נלמד את בסיס השפה, מה שמכונה גם Base R.\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד\n\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \"O’Reilly Media, Inc.\".",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>מבוא</span>"
    ]
  },
  {
    "objectID": "02-base-R.html#השמת-משתנים-פעולות-אריתמטיות-ופונקציות",
    "href": "02-base-R.html#השמת-משתנים-פעולות-אריתמטיות-ופונקציות",
    "title": "2  תחביר בסיסי",
    "section": "2.1 השמת משתנים, פעולות אריתמטיות ופונקציות",
    "text": "2.1 השמת משתנים, פעולות אריתמטיות ופונקציות\nניתן להריץ ב-R פעולות אריתמטיות (חיבור, חיסור, כפל, חילוק), פונקציות, ולהגדיר משתנים שונים. לדוגמה, הקוד הבא מגדיר משתנה a משתנה b ומכניס את הסכום שלהם למשתנה חדש שיקרא a_plus_b.\n\na &lt;- 5\nb &lt;- 3\na_plus_b &lt;- a + b\na_plus_b\n\n[1] 8\n\n\nשימו לב שההשמה לתוך משתנה מתבצעת עם האופרטור -&gt;, ניתן גם להשתמש ב= לצורך השמה, כתיב זה פחות נפוץ. לדוגמה:\n\na_plus_b = a + b  # this form of assignment `=` is less common, don't use it (use `&lt;-`)\n\n\n2.1.1 קביעת שמות משתנים\nקודם השתמשנו בשמות a, b , ו-a_plus_b כדי לקבוע משתנים. ככלל, מומלץ להשתמש בשמות קצרים בעלי משמעות. שמות משתנים חייבים להתחיל באות באנגלית, ויכולים להכיל אותיות, מספרים, קו תחתון, ונקודה. לדוגמה gender, age, raw_data, וכו’.\n\n\n2.1.2 סוגי משתנים\nבבסיס השפה יש כמה סוגי משתנים, שקובעים מה סוג הערכים שהמשתנה יכול לקבל:\n\nמספר שלם (Integer)\nמספר רציף (Double)\nמחרוזת (Character)\nמשתנה קטגוריות (Factor)\nתאריך (Date)\nמשתנה לוגי (Logical)\n\nכל משתנה חדש אנחנו מגדירים ב-R הוא למעשה וקטור. אגב, גם כשאנחנו מגדירים משתנה כערך בודד, בעצם הוא וקטור עם איבר אחד. אנחנו יכולים להשתמש בפקודה c (קיצור של המילה combine) כדי לשלב וקטורים שונים.\nנראה דוגמאות להגדרות של וקטורים מסוגים שונים.\n\nsome_integer &lt;- c(1L, 2L, 3L)  # The L sign stands for \"Long integer\"\nsome_integer\n\n[1] 1 2 3\n\nsome_double &lt;- c(1, 2, pi, exp(1))\nsome_double\n\n[1] 1.000000 2.000000 3.141593 2.718282\n\nsome_character &lt;- c(\"This\", \"is\", \"a\", \"character\", \"vector\")\nsome_character\n\n[1] \"This\"      \"is\"        \"a\"         \"character\" \"vector\"   \n\nsome_factor &lt;- factor(c(\"Apples\", \"Oranges\", \"Paers\", \"Mangos\", \"Apples\", \"Oranges\"))\nsome_factor\n\n[1] Apples  Oranges Paers   Mangos  Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\nsome_date &lt;- c(Sys.Date(), as.Date(\"1993-08-01\"))\nsome_date\n\n[1] \"2024-04-29\" \"1993-08-01\"\n\nsome_logical &lt;- c(TRUE, FALSE, FALSE, TRUE) # can also use c(T, F, F, T) is the same\nsome_logical\n\n[1]  TRUE FALSE FALSE  TRUE\n\n\nלמשתני קטגוריות יש שימוש חשוב בסטטיסטיקה שעוד נראה אותו בפרקים הבאים, ולכן הוא מובחן ממשתנה מחרוזת ומקבל מקום של כבוד. כפי שניתן לראות, כאשר מדפיסים אותו, R מדווח גם על הרמות השונות שכלולות בו.\nשימוש בפקודה typeof(some_variable) יציג את סוג המשתנה.\n\ntypeof(some_integer)\n\n[1] \"integer\"\n\ntypeof(some_double)\n\n[1] \"double\"\n\ntypeof(some_character)\n\n[1] \"character\"\n\ntypeof(some_date)\n\n[1] \"double\"\n\ntypeof(some_factor)\n\n[1] \"integer\"\n\ntypeof(some_logical)\n\n[1] \"logical\"\n\n\nניתן לשים לב ש-R מחשיב את המשתנה הקטגוריאלי כמספר שלם (integer) ואת התאריך כמספר רציף (double).\n\n\n\n\n\n\nתרגיל: חיבור של וקטורים מסוגים שונים\n\n\n\nבאמצעות הפקודה c והפקודה typeof בדקו מה קורה כאשר מחברים משתנים מסוגים שונים אחד לשני. האם התוצאה הגיונית? מה ההיגיון? האם יש מקרים בהם התוצאה של חיבור משתנים עשויה להטעות?\nבדקו את c(some_factor, some_character) ודוגמאות נוספות.\n\n\n\n\n2.1.3 קריאה לתתי וקטורים\nב-R ניתן לקרוא לחלק מסוים מתוך וקטור. לדוגמה, אם אנחנו רוצים רק את שני האיברים הראשונים מתוך הוקטור some_factor או את האיבר הראשון והרביעי מתוך some_character נשתמש בכתיב:\n\nsome_factor[1:2]\n\n[1] Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\nsome_character[c(1,4)]\n\n[1] \"This\"      \"character\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>תחביר בסיסי</span>"
    ]
  },
  {
    "objectID": "02-base-R.html#רשימה-list",
    "href": "02-base-R.html#רשימה-list",
    "title": "2  תחביר בסיסי",
    "section": "2.2 רשימה (list)",
    "text": "2.2 רשימה (list)\nכעת נדון במבנה נתונים שנקרא רשימה (list). רשימה היא אובייקט מרכזי ב-R שמאפשר לנו לאחד משתנים ווקטורים מסוגים שונים, לתוך dataset שיאפשר לנו בהמשך לנתח נתונים. ישנן מספר דרכים להגדיר רשימה, אחת מהן באמצעות הפקודה list. לדוגמה, הרשימה הבאה תכיל את כל הוקטורים שהגדרנו עד כה, מבלי שהם יאבדו מהמשמעות שלהם (כפי שקורה כשמנסים לעשות חיבור רגיל).\n\nmy_list &lt;- list(my_int = some_integer,\n                my_double = some_double,\n                my_character = some_character,\n                my_factor = some_factor,\n                my_date = some_date)\nmy_list\n\n$my_int\n[1] 1 2 3\n\n$my_double\n[1] 1.000000 2.000000 3.141593 2.718282\n\n$my_character\n[1] \"This\"      \"is\"        \"a\"         \"character\" \"vector\"   \n\n$my_factor\n[1] Apples  Oranges Paers   Mangos  Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\n$my_date\n[1] \"2024-04-29\" \"1993-08-01\"\n\ntypeof(my_list)\n\n[1] \"list\"\n\n\nכדי לקרוא לוקטור מסוים מתוך רשימה ניתן להשתמש ב-$ באופן הבא:\n\nmy_list$my_int\n\n[1] 1 2 3\n\n\nהחלק הסופי בהצגה שלנו הוא רשימה מסוג מאוד מסוים, data.frame. מבנה נתונים זה הוא רשימה שבה כל הוקטורים באותו האורך. הוקטורים יכולים להיות מסוגים שונים כפי שציינו, ומה שחשוב ב-data.frame הוא שהוא הולך להיות אבן הפינה שלנו בכל ניתוח נתונים סטטיסטי. בינתיים נסתפק בהדגמה קצרה של הגדרת data.frame אך נרחיב עליו בפרקים הבאים.\n\nmy_data &lt;- data.frame(name = c(\"Danny\", \"Moshe\", \"Iris\", \"Ronit\"),\n                      favorite_fruit = factor(c(\"Mango\", \"Apple\", \"Apple\", \"Paer\")),\n                      age = c(25L, 32L, 22L, 30L),\n                      height = c(1.8, 1.75, 1.6, 1.68),\n                      married = c(F, T, F, T))\nmy_data\n\n   name favorite_fruit age height married\n1 Danny          Mango  25   1.80   FALSE\n2 Moshe          Apple  32   1.75    TRUE\n3  Iris          Apple  22   1.60   FALSE\n4 Ronit           Paer  30   1.68    TRUE\n\ntypeof(my_data)\n\n[1] \"list\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>תחביר בסיסי</span>"
    ]
  },
  {
    "objectID": "02-base-R.html#שימוש-בפונקציות",
    "href": "02-base-R.html#שימוש-בפונקציות",
    "title": "2  תחביר בסיסי",
    "section": "2.3 שימוש בפונקציות",
    "text": "2.3 שימוש בפונקציות\nניתן גם להפעיל פונקציות שונות, לדוגמה לוגריתם, פונקציות טריגונומטריות. למעשה בסעיף הקודם כבר ראינו מספר פונקציות כגון c ו-typeof. כעת נראה עוד מספר דוגמאות.\nנסו להריץ את הקוד הבא, ולאחר מכן לענות על השאלות שמתחת למקטע הקוד. יש לשים לב שעל מנת להריץ את הפקודות בסוף המקטע (שקשורות ב-my_data נדרש קודם להגדיר את my_data כפי שהוגדר במקטע הקוד הקודם.\n\nlog(100)  # natural logarithm\nlog10(100)  # base 10 logarithm \nsin(pi)  # sin(pi) is 0 but may give you a surprising answer, why?\nsqrt(4)  # square root of 4\nmean(my_data$age)\nsd(my_data$age)\nsummary(my_data)\n\n\n\n\n\n\n\nחשיבה על דיוק\n\n\n\nשאלה למחשבה: בחלק מהמחשבים התשובה שמתקבלת ל-sin(pi) שונה מ-0.\nלדוגמה\n&gt; sin(pi)\n[1] 1.224606e-16\nלמה לדעתך?\n\n\n\n\n\n\n\n\nהפקודה summary\n\n\n\nהפקודה האחרונה שהרצנו בדוגמה היא פקודת summary. מה עושה הפקודה summary עבור כל סוג עמודה שהיא מוצאת בdata.frame?\n\n\nככלל, הפעלת פונקציה ב-R תיראה כך:\n\n# some code which defines the variable `bar` and then\nsome_result &lt;- some_function(foo = bar)\n\n# or simply\nsome_result &lt;- some_function(bar)\n\nכאשר some_result יחזיק את התוצאה של הפונקציה. הפונקציה עצמה נקראת some_function, היא מקבלת ארגומנט (משתנה) יחיד שנקרא foo ואנחנו משתמשים במשתנה שערכו bar שנכנס לארגומנט.\nכדי להמחיש נראה דוגמה נוספת, הפעם עם פונקציה פשוטה שגם נגדיר בעצמנו. נסו לעיין בקוד ולהבין מה המשמעות של כל שורה בקוד. שלושת השורות הראשונות בקוד מגדירות פונקציה חדשה, וההמשך מריץ אותה.\n\n# define a new function which adds a number\none_plus &lt;- function(number){\n  number + 1\n}\n# use the function:\none_plus(1)\n\n[1] 2\n\none_plus(one_plus(1))\n\n[1] 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>תחביר בסיסי</span>"
    ]
  },
  {
    "objectID": "02-base-R.html#אופרטורים",
    "href": "02-base-R.html#אופרטורים",
    "title": "2  תחביר בסיסי",
    "section": "2.4 אופרטורים",
    "text": "2.4 אופרטורים\nאופרטורים משמשים כדי להגדיר תנאים לוגיים שונים, לדוגמה אם אנחנו רוצים לבדוק את נכונותם של שני תנאים או יותר. ב-R נשתמש בתו כפול || כדי לציין “או” לוגי (or), ונשתמש בתו כפול && על מנת לציין “וגם” לוגי (and).\n\na &lt;- 5\nb &lt;- 6\n\n(a &lt; 3) && (b &gt;= 3)\n\n[1] FALSE\n\n(a &gt;= 5) || (b &gt; 10)\n\n[1] TRUE\n\n\nישנם גם פעולות לוגיות וקטוריות: כמו שניתן לחבר שני וקטורים, ניתן גם לבצע פעולות לוגיות איבר-איבר. פעולות אלו מבוצעות על ידי תו בודד: | או &.\n\nv1 &lt;- c(T, T, F, F)\nv2 &lt;- c(T, F, T, F)\n\nv1 | v2\n\n[1]  TRUE  TRUE  TRUE FALSE\n\nv1 & v2\n\n[1]  TRUE FALSE FALSE FALSE\n\n\n\n\n\n\n\n\nאופרטור || ו-&&\n\n\n\nנסו לבחון מה קורה במקרה של v1 || v2 או v1 && v2. מה החוקיות?\n\n\nאופרטור נוסף הוא אופרטור השלילה (not), נשתמש בתו ! על מנת לייצג אותו. לדוגמה:\n\n!c(T, F)\n\n[1] FALSE  TRUE\n\n!v1\n\n[1] FALSE FALSE  TRUE  TRUE\n\na==5\n\n[1] TRUE\n\n!(a==5)\n\n[1] FALSE\n\n\nשימו לב שבדוגמה האחרונה השתמשנו באופרטור נוסף אשר בודק אם שני אובייקטים הם בעלי אותו הערך. אופרטור זו מצויין עם שיוויון כפול ==. ניתן גם להשוות שני משתנים זה לזה או להשוות שני וקטורים (איבר-איבר) באופן הבא:\n\na == b\n\n[1] FALSE\n\nc(1, 2, 3) == c(2, 1 , 3)\n\n[1] FALSE FALSE  TRUE\n\n\nישנם אופרטורים נוספים ב-R, אך בינתיים נסתפק באופרטורים שצוינו לעיל. כעת, לאחר שלמדנו על אופרטורים לוגיים, באפשרותנו ללמוד על התניות (if cluases) ועל לולאות (loops).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>תחביר בסיסי</span>"
    ]
  },
  {
    "objectID": "02-base-R.html#התניות",
    "href": "02-base-R.html#התניות",
    "title": "2  תחביר בסיסי",
    "section": "2.5 התניות",
    "text": "2.5 התניות\nבמקרים רבים אנחנו רוצים להתנות פעולות מסוימות בקיומו של תנאי כלשהו. ניתן לבצע התניה זו באמצעות הפקודות if, else if, else.\nהמבנה הכללי של התניות יראה כך:\n\nif (condition1) {\n  # some code which evaluates if condition1 == TRUE\n} else if (condition2) {\n  # some code which evaluates if condition1 == FALSE and condition2 == TRUE\n} else {\n  # some code which evaluates if condition1 == FALSE and condition2 == FALSE\n}\n\nעל מנת להדגים, נשתמש בדוגמה הבאה: נניח שאנחנו רוצים לבדוק אם ערך מסוים הוא מספר או לא. נוכל להשתמש בשילוב של if והפונקציה is.numeric:\n\nsome_value &lt;- 100\n\nif (is.numeric(some_value)) {\n  cat(\"This is indeed a numeric value!\")\n} else {\n  cat(\"This is not a numeric value!\")\n}\n\nThis is indeed a numeric value!\n\nsome_value &lt;- \"foobar\"\n\nif (is.numeric(some_value)) {\n  cat(\"This is indeed a numeric value!\")\n} else {\n  cat(\"This is not a numeric value!\")\n}\n\nThis is not a numeric value!\n\n\nאפשר גם להשתמש בהתניות בתוך התניות, כלומר בתוך פקודת if להגדיר פקודת if נוספת.\n\n\n\n\n\n\nתרגיל בבניית פונקציה\n\n\n\nנסו להרחיב את הדוגמה הקודמת, כך שבמידה ו-some_value הוא מספר המתחלק ב-2 אז יודפס “some_value is even” ובמידה ואינו מתחלק ב-2 יודפס “some_value is odd”.\nנסו למצוא יותר מדרך אחת לביצוע הרחבה זו.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>תחביר בסיסי</span>"
    ]
  },
  {
    "objectID": "02-base-R.html#לולאות",
    "href": "02-base-R.html#לולאות",
    "title": "2  תחביר בסיסי",
    "section": "2.6 לולאות",
    "text": "2.6 לולאות\nלולאות הן דרך נוחה כדי לגרום למחשב לעשות הרבה חזרות של אותה הפעולה (רק בשינוי ערכים מסוימים). ב-R ישנם סוגים שונים של לולאות, המתאפיינים בפקודות שונות אבל גם בזמן ריצה (יעילות) שונה.\n\nלולאות for\nלולאות while\nלולאות repeat break next\nלולאות באמצעות תכנות פונקציונלי (כדוגמת פקודת lapply, או פקודות מחבילות אחרות כמו map שנמצאת בחבילת purrr)\n\nעדיף להימנע ככל שניתן משימוש בכל סוגי הלולאות for, while, ו-repeat בעבודה עם R. לולאות אלו מאוד לא יעילות וזמן הריצה שלהן ארוך. תכנות פונקציונלי הוא יותר יעיל, אך דורש קצת יותר “התרגלות”. בכל זאת, נדגים את אופן הפעולה של לולאת for.\nעל מנת להגדיר לולאת for עלינו להגדיר ראשית את טווח הפעולה של הלולאה. לדוגמה, לולאה שרצה על המספרים 1 עד 100 תוגדר באופן הבא:\n\nfor (i in 1:100){\n  # do some action\n  # you can use i for that but don't have to\n}\n\nטווח הפעולה של הלולאה לא חייב להיות מספרי, אפשר גם להשתמש באובייקטים נוספים. לדוגמה נשתמש בלולאה על סוגי פירות. בדוגמה הבאה נשלב גם שימוש בהתניות, כפי שלמדנו בסעיף הקודם. השילוב של לולאות והתניות די נפוץ בתכנות.\n\nfruits &lt;- c(\"Mango\", \"Bannana\", \"Pineapple\", \"Orange\", \"Apple\", \"Prune\", \"Lemon\", \"Loquat\")\nmy_garden &lt;- c(\"Mango\", \"Orange\", \"Lemon\", \"Loquat\")\n\nfor (current_fruit in fruits) {\n  if (current_fruit %in% my_garden) {\n    cat(\"\\nI grow\", current_fruit)\n  } else {\n    cat(\"\\nI don't grow\", current_fruit)\n  }\n}\n\n\nI grow Mango\nI don't grow Bannana\nI don't grow Pineapple\nI grow Orange\nI don't grow Apple\nI don't grow Prune\nI grow Lemon\nI grow Loquat\n\n\n\n\n\n\n\n\nההבדל בין %in% לבין in\n\n\n\nבדוגמה הקודמת השתמשנו ב-in וגם ב-%in%.\nin נחשבת מילת מפתח, בעוד ש-%in% נחשבת אופרטור. עמדו על ההבדלים ביניהן וכתבו מה המשמעות של כל אחת, ומה התפקיד שלה בקוד.\n\n\nנדגים גם כיצד ניתן להחליף לולאה באמצעות פעולה וקטורית, ובאמצעות נוסחה מתמטית. נניח שאנחנו רוצים לחשב סכום של טור הנדסי, כלומר הסכום של \\(1, q, q^2, q^3, \\ldots\\) כאשר \\(q&lt;1\\). נציג שלוש דרכים לבצע את הפעולה הזו: לולאה (הדרך הכי פחות יעילה), פעולה וקטורית (להיעזר בוקטור, כלומר מערך של מספרים), והדרך היעילה ביותר שהיא כמובן פשוט להשתמש בנוסחה של טור הנדסי (\\(\\frac{1}{1-q}\\)).\n\nq &lt;- 1/2\n\nseries_sum_loop &lt;- 0\n\nfor (element_i in 0:50){\n  series_sum_loop &lt;- series_sum_loop + q^element_i\n}\n\nseries_sum_loop\n\n[1] 2\n\nseries_sum_vector &lt;- sum(q^(0:50))\n\nseries_sum_vector\n\n[1] 2\n\nseries_sum_analytic &lt;- 1/(1-q)\n\nseries_sum_analytic\n\n[1] 2\n\n\nחישוב של טור הנדסי הוא כמובן פעולה פשוטה, אבל לא בכל פעולה שנרצה לעשות תהיה נוסחה סגורה כמו שיש שלנו במקרה של טור הנדסי, וגם לא תמיד יהיה אפשר לבצע את הפעולה כפעולה וקטורית.\n\n\n\n\n\n\nתרגיל בבניית סדרת פיבונצ’י\n\n\n\nסדרת פיבונצ’י היא סדרה של מספרים שבה כל איבר הוא הסכום של שני האיברים שקדמו לו. שני האיברים הראשונים מקבלים את הערך 1, ולכן האיברים הראשונים של הסדרה נראים כך:\n\\[\n1, 1, 2, 3, 5, 8, 13, 21, 34,\\ldots\n\\] היעזרו בקוד הבא על מנת לבנות לולאה שתדפיס את 50 האיברים הראשונים של סדרת פיבונצ’י. עליכם להשלים את הקוד במקומות בהם מופיע סימן שאלה.\n\n\n\n# Fibonachi code exercise, fill in the blanks (where you see `?`)\ntotal &lt;- ?\n\nelement_i_minus1 &lt;- 1\nelement_i_minus2 &lt;- 1\n\nfor (? in 3:total){\n  next_element &lt;- element_i_minus1 + ?\n  element_i_minus2 &lt;- element_i_minus1\n  ? &lt;- next_element\n  \n  cat(\"\\n\", ?)\n}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>תחביר בסיסי</span>"
    ]
  },
  {
    "objectID": "02-base-R.html#סיכום",
    "href": "02-base-R.html#סיכום",
    "title": "2  תחביר בסיסי",
    "section": "2.7 סיכום",
    "text": "2.7 סיכום\nבפרק זה למדנו את התחביר הבסיסי של שפת R.\n\nראינו כיצד עובדת השמת משתנים\nלמדנו על סוגי משתנים שונים\nראינו כיצד לקרוא לתתי וקטורים (חלק מוקטור)\nלמדנו על אובייקטים מסוג רשימה (list)\nלמדנו על פונקציות שונות - כיצד להפעיל אותן וכיצד להגדיר פונקציות חדשות\nלמדנו על אופרטורים (וגם, או, לא - NOT, והשוואה)\nלמדנו על התניות (אם… אז… אחרת)\nלמדנו על לולאות (מסוג for), והזכרנו סוגים נוספים.\n\nעד כה הכלים שתיארנו הם כלים כלליים, במובן שבמרבית שפות התכנון ישנן מקבילות דומות. בפרק הבא נתעמק בכלים ייעודיים אשר נבנו ומשמשים לניתוח נתונים סטטיסטי (או ליתר דיוק בהכנת נתונים לניתוח נתונים סטטיסטיקה).\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>תחביר בסיסי</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#קצת-פילוסופיה",
    "href": "03-data-munging-tidyverse.html#קצת-פילוסופיה",
    "title": "3  הכנת נתונים",
    "section": "3.1 קצת פילוסופיה",
    "text": "3.1 קצת פילוסופיה\nהחבילה ב-R שנקראת tidyverse היא למעשה “חבילה של חבילות”.\nהיא מכילה מקבץ חבילות לעבודה עם נתונים כמו dplyr, וכמו tidyr שהן חבילות מאוד שימושיות במניפולציה על נתונים, וסידור נתונים, אבל היא מכילה גם חבילות שממוקדות סביב עולמות תוכן אחרים, כמו stringr לעבודה עם מחרוזות, lubridate לעבודה עם תאריכים, ו-forcats לעבודה עם פקטורים. כפי שחדי העין ישימו לב, לרוב שם של חבילה ירמוז לגבי מהות החבילה (לעיתים עם האות r איפשהו, ולעיתים עם קורטוב של הומור). הפירוט המלא של תוכן החבילה tidyverseוהחבילות שמוכלות בה זמין בקישור.\nעל מנת להתקין את החבילה נשתמש בפקודה install.packages(\"tidyverse\"), ועל מנת לטעון אותה לאחר ההתקנה, נשתמש בפקודה library(tidyverse). שימו לב שבהתקנה צריך להשתמש במרכאות אבל בקריאה לאחר מכן אין צורך במרכאות. את ההתקנה צריך לעשות רק פעם אחת (והיא לוקחת המון זמן), ואת הקריאה לספריה צריך לעשות כל פעם שמפעילים מחדש את R.\nכשלב יסודי, מה שחשוב להבין בעבודה עם נתונים זה שהשאיפה היא שתמיד נשאף להגיע ולעבוד במבנה מסודר שבו:\n\nכל עמודה היא משתנה.\nכל שורה היא תצפית.\nכל תא הוא ערך של משתנה עבור תצפית מסוימות.\n\nאם הדאטה המקורי שלנו לא במבנה הזה - אז כהכנה נרצה להביא אותו למבנה כזה, ואם הוא כבר במבנה המסודר הזה, אז כל פעולה שנעשה, עדיין תשמור את הדאטה במבנה מסודר. המבנה הזה מכונה באנגלית tidy (ומכאן השם tidyverse). אנחנו פשוט נכנה אותו פה מבנה “מסודר”.\nניתן שתי דוגמאות לדאטה, אחד מסודר ואחר לא מסודר. נתחיל בדוגמה לדאטה לא מסודר.\n\n3.1.1 דאטה untidy\nהלשכה המרכזית לסטטיסטיקה מנגישה הרבה נתונים לציבור באמצעות האתר שלה https://www.cbs.gov.il\nמרבית הנתונים שמונגשים לציבור דרך האתר בקבצי אקסל הינם בפורמט לא מסודר. לדוגמה, קובץ שהורדתי מהכתובת הזו והוא עוסק בנפח תנועה מסביב לכנרת בחג הפסח וסוכות.\nזה קובץ אקסל, והוא נראה כך:\n\n\n\nדאטה לא-מסודר מאתר הלשכה המרכזית לסטטיסטיקה\n\n\nאיפה הבעיות עם הדאטה? נראה מה הסעיפים שאינם מתקיימים:\n\nכל עמודה היא משתנה - מתקיים באופן חלקי. משום שיש עמודות מסוימות כמו עמודות H-K שהן ממוזגות מה שהופך אותם ל”לא בדיוק משתנה יחיד”. מדובר בקבוצת משתנים ותכונה שמתארת אותם. בפרט, היינו מצפים לראות שורת כותרת אחת שמתארת את שמות המשתנים (מה שמכונה באנגלית headers), אבל בפועל יש פה הרבה שורות כותרות.\nכל שורה היא תצפית - לא מתקיים בכלל. יש שורות ריקות (כמו שורה 5), ויש שורות שאינן תצפית אלא מתארות תכונות של מקבץ תצפיות (כגון שורה 6 ושורה 14).\nכל תא הוא ערך של משתנה עבור תצפית מסוימת - לא מתקיים. ראו סעיף קודם - מדובר בתאים שמכילים ערכים שמתארים מקבץ תצפיות.\n\nכמו כן, יש עוד כל מיני חריגות לא ברורות בקובץ כגון תאים שמודגשים במסגרת גבול שחורה (מבלי שברור מה המסגרת אומרת), יש תאים שמכילים שתי נקודות (לא ברור מה זה, האם ערך חסר?), שמות המשתנים לעיתים מפוצלים על פני שתי שורות (כמו לדוגמה “ערב פסח” בעמודה F), ועוד בעיות.\nבסיכומו של עניין - אילו היינו רוצים לקלוט קובץ כזה לתוך R על מנת לחלץ את המספרים שבו, היינו צריכים להתאמץ רבות על מנת להפוך את הקובץ למסודר. באופן כללי, ניתן לומר שקבצי אקסל הם מתכון לאסון כי הם מעודדים את המשתמשים לבנות קבצים לא-מסודרים על ידי ביצוע פעולות כמו מיזוג תאים, צביעה של תאים (שזה אינדיקציה לקידוד מידע כלשהו, אבל קידוד שקשה להבין אותו ב”שפת הנתונים”), ועוד שאר בעיות שאין זה המקום לתאר.\n\n\n3.1.2 דאטה tidy\nהנה דוגמה לדאטה מסודר מתוך חבילת palmerpenguins. חבילה זו מכילה נתונים של שלושה זנים של פינגוינים, ואנחנו עוד נשתמש בה בהמשך הספר. לכרגע רק נראה איך נראות עשרת השורות הראשונות בטבלת הנתונים (הסבר על הקוד והתוצר שרואים מצורף מטה):\n\npalmerpenguins::penguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nאנחנו רואים שהאובייקט הוא מסוג tibble (טבלה שהיא גרסה מודרנית יותר של ה-data.frame הבסיסי ב-R). לטבלה הזו יש 344 תצפיות (פינגוינים), ויש לה 8 עמודות (משתנים) שכוללים את הזן של הפינגוין, מאיזה אי הוא, אורך ועומד המקור, אורך הכנף, מסה, מין, והשנה שבה נצפתה הדגימה. הדאטה הזה מסודר ועומד בכללים שהגדרנו.\nלגבי הקוד עצמו שבו השתמשנו: השימוש בנקודותיים :: אומר ל-R לקחת את האובייקט penguins שנמצא בתוך חבילת palmerpenguins (אפשר גם היה לפצל את הקוד וקודם להשתמש ב-library(palmerpenguins) ואז להריץ את head(penguins).\nאם תרצו להריץ את הקוד הזה אצלכם במחשב, יכול להיות שתצטרכו קודם להתקין את החבילה על ידי שימוש בפקודה install.packages(\"palmerpenguins\").\nכעת לאחר שלמדנו קצת על מה הוא דאטה מסודר, נראה איך אפשר לקרוא נתונים ו”להציץ” בנתונים, כדי לקבל מושג מה יש בנתונים ואיך לגשת אליהם.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#הצצה-ראשונית",
    "href": "03-data-munging-tidyverse.html#הצצה-ראשונית",
    "title": "3  הכנת נתונים",
    "section": "3.2 הצצה ראשונית",
    "text": "3.2 הצצה ראשונית\nבדרך כלל לפני הצצה ראשונית על הנתונים, אנחנו נידרש לקרוא אותם. קריאת הנתונים יכולה להתבצע ממגוון פורמטים. לדוגמה:\n\nקריאה מפורמט של CSV (Comma Separated Values, קרי קובץ טקסט המפריד ערכים באמצעות פסיקים), באמצעות פונקציות כגון read.csv, readr::read_csv.\nקריאה מפורמט של אקסל באמצעות פונקציה כגון: readxl::read_excel.\nקריאה מפורמט של תוכנות סטטיסטיות אחרות כגון SPSS או SAS באמצעות פקודות מחבילת haven.\nפורמטים וכלים נוספים.\n\nנתמקד בקבצי CSV, הפקודה המועדפת עלי היא readr::read_csv (בהשוואה ל-read.csv שנמצאת ב-Base R). הפקודה read_csv מעט מהירה ונוחה יותר מבחינת השליטה שהיא מאפשרת בקריאת הנתונים.\n\n\n\n\n\n\nTip\n\n\n\nקראו את התיעוד של read.csv ושל read_csv. איזה הבדלים אתם מזהים בין הפקודות?\nלצורך קריאת התיעוד ניתן לכתוב ב-Console ?read.csv, ?readr::read_csv.\n\n\nנקרא כעת את טבלת הPenguins שראינו בחלק הקודם. שימו לב שאנחנו משתמשים במיקום קובץ באינטרנט, אבל ניתן גם לקרוא קבצים שנמצאים מקומית על המחשב.\n\nlibrary(readr)\npenguins &lt;- read_csv(\"https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv\")\n\nעל מנת להציץ בדאטה יש מספר פקודות שניתן להשתמש בהן:\n\nהפקודה View (עם V גדולה) - פקודה זו מתאימה לדאטה בגודל קטן עד בינוני, והיא מציגה טבלה עם הנתונים.\nהפקודה glimpse תציג את הערכים הראשונים של כל אחד מהמשתנים, כמו גם את שמות המשתנים, ואת סוגם.\nהפקודה head תציג טבלה המוגבלת לשש התצפיות הראשונות. אפשר להשתמש בארגומנט של הפונקציה על מנת להציג יותר שורות. הפקודה tail עובדת באופן דומה (רק מתחתית הטבלה).\nלכתוב ב-Console את שם הטבלה וללחוץ על Enter פשוט יציג את הטבלה (אם מדובר בtibble אז היא תוצג בפורמט קומפקטי ונוח).\n\n\nlibrary(tidyverse)\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\nhead(penguins)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\nhead(penguins, 10)\n\n# A tibble: 10 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n\n\n\n\nTip\n\n\n\nעברו על הפלט וודאו שאתם מצליחים להבין אילו חלקים בכל אחד מהפלטים מספק את המידע: סוג המשתנה, שם המשתנה, גודל הטבלה.\n\n\nבמבט על הפלט של כל אחת מהפקודות להלן ניתן כבר להבין את הפרטים הבאים:\n\nהאובייקט שאנחנו בוחנים הוא טבלה מסוג tibble, בגודל של 344 שורות (תצפיות), ו-8 עמודות (משתנים).\nסוגי המשתנים הם מחרוזות (character - chr), מספרים ממשיים (double - dbl).\n\nמחרוזות: species, island, sex\nמספרים ממשיים: bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year.\n\n\nכעת, לאחר שלמדנו איך להבין את מבנה הדאטה באופן ראשוני, נציג פונקציות שמשמשות לשינוי משתנים (טרנספורמציות).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#טרנספורמציות",
    "href": "03-data-munging-tidyverse.html#טרנספורמציות",
    "title": "3  הכנת נתונים",
    "section": "3.3 טרנספורמציות",
    "text": "3.3 טרנספורמציות\nטרנספורמציה היא פעולה (פונקציה) על משתנה או צירוף של משתנים המניבה משתנה עם ערך חדש. היא יכולה להיות פעולה מתמטית פשוטה כמו לוגריתם, פונקציה טריגונומטרית, או מכפלה בסקלר (ערך כלשהו).\nגם פעולה על מחרוזת היא טרנספורמציה, כגון החזרת אורך המחרוזת או חלק ממחרוזת.\nטרנספורמציות ב-R יבוצעו באמצעות הפקודה mutate, והן יכולות לדרוס ערך קיים או להוסיף משתנה חדש לטבלה. התוצאה תוחזר בטבלה חדשה לגמרי (ולא תדרוס את הטבלה שהוזנה לתוך הפונציה mutate.\nבנוסף, על מנת להפעיל את הטרנספורמציה עם פקודת mutate (ובאופן כללי בשימוש ב-tidyverse) נשתמש באופרטור הנקרא pipe (מקטרת או צינור) ומטרתו להפוך את הקוד ליותר ברור. ישנם שני אופרטורים מסוג pipe: %&gt;% ו-|&gt;. בספר זה נשתמש בנוסח הראשון (הנוסח השני נמצא ב-Base R החל מגרסה 4.0.0).\nלהלן דוגמה המייצרת משתנה חדש (עמודה נוספת) ל-penguins, של משקל בקילוגרמים.\n\nnew_penguins &lt;- penguins %&gt;% \n  mutate(body_mass_kg = body_mass_g/1000)\n\nglimpse(new_penguins)\n\nRows: 344\nColumns: 9\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      &lt;dbl&gt; 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…\n\n\nכפי שניתן לראות האובייקט new_penguins דומה מאוד לאובייקט המקורי penguins (שלא השתנה). האובייקט החדש מכיל עמודה נוספת שהיא המשקל של התצפית בק”ג.\nהאופרטור pipe מסמן ל-R להכניס את הדאטה penguins כארגומנט ראשון בפונקציה mutate. זה שקול לכתיב הבא: mutate(penguins, body_mass_kg = body_mass_g/1000). היתרון בשימוש ב-pipe יבוא לידי ביטוי כאשר נרצה לשרשר מספר רב של פקודות, וללא שימוש ב-pipe נצטרך להכניס פונקציה בתוך פונקציה או להגדיר הרבה אובייקטי ביניים.\nלהלן דוגמה נוספת, הפעם עם טרנספורמציה של מחרוזת, באמצעות פונקציה str_sub (מחבילת stringr) אשר דורסת את המשתנה sex והופכת male ל-m ו-female ל-f. המשתנה נדרס משום שהשם שהגדרנו בתוך הפקודה mutate הינו השם של המשתנה הקיים במקום שם משתנה חדש כפי שעשינו בדוגמה של משקל התצפית.\n\nnew_gender_penguin &lt;- new_penguins %&gt;% \n  mutate(sex = str_sub(sex, start = 1, end = 1))\n\nglimpse(new_gender_penguin)\n\nRows: 344\nColumns: 9\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;chr&gt; \"m\", \"f\", \"f\", NA, \"f\", \"m\", \"f\", \"m\", NA, NA, NA, N…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      &lt;dbl&gt; 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#שמות-ובחירה",
    "href": "03-data-munging-tidyverse.html#שמות-ובחירה",
    "title": "3  הכנת נתונים",
    "section": "3.4 שמות ובחירה",
    "text": "3.4 שמות ובחירה\nבחירת ושינוי שם משתנים היא פעולה שקוראת הרבה במהלך ניתוח נתונים, ובפרט אם הקובץ המקורי שלנו הוא עם כותרות (headers) בעברית, אז אחד הדברים הראשונים שנרצה לעשות הוא לשנות את שמות העמודות לאנגלית, על מנת שיהיה יותר קל לעבוד עם הנתונים.\nעל מנת לבחור משתנים ניתן להשתמש בפונקציה select ועל מנת לשנות שמות של משתנים ניתן להשתמש בפונקציה rename, לדוגמה, הקוד הבא משנה את שם המשתנה sex ל-gender ואז בוחר אותו.\n\npenguin_gender &lt;- new_gender_penguin %&gt;% \n  select(sex) %&gt;% \n  rename(gender = sex)\n\nglimpse(penguin_gender)\n\nRows: 344\nColumns: 1\n$ gender &lt;chr&gt; \"m\", \"f\", \"f\", NA, \"f\", \"m\", \"f\", \"m\", NA, NA, NA, NA, \"f\", \"m\"…\n\n\nכאשר עובדים עם קובץ שבו כותרות המקור היו בעברית, נצטרך להשתמש ב-Back ticks (המרכאה שנמצאת מעל מקש ה-Tab) על מנת לבחור או לשנות את שם המשתנה. לדוגמה נניח שיש לנו שם של משתנה שנקרא”מגדר” ואנחנו רוצים לשנות אותו ל-gender\n\nmy_hebrew_data %&gt;% \n  rename(gender = `מגדר`)\n\nלאחר שינוי השם ל-gender ניתן יהיה לוותר על ה-Back ticks.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#בחירה-מתקדמת",
    "href": "03-data-munging-tidyverse.html#בחירה-מתקדמת",
    "title": "3  הכנת נתונים",
    "section": "3.5 בחירה מתקדמת",
    "text": "3.5 בחירה מתקדמת\nישנן פונקציות עזר שמאפשרות לנו לבחור בצורה חכמה את המשתנים שעליהם ברצוננו להכיל פעולות מסוימות (כגון טרנספורמציות, שינוי שם, או אפילו רק לבחור משתנים בצורה חכמה). הפונקציות המרכזיות שישמשו אותנו בבחירת משתנים מתקדמת הינן:\n\nwhere כדי להכיל תנאים על סוג המשתנה, לדוגמה משתנה שהוא מספרי או תווים;\nends_with, starts_with, contains, any_of, matches כדי לבחור משתנים לפי תת-מחרוזת שמופיעה בהם;\nacross על מנת להחיל טרנספורמציות על כל המשתנים שעונים על קריטריונים שהוגדרו עם הפונקציות לעיל.\n\nנמחיש באמצעות שתי דוגמאות.\nדוגמה ראשונה: נניח שברצוננו לחלק ב-10 את כל המשתנים שמסתיימים ב-“mm” (בעצם להחליף מיחידות של מילימטר ליחידות של ס”מ). אז ניעזר בפונקציה ends_with(\"mm\") בשביל לזהות את המשתנים הללו, ובפונקציה across על מנת להפעיל עליהם את הטרנספורמציה ~{.x/10} (שזו דרך סימבולית לבנות פונקציה שמחלקת מספר ב-10). התוצאה הסופית תיראה כך. לבסוף נרצה לשנות את “mm” ל- ”cm”.\n\npenguin_cm &lt;- penguins %&gt;% \n  mutate(across(ends_with(\"mm\"), ~{.x/10})) %&gt;% \n  rename_with(~str_replace(.x, \"mm\", \"cm\"),\n              ends_with(\"mm\"))\n\nglimpse(penguin_cm)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_cm    &lt;dbl&gt; 3.91, 3.95, 4.03, NA, 3.67, 3.93, 3.89, 3.92, 3.41, …\n$ bill_depth_cm     &lt;dbl&gt; 1.87, 1.74, 1.80, NA, 1.93, 2.06, 1.78, 1.96, 1.81, …\n$ flipper_length_cm &lt;dbl&gt; 18.1, 18.6, 19.5, NA, 19.3, 19.0, 18.1, 19.5, 19.3, …\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nשימו לב שהשתמשנו בפונקציה rename_with שמאפשרת להגדיר שינוי של קבוצת משתנים בבת אחת במקום משתנים ספציפיים אחד-אחד (המתבצע באמצעות rename).\nדוגמה שניה: נניח שברצוננו לחתוך את כל המשתנים שהן מחרוזות רק לשלושת התווים הראשונים שלהם. הפונקציה באמצעותה חותכים מחרוזות היא str_sub ונשתמש ב-where(is.character) בשביל לאתר את כל המשתנים שהם מחרוזות. נפעיל זאת על התוצאה של החישוב מהדוגמה הקודמת (על מנת לקבל טבלה חדשה שמכילה את כל השינויים במצטבר), באופן הבא:\n\npenguin_short &lt;- penguin_cm %&gt;% \n  mutate(across(where(is.character),\n                ~str_sub(.x, start = 1L, end = 3L)))\n\nglimpse(penguin_short)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_cm    &lt;dbl&gt; 3.91, 3.95, 4.03, NA, 3.67, 3.93, 3.89, 3.92, 3.41, …\n$ bill_depth_cm     &lt;dbl&gt; 1.87, 1.74, 1.80, NA, 1.93, 2.06, 1.78, 1.96, 1.81, …\n$ flipper_length_cm &lt;dbl&gt; 18.1, 18.6, 19.5, NA, 19.3, 19.0, 18.1, 19.5, 19.3, …\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\n\n\n\n\n\nTip\n\n\n\nעדכנו את הטבלה כך שלכל המשתנים שהינם מסוג מחרוזת תתווסף הסיומת “_chr”.\nבצעו זאת בשתי דרכים:\n\nבאמצעות rename;\nבבת אחת על ידי שימוש ב-where, וב-paste0, בתוך פקודת rename_with.\n\nכעת השתמשו בפונקציה mutate על מנת להמיר את המשתנה body_mass_g מגרמים לקילוגרמים. בצעו זאת בשתי דרכים:\n\nבאמצעות mutate על ידי רשימת הטרנספורמציה ישירות על המשתנה;\nבאמצעות mutate על ידי שימוש בפונקציות בחירה (לדוגמה ends_with(\"_g\"), ביחד עם across).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#פעולות-סינון",
    "href": "03-data-munging-tidyverse.html#פעולות-סינון",
    "title": "3  הכנת נתונים",
    "section": "3.6 פעולות סינון",
    "text": "3.6 פעולות סינון\nפעולה נפוצה בניתוח נתונים היא סינון של הנתונים לפי קריטריונים מסוימים. הפקודה שמסייעת לנו בסינון נקראת filter, ואפשר להגדיר באמצעותה קריטריונים או שילוב של קריטריונים שונים.\nלדוגמה, הקוד הבא יסנן מתוך הדאטה רק פינגויינים שחיים באי Dream:\n\npenguins %&gt;% \n  filter(island == \"Dream\")\n\n# A tibble: 124 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Dream            39.5          16.7               178        3250\n 2 Adelie  Dream            37.2          18.1               178        3900\n 3 Adelie  Dream            39.5          17.8               188        3300\n 4 Adelie  Dream            40.9          18.9               184        3900\n 5 Adelie  Dream            36.4          17                 195        3325\n 6 Adelie  Dream            39.2          21.1               196        4150\n 7 Adelie  Dream            38.8          20                 190        3950\n 8 Adelie  Dream            42.2          18.5               180        3550\n 9 Adelie  Dream            37.6          19.3               181        3300\n10 Adelie  Dream            39.8          19.1               184        4650\n# ℹ 114 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nדוגמה נוספת לחיתוך מורכב יותר היא להחזיר את כל הפינגויינים ממין זכר או מין לא ידוע שחיים באי Dream:\n\npenguins %&gt;% \n  filter(!is.na(sex) | sex == \"male\") %&gt;% \n  filter(island == \"Dream\")\n\n# A tibble: 123 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Dream            39.5          16.7               178        3250\n 2 Adelie  Dream            37.2          18.1               178        3900\n 3 Adelie  Dream            39.5          17.8               188        3300\n 4 Adelie  Dream            40.9          18.9               184        3900\n 5 Adelie  Dream            36.4          17                 195        3325\n 6 Adelie  Dream            39.2          21.1               196        4150\n 7 Adelie  Dream            38.8          20                 190        3950\n 8 Adelie  Dream            42.2          18.5               180        3550\n 9 Adelie  Dream            37.6          19.3               181        3300\n10 Adelie  Dream            39.8          19.1               184        4650\n# ℹ 113 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nבדוגמה זו ביצענו שני חיתוכים אחד אחרי השני, כאשר הראשון מכיל אופרטור “או” (תנאי מגדר שווה זכר או ערך חסר), והחיתוך השני נותר כפי שהיה בדוגמה הקודמת. בצורה כזו קיבלנו הפעלה של שני התנאים (“וגם”).\nניתן גם להשתמש במספר ארגומנטים בתוך פקודת filter אחת (הפרדה עם פסיק), וניתן גם להשתמש באופרטור &. לדוגמה, שתי הגרסאות הבאות יניבו את אותה התוצאה:\n\npenguins %&gt;% \n  filter(!is.na(sex) | sex == \"male\",\n         island == \"Dream\") \n\npenguins %&gt;% \n  filter((!is.na(sex) | sex == \"male\") &\n         island == \"Dream\") \n\n\n\n\n\n\n\nTip\n\n\n\nהיעזרו בפקודה filter וכתבו קוד שיחלץ את כל הפינגווינים מסוג Adelie או Chinstrap, בשלוש דרכים שונות:\n\nעל ידי שימוש באופרטור %in% (בתוך…)\nעל ידי שימוש באופרטור != (שונה מ…)\nעל ידי שימוש באופרטור | (או)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#פעולות-לפי-קיבוצים",
    "href": "03-data-munging-tidyverse.html#פעולות-לפי-קיבוצים",
    "title": "3  הכנת נתונים",
    "section": "3.7 פעולות לפי קיבוצים",
    "text": "3.7 פעולות לפי קיבוצים\nבעת ניתוח נתונים, פעולה המבוצעת באופן תדיר היא פעולת סיכום לפי קיבוצים. היא שימושית במצבים בהם אנחנו רוצים להפעיל פונקציה וקטורית, כזו שמקבלת וקטור ומחזירה ערך בודד (כגון: ממוצע, מינימום, מקסימום, סטיית תקן, חציון, סכום, וכו’). פעולה לפי קיבוץ תאפשר לנו לקבל בבת אחת את הפעלת הפונקציה הוקטורית על פני קבוצות שונות המובחנות בנתונים.\nנמשיך עם דוגמת הפינגווינים. נניח שאנחנו רוצים להשוות בין הזנים השונים, ועבור כל זן פינגווינים לחשב את המשקל הממוצע, סטיית התקן, משקל מינימלי ומשקל מקסימלי בין התצפיות. הקוד הבא מטפל בחישובים הללו, ויש לו שתי פונקציות חשובות שנסביר עליהן: group_by ו-summarize.\n\npenguins %&gt;% \n  filter(!is.na(body_mass_g)) %&gt;% \n  group_by(species) %&gt;% \n  summarize(avg_mass = mean(body_mass_g),\n            min_mass = min(body_mass_g),\n            max_mass = max(body_mass_g),\n            sd_mass = sd(body_mass_g))\n\n# A tibble: 3 × 5\n  species   avg_mass min_mass max_mass sd_mass\n  &lt;fct&gt;        &lt;dbl&gt;    &lt;int&gt;    &lt;int&gt;   &lt;dbl&gt;\n1 Adelie       3701.     2850     4775    459.\n2 Chinstrap    3733.     2700     4800    384.\n3 Gentoo       5076.     3950     6300    504.\n\n\nקיבלנו טבלה בעלת שלוש שורות, כל שורה מתייחסת לזן מסוים של פינגויינים, ומציגה את המשקל הממוצע, מינימלי, מקסימלי, וסטיית תקן.\nמשמעות שרשרת הפקודות:\n\nהפקודה הראשונה filter משמשת כדי להוציא החוצה תצפיות חסרות.\nהפקודה הבאה group_by מנחה לבצע את החישובים שאחריה לפי הקיבוץ המוגדר (במקרה זה לפי המשתנה species.\nהפקודה האחרונה בשרשרת, summarize, מזכירה קצת את mutate עליה הסברנו בחלק של טרנספורמציות, אבל מכיוון שבמקרה זה מדובר בחישובים שמקבלים וקטור ומחזירים מספר, אנחנו צריכים להשתמש בה. היא יודעת לעבוד עם הקיבוצים שהוגדרו ולהחזיר את החישובים המבוקשים. בתוך הפקודה summarize אנחנו מגדירים איזה חישובים אנחנו רוצים, וגם מהם שמות המשתנים החדשים. בדוגמה הגדרנו את avg_mass כמשתנה חדש שהוא תוצאת החישוב של הפונקציה mean על המשתנה המקורי שנקרא body_mass_g, וכנ”ל עבור יתר המשתנים (min_mass, max_mass, sd_mass).\n\nבפקודה group_by ניתן להגדיר קיבוצים לפי מספר משתנים.\n\n\n\n\n\n\nTip\n\n\n\nשנו את הקוד בדוגמה האחרונה כך שתתקבל טבלה עם שש שורות, הכוללת חישובים עבור כל זן ומין הפינגויין.\n\n\n\n\n\n\n\n\nTip\n\n\n\nהסבירו מדוע הקוד הבא אינו עובד:\n\npenguins %&gt;% \n  filter(!is.na(body_mass_g)) %&gt;% \n  group_by(species) %&gt;% \n  summarize(avg_mass = mean(body_mass_g)) %&gt;% \n  summarize(min_mass = min(body_mass_g))\n\n\n\n\n3.7.1 פעולות סיכום מורכבות\nאת הפונקציה across הכרנו כבר בשלב מוקדם יותר בפרק זה (כשהסברנו על הפוקנציה mutate). באופן אמצעות שימוש בפקודה across ניתן להגדיר פעולות סיכום מורכבות על פני קיבוצים שונים ועל פני מספר משתנים רב. לדוגמה, נניח שאנו רוצים לקבל ממוצע של כל המשתנים הנומריים על פני סוגים שונים של פינגווינים. נוכל לעשות זאת באמצעות הקוד הבא:\n\npenguins %&gt;% \n  filter(!is.na(body_mass_g)) %&gt;% \n  group_by(species) %&gt;% \n  summarize(across(bill_length_mm:body_mass_g,\n                   mean))\n\n# A tibble: 3 × 5\n  species   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n1 Adelie              38.8          18.3              190.       3701.\n2 Chinstrap           48.8          18.4              196.       3733.\n3 Gentoo              47.5          15.0              217.       5076.\n\n\n\n\n\n\n\n\nNote\n\n\n\nיש הרבה הכללות שניתן לעשות עם הקוד הקודם, לדוגמה באופן בחירת המשתנים עליהם עובדת הפקודה, בהגדרת הפונקציה, או בהגדרת הרבה פונקציות בבת אחת.\nכדוגמה שממנפת הרבה מהגמישות אליה ניתן להגיע אנחנו מצרפים את הקוד הבא. הקוד מחשב עבור כל המשתנים שמסתיימים ב \"_mm\" ממוצע, וסטיית תקן, תוך שהחישובים מתעלמים מערכים חסרים באמצעות שימוש בארגומנט na.rm=TRUE של הפונקציות mean, sd. הקוד משתמש בקיבוץ לפי סוג הפינגויין והאי ממנו הגיע.\nנסו לנתח ולהבין כל שורה מהקוד ועל מה היא אחראית.\n\npenguins %&gt;% \n  group_by(species, island) %&gt;% \n  summarize(across(ends_with(\"mm\"),\n                   list(avg = ~mean(., na.rm = T),\n                        sd = ~sd(., na.rm = T))))\n\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 5 × 8\n# Groups:   species [3]\n  species   island    bill_length_mm_avg bill_length_mm_sd bill_depth_mm_avg\n  &lt;fct&gt;     &lt;fct&gt;                  &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1 Adelie    Biscoe                  39.0              2.48              18.4\n2 Adelie    Dream                   38.5              2.47              18.3\n3 Adelie    Torgersen               39.0              3.03              18.4\n4 Chinstrap Dream                   48.8              3.34              18.4\n5 Gentoo    Biscoe                  47.5              3.08              15.0\n# ℹ 3 more variables: bill_depth_mm_sd &lt;dbl&gt;, flipper_length_mm_avg &lt;dbl&gt;,\n#   flipper_length_mm_sd &lt;dbl&gt;",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "03-data-munging-tidyverse.html#סיכום",
    "href": "03-data-munging-tidyverse.html#סיכום",
    "title": "3  הכנת נתונים",
    "section": "3.8 סיכום",
    "text": "3.8 סיכום\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>הכנת נתונים</span>"
    ]
  },
  {
    "objectID": "04-visualizations-ggplot2.html#הבסיס",
    "href": "04-visualizations-ggplot2.html#הבסיס",
    "title": "4  ויז’ואליזציות",
    "section": "4.1 הבסיס",
    "text": "4.1 הבסיס\nנתחיל בגרף פשוט, ונתקדם ממנו לסדרה של גרפים. ראשית נטען את החבילות הנדרשות לנו לפרק, ונגדיר את התמה – עיצוב הגרפים – שבו נשתמש (הסבר נוסף על תמות בהמשך פרק זה).\n\nlibrary(palmerpenguins)\nlibrary(tidyverse)\nggplot2::theme_set(ggplot2::theme_bw())\n\n\npenguins %&gt;% \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm)) + \n  geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nראשית מבחינת הנתונים המוצגים, לא ניתן להבחין בקשר משמעותי. במידה מסוימת נראה שעליה במשתנה bill_length_mm מעידה על ירידה במשתנה bill_depth_mm (כי ככל שמתקדמים בציר ה-x יש ירידה קלה של התצפיות בציר ה-y). זוהי מסקנה שגויה, ותיכף נבין למה, אבל לפני כן, עוד מספר הסברים:\nהודעת האזהרה שמופיעה מעל הגרף מיידעת אותנו שיש שתי שורות שאינן באות לידי ביטוי בתרשים בשל ערכים חסרים (חסר נתון על אורך או עומק או שניהם).\nבנוגע לתחביר:\n\nהפונקציה ggplot מגדירה תרשים.\nהארגומנט הראשון שלה הוא הדאטה עצמו (penguins), שנכנס באמצעות האופרטור %&gt;%.\nהארגומנט השני נכנס כפונקציה aes() שמגדירה אסטטיקות. במקרה זה מוגדרים שני מיפויי אסטטיקות, לציר x ולציר y.\nלאחר מכן יש חיבור + על מנת להוסיף שכבה של גיאומטריה מסוג נקודה geom_point, וקיבלנו גרף.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>ויז'ואליזציות</span>"
    ]
  },
  {
    "objectID": "04-visualizations-ggplot2.html#מיפויים-נוספים",
    "href": "04-visualizations-ggplot2.html#מיפויים-נוספים",
    "title": "4  ויז’ואליזציות",
    "section": "4.2 מיפויים נוספים",
    "text": "4.2 מיפויים נוספים\nכעת ניזכר שבדאטה מיוצגים שלושה זנים של פינגויינים, וייתכן שהקשר גם מושפע מעובדה זו. נוסיף מיפוי של זן הפינגויין לצבע של הנקודות. הוספה זו תתבצע עם הארגומנט color=species:\n\nbase_penguins_chart &lt;- penguins %&gt;% \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             color = species)) + \n  geom_point()\n\nכעת לאחר הוספת הצבע ניתן להבחין בבירור בכך שבכל אחד מהזנים עליה במשתנה bill_length_mm מביאה לעלייה במשתנה bill_depth_mm (וזה בעצם הפוך למה שחשבנו כשהסתכלנו על התרשים מבלי לחלק לזנים של הפינגויינים השונים). זו תובנה מאוד משמעותית, שנקראת בשפה המקצועית “אינטראקציה”. יש אינטראקציה בין אורך המקור לבין זן הפינגויין בהשפעתם על עומק המקור. ניגע באינטראקציות גם בהמשך (בפרק על רגרסיה לינארית).\nנוסיף לגרף גם שלושה קווי רגרסיה לינארית, עבור כל אחת מהקבוצות:\n\nbase_penguins_chart + \n  stat_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nכדאי להכיר - “פרדוס סימפסון”: התופעה שבה הבחנו בשינוי המשמעות של הקשר בין המשתנים כאשר מוסיפים אינטראקציה או זיהוי של הקבוצה, תוארה על ידי סימפסון (Simpson 1951). אחד מהגילגולים המודרנים של הפרדוקס הזה נמצא בדאטהסט שנוצר על ידי סימולציה ונקרא Datasaurus dozen (ראו Murray and Wilson 2021).\nב-Datasaurus משתמשים בסימולציה כדי לייצר שנים עשר קבוצות שבפני עצמן נראות זהות בפרמטרים מסוימים (ממוצע בציר x, ממוצע בציר y, סטיית תקן, קורלציה, וכו’), אבל כשמציגים את הנקודות בדיאגרמת פיזור, באופן מובחן בין הקבוצות, מקבלים את התרשים הבא:\n\nlibrary(datasauRus)\ndatasaurus_dozen %&gt;% \n  group_by(dataset) %&gt;% \n  summarize(mean(x),\n            mean(y),\n            sd(x),\n            sd(y),\n            cor(x, y))\n\n# A tibble: 13 × 6\n   dataset    `mean(x)` `mean(y)` `sd(x)` `sd(y)` `cor(x, y)`\n   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 away            54.3      47.8    16.8    26.9     -0.0641\n 2 bullseye        54.3      47.8    16.8    26.9     -0.0686\n 3 circle          54.3      47.8    16.8    26.9     -0.0683\n 4 dino            54.3      47.8    16.8    26.9     -0.0645\n 5 dots            54.3      47.8    16.8    26.9     -0.0603\n 6 h_lines         54.3      47.8    16.8    26.9     -0.0617\n 7 high_lines      54.3      47.8    16.8    26.9     -0.0685\n 8 slant_down      54.3      47.8    16.8    26.9     -0.0690\n 9 slant_up        54.3      47.8    16.8    26.9     -0.0686\n10 star            54.3      47.8    16.8    26.9     -0.0630\n11 v_lines         54.3      47.8    16.8    26.9     -0.0694\n12 wide_lines      54.3      47.8    16.8    26.9     -0.0666\n13 x_shape         54.3      47.8    16.8    26.9     -0.0656\n\ndatasaurus_dozen %&gt;% \n  ggplot(aes(x = x, y = y)) + \n  geom_point() + \n  facet_wrap(~dataset)\n\n\n\n\n\n\n\n\n\n\nבתרשים זה השתמשנו גם בפונקציות שראינו קודם, וגם בפונקציה נוספת שנקראת facet_wrap שמפרקת את התרשים לתתי-תרשימים, בכל אחד נמצאים הנתונים של קבוצה אחרת (מהמשתנה dataset).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>ויז'ואליזציות</span>"
    ]
  },
  {
    "objectID": "04-visualizations-ggplot2.html#כותרות-גרף-וצירים",
    "href": "04-visualizations-ggplot2.html#כותרות-גרף-וצירים",
    "title": "4  ויז’ואליזציות",
    "section": "4.3 כותרות גרף וצירים",
    "text": "4.3 כותרות גרף וצירים\nכעת נייפה את הגרף עם כותרות:\n\npebguin_chart_w_lm &lt;- base_penguins_chart +\n  stat_smooth(method = \"lm\", se = FALSE) +\n  xlab(\"Bill length [mm]\") + \n  ylab(\"Bill depth [mm]\") + \n  ggtitle(\"Relationship of bill length and depth in penguins\", \n          subtitle = \"Interaction with species (with linear regression)\")\n\npebguin_chart_w_lm\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>ויז'ואליזציות</span>"
    ]
  },
  {
    "objectID": "04-visualizations-ggplot2.html#הגדרת-תמות",
    "href": "04-visualizations-ggplot2.html#הגדרת-תמות",
    "title": "4  ויז’ואליזציות",
    "section": "4.4 הגדרת תמות",
    "text": "4.4 הגדרת תמות\nניתן להגדיר תמות (Themes) שיתנו לגרף חזות אחרת. בחבילת ggplot2 יש כמה תמות מוגדרות מראש שניתן להתחיל מהם וגם לעצב אותן מחדש. כדוגמה, נשתמש בתמה מסוג linedraw ונגדיר מחדש את מיקום המקרא ואת גודל הטקסט של הכותרות.\n\npebguin_chart_w_lm +\n  theme_linedraw() + \n  theme(legend.position = \"top\",\n        plot.title = element_text(size = 22),\n        axis.title = element_text(size = 15),\n        legend.box.background = element_rect(linetype = 1, linewidth = 1))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nרוב הרכיבים בתוך התרשים נשלטים בתוך הפונקציהtheme באמצעות פונקציות הכוונה כגון element_text (מאפייני טקסט), element_rect (מאפייני תחום מרובע), element_line (מאפייני קווים), וכו’. בתיעוד הפקודה theme ניתן לעיין באפשרויות השונות.\n\n\n\n\n\n\n\n\nTip\n\n\n\nהשתמשו בפקודה facet_wrap כשכבה נוספת לתרשים הקודם על מנת לפצל את הזנים השונים לתתי-תרשימים. הדגמה לשימוש בפקודה נמצאת בחלק הקודם של פרק זה (בקוד שמסביר על פרדוקס סימפסון).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>ויז'ואליזציות</span>"
    ]
  },
  {
    "objectID": "04-visualizations-ggplot2.html#גיאומטריות-נוספות",
    "href": "04-visualizations-ggplot2.html#גיאומטריות-נוספות",
    "title": "4  ויז’ואליזציות",
    "section": "4.5 גיאומטריות נוספות",
    "text": "4.5 גיאומטריות נוספות\nנדגים מספר גיאומטריות נוספות מההיצע הרב שיש בחבילת ggplot2. שימו לב, בסוף הפרק מדריך שיסייע לכם להחליט באיזה תרשים כדאי להשתמש לפי סוג המשתנים או היחס בין משתנים שאתם רוצים להדגים.\n\n4.5.1 Boxplot\nדיאגרמה מסוג Boxplot עוזרת לנו להבין את צורת ההתפלגות. הדיאגרמה מציגה “קופסה” שתוחמת 50% מהנתונים (החלק התחתון של הקופסה הוא רבעון ראשון, והחלק העליון של הקופסה הוא רבעון שלישי). במרכזה של הקופסה מוצג החציון קקו עבה (מחלק את התצפיות לחצי-חצי). ערכי קיצון, אם ישנם, מופיעים כנקודות. במידה ומופיעה קופסה שאינה סימטרית סביב החציון, הדבר מעיד על כך שההתפלגות אינה התפלגות נורמלית.\nנציג את התפלגות המשקל של הפינגויינים בתרשים, בהפרדה לפי זן הפינגויינים, ומיד לאחריו נציג את החציון, ורבעונים של כל קבוצה.\n\npenguins %&gt;% \n  ggplot(aes(y = body_mass_g, x = species)) + \n  geom_boxplot() + \n  ggtitle(\"Penguin weight\") + \n  xlab(\"Species\") + \n  ylab(\"Mass [grams]\")\n\nWarning: Removed 2 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\npenguins %&gt;% \n  filter(!is.na(body_mass_g)) %&gt;% \n  group_by(species) %&gt;% \n  summarize(median_mass = median(body_mass_g),\n            q1_mass = quantile(body_mass_g, 0.25),\n            q3_mass = quantile(body_mass_g, 0.75))\n\n# A tibble: 3 × 4\n  species   median_mass q1_mass q3_mass\n  &lt;fct&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Adelie           3700   3350     4000\n2 Chinstrap        3700   3488.    3950\n3 Gentoo           5000   4700     5500\n\n\nאיך מזהים ערכי קיצון?\nערכי קיצון היא בעיה בפני עצמה ואפשר להקדיש לה פרק, ואפילו ספר שלם. יש לערכי קיצון השלכות משמעותיות במגוון שימושים, החל ממודלים (כמו רגרסיה שנלמד עליה בספר זה) וחישובים שונים (ממוצע לדוגמה מושפע מאוד מערכי קיצון), דרך זיהוי אנומליות.\nערכי הקיצון מחושבים כ-1.5*טווח בין רבעוני מהרבעון הראשון מטה או מהרבעון השלישי מעלה, כלומר נקודות אשר מרוחקות לפחות פי 1.5 הטווח הבין רבעוני (הטווח “הסביר”) ביחס לרבעונים.\nאם נמחיש זאת על קבוצת הפינגויינים מסוג Chinstrap. הרבעון הראשון מתקבל ב-3488 גרם, והרבעון השלישי מתקבל ב-3950 גרם. הטווח הבין רבעון לכן הינו 462. כלומר הטווח הבין רבעוני כפול 1.5 הינו 693.\nכלומר, כל נקודה שנמצאת מחוץ לתחום של [3950+693, 3488-693] תיחשב כערך חריג ותסומן כנקודה.\n\nextreme_hinges &lt;- c(3488-693, 3950+693)\nextreme_hinges\n\n[1] 2795 4643\n\npenguins %&gt;% \n  filter(species == \"Chinstrap\") %&gt;% \n  filter(body_mass_g &lt; extreme_hinges[1] | body_mass_g &gt; extreme_hinges[2])\n\n# A tibble: 2 × 8\n  species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Chinstrap Dream            52            20.7               210        4800\n2 Chinstrap Dream            46.9          16.6               192        2700\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\n4.5.2 צפיפות\nתרשים נוסף שיכול לסייע בהבנת צורת ההתפלגות הינו תרשים שמציג את הצפיפות (תזכורת: פונקצית צפיפות הינה הפונקציה שהשטח שמתחת לה מהווה את פונקצית ההתפלגות. לגובה של פונקצית צפיפות אין משמעות בערך בפני עצמו, אלא רק בכך שסך האינטגרל מתחת לפונקצית הצפיפות שווה 1). הצפיפות יכולה להראות לנו האם ההתפלגות סימטרית, האם היא בעלת מודל אחד (פיק יחיד כמו בהתפלגות נורמלית) או בי-מודלית (שני פיקים, כמו בהרכבה של שתי התפלגויות נורמליות), וכן היא יכולה לסייע לנו להבין האם יש התפלגות אחרת שמתאימה לתיאור הנתונים. הפקודה שמייצרת גרף צפיפות היא geom_density.\n\npenguins %&gt;% \n  ggplot(aes(x = body_mass_g, color = species)) + \n  geom_density() + \n  ggtitle(\"Penguin weight: density functions\") + \n  xlab(\"Body mass [grams]\") + \n  ylab(\"Density\")\n\nWarning: Removed 2 rows containing non-finite values (`stat_density()`).\n\n\n\n\n\n\n\n\n\n\n\nכמה הבדלים בולטים מהתרשים:\n\nניתן לראות שהשונות (הפיזור) במשקל הגוף גדול יותר בסוג Gentoo, וגם ב-Adelie קצת יותר מב-Chinstrap.\nניתן לראות שב-Gentoo יש התפלגות בי-מודלית (שתי גבעות).\nניתן לראות ששני הזנים Adelie ו-Chinstrap בעלי התפלגות סביב אותו משקל גוף.\n\n\n\n\n\n\n\nTip\n\n\n\nנסו לשער מה מקור ההתפלגות הבי-מודלית בפינגויינים מזן Gentoo. בדקו את השערתכם עם תרשימים מתאימים.\nרמז - נסו לבחון האם פיצול ה-Gentoo לפי משתנה נוסף מייצג שני גרפים בעלי דמיון רב יותר להתפלגות נורמלית (סימטרית ובעלת פיק יחיד).\n\n\n\n\n4.5.3 היסטוגרמה\nהיסטוגרמה הוא גרף נוסף שנועד להציג התפלגות של משתנים רציפים, על ידי שבירה של הערכים הרציפים לערכים בדידים (קבוצות טווחים), בשונה מהגרפים הקודמים.\nבנייה של היסטגרמה תתבצע באמצעות הפונקציה geom_histogram.\n\npenguins %&gt;% \n  ggplot(aes(x = body_mass_g, fill = species)) + \n  geom_histogram() + \n  ggtitle(\"Penguin weight: histogram\") + \n  xlab(\"Body mass [grams]\") + \n  ylab(\"Counts [# observations]\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\nניתן לשלוט במספר העמודות (ה-bins) על ידי הגדרה של הארגומנט bins= בתוך הפונקציה geom_histogram. הערך ברירת המחדל הינו 30 בינים.\n\n\n4.5.4 בארים\nבארים הם גרף עמודות. יש שתי גיאומטריות שמסייעות לנו בגרף עמודות: geom_bar ו-geom_col. ההבדל המרכזי ביניהן הוא ש-geom_bar מקבלת דאטה גולמי וסופרת, בעוד ש-geom_col מקבלת מוצר סופי. נמחיש זאת בדוגמה שמתארת את מספר התצפיות מכל סוג:\n\npenguins %&gt;% \n  ggplot(aes(species)) + \n  geom_bar() + \n  ggtitle(\"Number of penguins of eash species (geom_bar)\")\n\n\n\n\n\n\n\n\n\npenguins %&gt;% \n  count(species) %&gt;% \n  ggplot(aes(x = species, y = n)) + \n  geom_col() + \n  ggtitle(\"Number of penguins of eash species (geom_col)\")\n\n\n\n\n\n\n\n\n\n\nשתי הפקודות עם אותו הפלט בדיוק. אני באופן אישי מעדיף את השימוש ב-geom_col משום שיותר קל לעשות לה debug (בכך שנראה מה הדאטה שנכנס פנימה).\nגרף בארים יכול להציג גם יותר ממשתנה אחד, לדוגמה אפשר להשתמש בו על מנת להציג את ההתפלגות של משתנה מסוים כפונקציה של משתנים אחר (קשר בין שני משתנים בדידים). נדגים זאת בתרשים הבא שיציג את התפלגות הדגימות של זנים שונים כפונקציה של מגדר.\n\npenguins %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  count(species, sex) %&gt;% \n  ggplot(aes(x = sex, fill = species, y = n)) + \n  geom_col(position = position_fill()) + \n  ggtitle(\"Distribution of species for each gender\") + \n  scale_y_continuous(labels = scales::percent) + \n  ylab(\"Proportion [%]\") + \n  xlab(\"Sex\")\n\n\n\n\n\n\n\n\n\n\nניתן לראות מהתרשים שהתפלגות הדגימה של הזנים דומה בין שני המגדרים תמהיל של כ-20% מסוג Chinstrap, 36% מסוג Gentoo, והיתר ממין Adelie.\nהפונקציה position_fill מגדירה שיש לערום את הבארים אחד על השני כך שיסתכמו ל-100%, ישנן שתי אפשרויות נוספות: position_dodge, ו-position_stack.\n\n\n\n\n\n\nTip\n\n\n\nנסו להחליף את הפונקציה position_fill בפונקציות האחרות (position_dodge, position_stack). באילו מקרים תשמשו בכל אחת מהפונקציות הללו?\n\n\n\n\n\n\n\n\nTip\n\n\n\nצרו תרשים הפוך שבו מוצגת התפלגות המין של הפנגויינים לפי הזן (להפוך את התפקידים של ציר ה-x והמילוי של העמודות).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>ויז'ואליזציות</span>"
    ]
  },
  {
    "objectID": "04-visualizations-ggplot2.html#בחירת-התרשים",
    "href": "04-visualizations-ggplot2.html#בחירת-התרשים",
    "title": "4  ויז’ואליזציות",
    "section": "4.6 בחירת התרשים",
    "text": "4.6 בחירת התרשים\nעל מנת לייצר תרשים טוב, עליכם לענות על השאלות הבאות:\n\nכמה משתנים אנחנו רוצים לתאר בתרשים (האם אנחנו רוצים לתאר התפלגות של משתנה אחד, קשר בין שני משתנים, או אולי קשר בין שלושה משתנים)?\nמהם סוגי המשתנים שאנחנו מתארים (בדידים או רציפים)?\nאילו גיאומטריות יכולות לשמש אותנו לתיאור זה, ואיזה משתנה ימופה לאן (לאיזו אסטטיקה)?\n\nהחלקים 1-2 נובעים מהבנה טובה של הדאטה, והצורך המחקרי/העסקי שלכם. בשביל חלק 3 תוכלו להיעזר ב-Cheatsheet שהכינו בחברת Posit (לשעבר RStudio). הוא מאפשר להבין לכל סיטואציה איזה סוג תרשים ידרש: קישור ל-Cheatsheet.\nעברנו את התהליך הזה בדוגמאות שכבר ראינו בפרק זה, מבלי לציין זאת:\n\nב-Boxplot תיארנו קשר בין שני משתנים: המסה של הפינגויין (משתנה רציף) כתלות בזן של הפינגויין (משתנה בדיד), ולשם כך השתמשנו ב-geom_boxplot.\nגם בצפיפות וגם בהיסטוגרמה תיארנו קשר זה של משתנה רציף למשתנה בדיד (רק צורת הצגה שונה- geom_density או geom_histogram בהתאמה).\n\nכל אחת מהדוגמאות הנ”ל יכלו לשמש אותנו גם על מנת לתאר התפלגות של משתנה רציף יחיד, וגם על מנת לתאר קשר בין משתנה בדיד לבין משתנה רציף.\n\nבתרשימי הבארים השתמשנו על מנת לתאר התפלגות של משתנה בדיד יחיד (כגון זני הפינגויינים במדגם), או קשר בין התפלגויות של שני משתנים בדידים (מין הפינגויין למול זן הפינגויין).\n\n\n\n\n\n\n\nדוגמה למתקדמים\n\n\n\nנדגים דוגמה נוספת, הפעם כזו שמתארת קשר בין ארבעה משתנים. הקשר בין אורך המקור, עומק המקור, ומשקל של הפינגויין. מכיוון שלמדנו שישנו הבדל בין זנים שונים, אז גם נבצע אבחנה בין הזנים.\n\nיש לנו שלושה משתנים רציפים (אורך, עומק, ומשקל)\nיש לנו משתנה בדיד (זן)\nמהסתכלות ב-Cheatsheet (פינה ימנית תחתונה בעמוד הראשון) נראה שישנן מספר גיאומטריות מתאימות geom_contour, geom_countour_filled, geom_raster, geom_tile.\n\nהמשתנה התלוי שלנו הוא המשקל, ואנחנו רוצים לחקור איך הוא מושפע ממימדי המקור. לכן נמפה את אורך ועומק המקור לצירים x ו-y, ואת המשקל לצבע. באמצעות facet_wrap נייצר שלושה תתי-תרשימים (אחר לכל זן פינגויין).\n\npenguins %&gt;% \n  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, fill = body_mass_g)) + \n  geom_raster() +\n  facet_wrap(~species) +\n  ggtitle(\"Bad example for geom_raster (due to low density)\")\n\n\n\n\n\n\n\n\n\n\nכפי שניתן לראות יש לנו בעיית רזולוציה, מכיוון שיש יחסית מעט תצפיות, כל פינגויין מסומן כמלבן עם המשקל שלו מסומן כצבע. התרשים לא מאוד אינפורמטיבי, ולא כל כך תורם להבנה. יש לגיאומטריה של geom_raster ארגומנט שנקרא interpolate, שאמור לעשות אינטרפולציה בין נקודות, אבל גם אם נפעיל אותו נקבל גרף מטושטש ולא ברור (הנקודות רחוקות מדי אחת מהשניה).\nבמקרה זה, אפשר לבנות לנו “אינטרפולציה משלנו”. נתאים מודל (נשתמש במודל רגרסיה לינארית פשוטה), של אורך מקור, עומק מקור, וזן הפינגויין.\n\npenguins_model &lt;- lm(body_mass_g ~ bill_length_mm + bill_depth_mm + species, \n                     data = penguins)\n\npenguin_ranges &lt;- penguins %&gt;% \n  group_by(species) %&gt;% \n  summarize(across(c(bill_length_mm, bill_depth_mm), \n                   list(min = ~min(., na.rm = T),\n                        max = ~max(., na.rm = T))))\n\nהטבלה הבאה מציגה את טווחי אורך המקור, עומק המקור, ומשקל, עבור כל אחד מזני הפינגויינים.\n\n\ngt::gt(penguin_ranges)\n\n\n\n\n\n\n\nspecies\nbill_length_mm_min\nbill_length_mm_max\nbill_depth_mm_min\nbill_depth_mm_max\n\n\n\n\nAdelie\n32.1\n46.0\n15.5\n21.5\n\n\nChinstrap\n40.9\n58.0\n16.4\n20.8\n\n\nGentoo\n40.9\n59.6\n13.1\n17.3\n\n\n\n\n\n\n\n\nנשתמש בנתוני הטבלה כדי לבנות טבלה חדשה שבה נמצאים כל הערכים האפשריים, וחיזוי שלהם על בסיס מודל הרגרסיה הלוגיסטית שבנינו.\n\nstep &lt;- 0.5\npenguin_grid &lt;- \n  expand_grid(length = seq(32.1, 46, step),\n              depth = seq(15.5, 21.5, step),\n              species = \"Adelie\") %&gt;% \n  bind_rows(\n    expand_grid(length = seq(40.9, 58, step),\n                depth = seq(16.4, 20.8, step),\n                species = \"Chinstrap\"),\n    expand_grid(length = seq(40.9, 59.6, step),\n                depth = seq(13.1, 17.3, step),\n                species = \"Gentoo\")\n  ) %&gt;% \n  rename(bill_length_mm = length,\n         bill_depth_mm = depth)\n\npenguin_grid$body_mass_g &lt;- predict(penguins_model, newdata = penguin_grid)\n\npenguin_grid %&gt;% \n  ggplot(aes(x = bill_length_mm, y = bill_depth_mm, fill = body_mass_g)) + \n  geom_raster(interpolate = TRUE) + \n  scale_fill_viridis_c() + \n  facet_wrap(~species) + \n  ggtitle(\"Bill length, depth, and mass for various species\", subtitle = \"Based on a linear regression model\")\n\nWarning: Raster pixels are placed at uneven horizontal intervals and will be shifted\nℹ Consider using `geom_tile()` instead.\nRaster pixels are placed at uneven horizontal intervals and will be shifted\nℹ Consider using `geom_tile()` instead.\n\n\n\n\n\n\n\n\n\n\n\nכעת ניתן להצמיד פרשנות למודל על ידי עיון בגרף. נראה שסוג הפינגויין משפיע ביותר על המשקל: ל-Gentoo המשקל הגבוה ביותר, המתקבל כאשר האורך והעומק של המקור עולים (בפינה הימנית העליונה של התרשים הימני). פרטים של פינגויינים מזן ה-Chinstrap יכולים להיות בעלי מימדי מקור דומים, אך עדיין לא מגיעים לאותו המשקל כפי שנצפה ב-Gentoo.\nבכל המקרים עלייה במימדי המקור (עומק ואורך) מצביעה על עלייה במשקל (בגלל זה לפינה העליונה הימנית בכל אחד מתתי התרשימים נצבעת בצבע יותר בהיר).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>ויז'ואליזציות</span>"
    ]
  },
  {
    "objectID": "04-visualizations-ggplot2.html#סיכום",
    "href": "04-visualizations-ggplot2.html#סיכום",
    "title": "4  ויז’ואליזציות",
    "section": "4.7 סיכום",
    "text": "4.7 סיכום\nבפרק זה למדנו להפיק תרשימים באמצעות חבילת ggplot2. דנו בייחודיות של החבילה בהיבט התיאוריה שמבססת אותה (the grammar of graphics), והבנו כיצד יש לתכנן תרשים (באמצעות מיפויים, גיאומטריות, והגדרות נוספות).\nראינו דוגמאות לגיאומטריות מסוימות כגון boxplot, היסטוגרמה, צפיפויות, וגרף בארים.\nלבסוף ראינו כיצד ניתן לתכנן תרשים באמצעות בחינה של סוגי המשתנים והקשרים שאנחנו רוצים לזהות, וראינו דוגמה לתרשים אשר קושר בין ארבעה משתנים שונים, ומבוסס על מודל של רגרסיה לינארית.\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד\n\n\n\n\n\nMurray, Lori L., and John G. Wilson. 2021. “Generating Data Sets for Teaching the Importance of Regression Analysis.” Decision Sciences Journal of Innovative Education 19 (2): 157–66. https://doi.org/10.1111/dsji.12233.\n\n\nSimpson, E. H. 1951. “The Interpretation of Interaction in Contingency Tables.” Journal of the Royal Statistical Society: Series B (Methodological) 13 (2): 238–41. https://doi.org/10.1111/j.2517-6161.1951.tb00088.x.\n\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics 19 (1): 3–28. https://doi.org/10.1198/jcgs.2009.07098.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>ויז'ואליזציות</span>"
    ]
  },
  {
    "objectID": "05-pivot-and-join.html#מבנה-רחבארוך",
    "href": "05-pivot-and-join.html#מבנה-רחבארוך",
    "title": "5  מבנה וחיבור נתונים",
    "section": "5.1 מבנה רחב/ארוך",
    "text": "5.1 מבנה רחב/ארוך\nאחת מהפעולות השימושיות היא העברה של דאטה בין פורמט ארוך לפורמט רחב. לדוגמה כשרוצים שמשתנים מסוימים יהפכו לתצפיות נוספות, או להיפך. נדגים זאת עם הנתונים של penguins, שראינו בפרקים הקודמים. נוסיף שינוי קטן לקובץ שמזהה כל תצפית באמצעות מזהה penguin_id לשם כך אנו משתמשים בפונקציה seq_along שפשוט נותנת וקטור של מספר רץ בהתאם לתצפיות.\n\n5.1.1 רחב לארוך\nהמבנה הסטנדרטי של הקובץ הוא מבנה רחב - כל פינגויין מופיע בשורה אחת עם כל המשתנים שלו. נניח שאנחנו רוצים להפוך את המבנה לארוך, ושכל פינגויין יופיע מספר פעמים בטבלה, בהתאם לסוג המידע המדווח עליו. לצורך זה נשתמש ב-pivot_longer. הנה תזכורת על המבנה הקיים, והקוד שהופך את המבנה למבנה ארוך:\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\npenguins_w_id &lt;- penguins %&gt;% \n  mutate(penguin_id = seq_along(species))\n\npenguins_w_id\n\n# A tibble: 344 × 9\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 3 more variables: sex &lt;fct&gt;, year &lt;int&gt;, penguin_id &lt;int&gt;\n\nlonger_penguins &lt;- penguins_w_id %&gt;% \n  select(penguin_id, species, contains(\"_mm\")) %&gt;% \n  pivot_longer(cols = -c(species, penguin_id),\n               names_to = \"measurement_type\",\n               values_to = \"measurement_value\")\n\nlonger_penguins\n\n# A tibble: 1,032 × 4\n   penguin_id species measurement_type  measurement_value\n        &lt;int&gt; &lt;fct&gt;   &lt;chr&gt;                         &lt;dbl&gt;\n 1          1 Adelie  bill_length_mm                 39.1\n 2          1 Adelie  bill_depth_mm                  18.7\n 3          1 Adelie  flipper_length_mm             181  \n 4          2 Adelie  bill_length_mm                 39.5\n 5          2 Adelie  bill_depth_mm                  17.4\n 6          2 Adelie  flipper_length_mm             186  \n 7          3 Adelie  bill_length_mm                 40.3\n 8          3 Adelie  bill_depth_mm                  18  \n 9          3 Adelie  flipper_length_mm             195  \n10          4 Adelie  bill_length_mm                 NA  \n# ℹ 1,022 more rows\n\n\nהארגומנט הראשון קובע את המשתנים שהולכים לעבור “pivot”. במקרה הזה הגדרנו אותו על דרך השלילה (-species אומר שכל המשתנים צריכים להשתתף ב-pivot למעט המשתנה species שנותר כעמודה מופרדת).\nהארגומנט names_to קובע את שם העמודה שתכיל את שמות המשתנים במקור, והארגומנט values_to קובע את שם העמודה שתכיל את הערכים שהכילו המשתנים במקור.\n\n\n5.1.2 ארוך לרחב\nהפעולה ההפוכה (הפיכת טבלה ארוכה לטבלה רחבה) יכולה להיעשות באמצעות הפונקציה pivot_wider, באופן הבא:\n\nlonger_penguins %&gt;% \n  pivot_wider(id_cols = c(species, penguin_id),\n              names_from = measurement_type,\n              values_from = measurement_value)\n\n# A tibble: 344 × 5\n   species penguin_id bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;fct&gt;        &lt;int&gt;          &lt;dbl&gt;         &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie           1           39.1          18.7               181\n 2 Adelie           2           39.5          17.4               186\n 3 Adelie           3           40.3          18                 195\n 4 Adelie           4           NA            NA                  NA\n 5 Adelie           5           36.7          19.3               193\n 6 Adelie           6           39.3          20.6               190\n 7 Adelie           7           38.9          17.8               181\n 8 Adelie           8           39.2          19.6               195\n 9 Adelie           9           34.1          18.1               193\n10 Adelie          10           42            20.2               190\n# ℹ 334 more rows\n\n\nהתחביר של הפקודה מאוד דומה לתחביר של הפקודה הקודמת. שימו לב שבמקרה זה אפשר להגדיר את שמות המשתנים ללא מרכאות, משום שאלו משתנים קיימים ב-longer_penguins והפקודה יודעת לבחור אותם גם ללא ציון שלהם במרכאות.\n\n\n\n\n\n\nTip\n\n\n\nנסו להריץ את אותן הפקודות (pivot_longer ואז pivot_wider) על penguins (במקום על penguins_id).\nמה שונה בפלט של כל אחת מהפקודות, ומדוע?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>מבנה וחיבור נתונים</span>"
    ]
  },
  {
    "objectID": "05-pivot-and-join.html#חיבור-טבלאות",
    "href": "05-pivot-and-join.html#חיבור-טבלאות",
    "title": "5  מבנה וחיבור נתונים",
    "section": "5.2 חיבור טבלאות",
    "text": "5.2 חיבור טבלאות\nלעיתים בעבודה עם נתונים נדרש חיבור של נתונים ממקורות שונים (או מאותו מקור המאוחסן בטבלאות שונות). זה מאוד מקובל בעבודה עם דאטהבייס. לדוגמה (בהפשטה) חשבו על חברת אשראי שמצד אחד מאחסנת נתונים על לקוחות (גיל, מגדר, כתובת), ומצד שני מאחסנת נתונים של טראנזקציות (פעולות, קרי, חיובי אשראי. שדות כגון מיקום החיוב וסכום החיוב).\nאין סיבה שהטבלה שמאחסנת נתונים של טראנזקציות תכיל גם נתונים של גיל, מגדר, וכתובת, משום שאלו לרוב לא משתנים בין חיוב לחיוב.\nאבל יש מקרים שבהם נרצה לחבר בין הנתונים כדי לנתח אותם ביחד. לדוגמה בשביל לחשב מה ממוצע ההוצאה של גברים לעומת נשים. זה דורש חיבור של טבלת הנתונים על לקוחות עם טבלת הטראנזקציות.\nנדגים זאת בדוגמה קטנה שבה שתי טבלאות. בטבלה הראשונה נתונים על ארבעה לקוחות פיקטיביים של חברת אשראי. אנחנו נשתמש בפקודה tribble כדי להגדיר את הטבלה בקוד.\n\ncustomers &lt;- tribble(~customer_id, ~gender, ~home_address,\n                     1, \"גבר\", \"חיפה\",\n                     2, \"אשה\", \"תל-אביב\",\n                     3, \"גבר\", \"תל-אביב\",\n                     4, \"אשה\", \"חיפה\")\n\ncustomers\n\n# A tibble: 4 × 3\n  customer_id gender home_address\n        &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;       \n1           1 גבר    חיפה        \n2           2 אשה    תל-אביב     \n3           3 גבר    תל-אביב     \n4           4 אשה    חיפה        \n\n\nכעת נגדיר טבלה נוספת של הרכישות שביצעו הלקוחות:\n\ntransactions &lt;- tribble(~customer_id, ~expense, ~dealer,    \n                        1, 80, \"Motty's Shawarma\", \n                        1, 12, \"Marina's coffee\",\n                        2, 350, \"Dekek fuel\",\n                        4, 35, \"Train\",\n                        4, 12, \"Rokadin's Crossons\")\n\nניתן לראות שיש לקוחות שביצעו שתי עסקאות, יש לקוחות שביצעו עסקה אחת, ויש לקוחות שלא ביצעו עסקאות בכלל. אנחנו רוצים לחשב כמה כסף בסך הכל הוציאו לקוחות שמתגוררים בחיפה לעומת לקוחות שמתגוררים בתל-אביב.\nנשתמש בפקודה left_join שמחברת בין טבלאות. המשתנה המשותף הוא customer_id והוא יאפשר לנו לחבר בין הטבלאות.\n\ncustomers_transactions &lt;- transactions %&gt;%    \n  left_join(customers)\n\nJoining with `by = join_by(customer_id)`\n\ncustomers_transactions\n\n# A tibble: 5 × 5\n  customer_id expense dealer             gender home_address\n        &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;              &lt;chr&gt;  &lt;chr&gt;       \n1           1      80 Motty's Shawarma   גבר    חיפה        \n2           1      12 Marina's coffee    גבר    חיפה        \n3           2     350 Dekek fuel         אשה    תל-אביב     \n4           4      35 Train              אשה    חיפה        \n5           4      12 Rokadin's Crossons אשה    חיפה        \n\n\nהטבלה המאוחדת מציגה עבור כל עסקה מה המגדר של הלקוח ואיפה גר (בשתי העמודות האחרונות). כעת נוכל להשתמש בפקודות שלמדנו בפרק זה לפעולות לפי קיבוצים:\n\ncustomers_transactions %&gt;%    \n  group_by(home_address) %&gt;%    \n  summarize(total_expense = sum(expense))\n\n# A tibble: 2 × 2\n  home_address total_expense\n  &lt;chr&gt;                &lt;dbl&gt;\n1 חיפה                   139\n2 תל-אביב                350\n\n\nמעבר לפקודה שבה השתמשנו left_join יש עוד פקודות חיבור. הפקודה right_join עושה את אותו הדבר רק במקום לחבר את הטבלה השניה לראשונה היא מחברת את הראשונה לשניה:\n\ncustomers %&gt;%    \n  right_join(transactions)\n\nJoining with `by = join_by(customer_id)`\n\n\n# A tibble: 5 × 5\n  customer_id gender home_address expense dealer            \n        &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;             \n1           1 גבר    חיפה              80 Motty's Shawarma  \n2           1 גבר    חיפה              12 Marina's coffee   \n3           2 אשה    תל-אביב          350 Dekek fuel        \n4           4 אשה    חיפה              35 Train             \n5           4 אשה    חיפה              12 Rokadin's Crossons\n\n\nהפקודה full_join תשמר ערכים שאין להם התאמה באחת הטבלאות. לדוגמה לקוח מספר 3 (והם יופיעו עם ערך חסר):\n\ncustomers %&gt;%    \n  full_join(transactions)\n\nJoining with `by = join_by(customer_id)`\n\n\n# A tibble: 6 × 5\n  customer_id gender home_address expense dealer            \n        &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;             \n1           1 גבר    חיפה              80 Motty's Shawarma  \n2           1 גבר    חיפה              12 Marina's coffee   \n3           2 אשה    תל-אביב          350 Dekek fuel        \n4           3 גבר    תל-אביב           NA &lt;NA&gt;              \n5           4 אשה    חיפה              35 Train             \n6           4 אשה    חיפה              12 Rokadin's Crossons\n\n\nשימו לב, הפקודות הללו מזהות לבד מהם המשתנים החופפים ומחברות בהתאם. ניתן גם להגדיר חפיפות אם שמות המשתנים אינם זהים בין שתי הטבלאות, על ידי שימוש בארגומנט by.\n\n\n\n\n\n\nNote\n\n\n\nלגבי שיבושי עברית/אנגלית בקוד ובפלט… 😮‍💨\nבהתייחס לטבלת ה-customers שבה הגדרנו ערכי שדות בעברית: שימו לב שהשדה gender הוגדר לפני השדה home_address אבל מכיוון שאנחנו משתמשים בעברית בהמשך שורות הקוד, זה נראה “כאילו” התוכן של מגדר מופיע אחרי התוכן של עיר (הפוך).\nכמו כן גם הטקסט עצמו בעברית בפלט משתבש.\nזה בגלל עניין היישור של הקוד משמאל לימין. זו בעיה נפוצה, כשמערבים עברית ואנגלית בקוד, ולוקח זמן להתרגל אליה. תתחילו להתאמן.\nעוד על עברית ב-R תוכלו למצוא בפרק 10.\n\n\n\n5.2.1 סינון מטבלה באמצעות join\nניתן להשתמש בפקודות anti_join ו-semi_join על מנת לסנן שורות. למעשה פקודות אלו אינן מחברות נתונים, אלא רק מסננות שורות.\nלדוגמה, הקוד הבא משתמש ב-anti_join בשביל לחלץ את הלקוחות שאינם מופיעים בטבלת הפעולות:\n\ncustomers %&gt;%      \n  anti_join(transactions)\n\nJoining with `by = join_by(customer_id)`\n\n\n# A tibble: 1 × 3\n  customer_id gender home_address\n        &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;       \n1           3 גבר    תל-אביב     \n\n\nלא התווספו שדות לטבלת הלקוחות. קיבלנו רק את לקוח 3 שלא הופיעו עבורו פעולות.\n\n\n\n\n\n\nתרגיל: semi_join לעומת anti_join\n\n\n\nהשתמשו בפקודה semi_join במקום anti_join. מה עושה הפקודה?\n\n\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>מבנה וחיבור נתונים</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#מבחן-השערות-על-תוחלת",
    "href": "06-hypothesis-tests.html#מבחן-השערות-על-תוחלת",
    "title": "6  מבחני השערות",
    "section": "6.1 מבחן השערות על תוחלת",
    "text": "6.1 מבחן השערות על תוחלת\nאחד מהפרמטרים החשובים של התפלגויות הוא התוחלת. לתוחלת ולממוצע יש קשר הדוק ביניהם - כאשר אנחנו מבצעים דגימה מתוך אוכלוסיה, ממוצע המדגם הוא אמד המייצג את התוחלת.\nנדגים זאת בעזרת מדגם הפינגויינים שראינו בפרק הקודם:\nלכל אחד מזני הפינגויינים ממוצע שונה לאורך המקור. לדוגמה, פינגויינים מסוג Adelie הם בעלי מקור באורך ממוצע 38.8 מ”מ. בפועל מדובר בממוצע המחושב על מדגם של 151 תצפיות, וסביר להניח שהתוחלת בכלל אוכלוסית הפינגויים מזן Adelie היא קצת שונה. לדוגמה, תוחלת של 38 מ”מ, יכולה להביא לכך שממוצע על פני דגימה של 151 תצפיות יהיה 38.8 מ”מ.\nהמטרה של מבחן השערות על התוחלת היא לעזור לנו לקבוע ברמת שגיאה של \\(\\alpha\\) (אשר בדרך כלל נקבעת כ-5% שגיאה), האם התוחלת היא בעלת ערך מסוים \\(\\mu_0\\), בהינתן תוצאות המדגם שלנו.\nצורת הסתכלות אחרת היא בניית רווח בר סמך לתוחלת, או במילים אחרות, מה הטווח הסביר שבו נמצאת התוחלת בהינתן תוצאות המדגם.\nבשלב זה נתייחס למדגם אחד, ולאחר מכן נכליל את ההסתכלות לשני מדגמים.\nהתרשים הבא מציג את התפלגות אורך המקור של פינגויינים מזן Adelie באמצעות היסטוגרמה.\nעל ההיסטוגרמה הלבשנו שני קווים אנכיים: הממוצע בפועל בירוק (38.3913), והערך שאותו נבחן כתוחלת (38) באמצעות מבחן השערות.\n\nadelie &lt;- penguins %&gt;% \n  filter(species == \"Adelie\") %&gt;% \n  filter(!is.na(bill_length_mm))\n\nggplot(adelie, aes(x = bill_length_mm)) + \n  geom_histogram(bins = 15) + \n  geom_vline(xintercept = 38, color = \"#E41A1C\", linewidth = 1, linetype = 2) + \n  geom_vline(xintercept = mean(adelie$bill_length_mm), color = \"#4DAF4A\", linewidth = 1) + \n  ggtitle(\"Distribution of Adelie bill length\")\n\n\n\n\n\n\n\n\n\n\nנשתמש בפקודת t.test על מנת לייצר רווח בר סמך (או מבחן השערות) לתוחלת אורך המקור של פינגויינים מזן Adelie.\nנבנה את רווח בר הסמך ברמת ביטחון של 95% (כלומר רמת הוודאות של הדיווח שנקבל היא 95%, או 5% שגיאה). כמו כן, נבחן האם ייתכן שהתוחלת הינה 38, למרות שהתצפיות במדגם בעלות ממוצע של 38.8.\n\nadeliettest &lt;- t.test(adelie$bill_length_mm, \n       alternative = \"two.sided\",\n       mu = 38, conf.level = 0.95)\n\nadeliettest\n\n\n    One Sample t-test\n\ndata:  adelie$bill_length_mm\nt = 3.6513, df = 150, p-value = 0.0003598\nalternative hypothesis: true mean is not equal to 38\n95 percent confidence interval:\n 38.36312 39.21966\nsample estimates:\nmean of x \n 38.79139 \n\n\nפרשנות תוצאות המבחן: אנו דוחים את השערת ה-0 שהתוחלת הינה 38. להלן הסבר מפורט לפלט:\n\nבראש הפלט מופיע סוג המבחן שהופעל (One Sample t-test), כלומר מבחן t עבור מדגם יחיד (יש גם מבחנים עבור שני מדגמים מזווגים, ושני מדגמים לא-מזווגים, מיד נדגים).\nבשורה השניה מופיע הדאטה שבו השתמשנו.\nבשורה השלישית ההשערה האלטרנטיבית שנבחנה (המכונה \\(H_1\\) . במקרה זה הגדרנו בארגומנט alternative מבחן השערה דו-צדדי, כלומר: \\(H_1: \\mu\\neq38\\).\nבשורה הרביעית ערך \\(T\\) של המבחן (המכונה גם סטטיסטי המבחן), במקרה זה ערכו הוא 3.6513, ובנוסף מספר דרגות החופש (df), וערך המובהקות (p-value). ערך p-value במקרה זה הינו מתחת ל-0.05 מה שמעיד על כך שעלינו לדחות את השערת ה-0 (\\(H_0: \\mu=38\\)).\nבשורה הבאה (ובזו שאחריה) מופיע הרווח בר סמך לתוחלת. במקרה זה הרווח בר סמך ברמת בטחון של 95% מעיד על כך שתוחלת אורך המקור של הפינגויין מהזן הנבחן נמצאת בין 38.36 לבין 39.22. ניתן לשים לב שהתוחלת אותה בחנו בהשערת ה-0 ($\\mu=38$) נמצאת מחוץ לטווח זה, וזה עולה בקנה אחד עם הדחיה שתיארנו בסעיף קודם בהתייחס לערך ה-p-value.\nלבסוף מופיע הממוצע עצמו של המשתנה (38.7914).\n\n\n\n\n\n\n\nמעבר ממבחן דו-צדדי למבחן חד-צדדי\n\n\n\nהיעזרו בתיעוד הפקודה t-test ושנו את הארגומנט alternative על מנת לבצע את המבחן הסטטיסטי:\n\\[\nH_0: \\mu=38\n\\]\n\\[\nH_1: \\mu&gt;38\n\\]\nמה תוצאת המבחן? מה המסקנה?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#שני-מדגמים-לא-מזווגים",
    "href": "06-hypothesis-tests.html#שני-מדגמים-לא-מזווגים",
    "title": "6  מבחני השערות",
    "section": "6.2 שני מדגמים לא-מזווגים",
    "text": "6.2 שני מדגמים לא-מזווגים\nכעת נפנה למבחן t-test שבו נשתמש כאשר ברצוננו להשוות בין שני מדגמים, לא מזווגים. לדוגמה על מנת לבחן האם ניתן לדחות את ההשערה שאורך המקור של פינגויינים מזן Chinstrap ואורך המקור של פינגויינים מזן Gentoo שווים (כפי שראינו ערכיהם דומים יחסית).\nראשית, נציג את ההתפלגות של שני הזנים בתרשים הבא:\n\nchin_gentoo &lt;- penguins %&gt;% \n  filter(!is.na(bill_length_mm)) %&gt;% \n  filter(species != \"Adelie\")\n\nggplot(chin_gentoo,\n       aes(x = bill_length_mm, color = species)) + \n  geom_density() + \n  ggtitle(\"Distribution of Chinstrap and Gentoo bill length\")\n\n\n\n\n\n\n\n\n\n\nהתרשים ממחיש לנו הבדלים בין התפלגות אורך המקור של שני הזנים (ובהמשך הפרק נראה איך בוחנים הבדלים בין שתי התפלגויות), אך כעת נרצה לבחון את ההבדלים בין ממוצעי אורך המקור של כל זן. נשתמש בפקודה t-test אך בצורת הפעלה מעט שונה מזו שבה השתמשנו במקרה של מדגם יחיד.\n\nchin_gentoo_ttest &lt;- t.test(formula = bill_length_mm ~ species,\n                            data = chin_gentoo)\nchin_gentoo_ttest\n\n\n    Welch Two Sample t-test\n\ndata:  bill_length_mm by species\nt = 2.706, df = 129.22, p-value = 0.00773\nalternative hypothesis: true difference in means between group Chinstrap and group Gentoo is not equal to 0\n95 percent confidence interval:\n 0.3572698 2.3006212\nsample estimates:\nmean in group Chinstrap    mean in group Gentoo \n               48.83382                47.50488 \n\n\nצורת ההפעלה שבה השתמשנו מגדירה נוסחה ודאטה. הנוסחה היא bill_length_mm ~ species, כלומר בחן את אורך המקור לפי המשתנה species (במקרה זה, חייבים שלמשתנה המסביר species יהיו בדיוק שתי רמות, אחרת נקבל שגיאה).\nקיבלנו דחיה של השערת ה-0, כלומר ניתן לדחות את ההשערה שתוחלת אורך המקור בין שני הזנים שווה. ברמת מובהקות של 0.00773.\nהרווח בר סמך מתייחס להפרש בין התוחלות, קרי, ברמת ביטחון של 95% ההפרש בין התוחלות נע בין 0.357 לבין 2.301 (לטובת Chinstrap שבעלי אורך מקור גדול יותר).\nהפקודה שהרצנו משתמשת במבחן המניח שונות שונה, ניתן לשנות זאת על ידי הוספת הארגומנט var.equal=TRUE.\n\nchin_gentoo_nonequal_var_ttest &lt;- t.test(formula = bill_length_mm ~ species,\n                                         data = chin_gentoo,\n                                         var.equal = TRUE)\nchin_gentoo_nonequal_var_ttest\n\n\n    Two Sample t-test\n\ndata:  bill_length_mm by species\nt = 2.7694, df = 189, p-value = 0.006176\nalternative hypothesis: true difference in means between group Chinstrap and group Gentoo is not equal to 0\n95 percent confidence interval:\n 0.3823625 2.2755285\nsample estimates:\nmean in group Chinstrap    mean in group Gentoo \n               48.83382                47.50488",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#שני-מדגמים-מזווגים",
    "href": "06-hypothesis-tests.html#שני-מדגמים-מזווגים",
    "title": "6  מבחני השערות",
    "section": "6.3 שני מדגמים מזווגים",
    "text": "6.3 שני מדגמים מזווגים\nנדגים כעת מבחן t-test שבו משתמשים כאשר יש לנו שני מדגמים אשר מזווגים ביניהם. מדגמים מזווגים הם מדגמים אשר לכל ערך במדגם הראשון ניתן לזווג ערך במדגם השני (באופן חד-חד ערכי). משום כך, מדגמים מזווגים תמיד יהיו שווים בגודלם. הדוגמה ה”קלאסית” למדגמים מזווגים הם מחקר שבו יש שלב של “לפני” ושלב של “אחרי”: הם מזווגים משום שניתן להצמיד אחרי-לפני עבור כל נדגם. במקרים בהם רוצים לבחון התערבות מסוימת אז אפשר להשוות את ההפרשים של אחרי-לפני ולראות האם ההפרשים שונים באופן מובהק מ-0 (ואז זה אומר שיש אפקט עם כיוון מסוים להתערבות).\nנמחיש זאת על ידי השוואה בין אורך המקור לעומק המקור (bill_length_mm, bill_depth_mm). מדובר בשני מדגמים, אך הם קשורים ביניהם (משום שכל תצפית של אורך קשורה לתצפית מסוימת של עומק).\nראשית נשתמש בתרשים על מנת להמחיש את ההתפלגויות של המשתנים:\n\npenguins %&gt;% \n  mutate(specimen = seq_along(species)) %&gt;% \n  select(specimen, bill_length_mm, bill_depth_mm) %&gt;% \n  pivot_longer(cols = -specimen, names_to = \"measurement_type\", values_to = \"mm\") %&gt;% \n  ggplot(aes(x = mm, color = measurement_type)) + \n  geom_density()\n\nWarning: Removed 4 rows containing non-finite values (`stat_density()`).\n\n\n\n\n\n\n\n\n\n\n\nכפי שניתן לראות, ההתפלגויות שונות מאוד (האורך ארוך משמעותי מן העומק), ולכן ניתן להעריך שגם מבחן המובהקות יגלה זאת.\nנשתמש שוב בפקודת t.test עם שינוי נוסף.\n\npaired_ttest &lt;- t.test(x = penguins$bill_length_mm,\n                       y = penguins$bill_depth_mm, \n                       paired = TRUE)\npaired_ttest\n\n\n    Paired t-test\n\ndata:  penguins$bill_length_mm and penguins$bill_depth_mm\nt = 79.505, df = 341, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 26.10846 27.43306\nsample estimates:\nmean of the differences \n               26.77076 \n\n\nהפלט מאוד דומה לפלטים שכבר ראינו (שימו לב שבכותרת Paired t-test המציין שמדובר במבחן מזווג), ובמקרה זה המבחן מובהק סטטיסטית.\nניתן לראות שההבדל בין אורך לעומק המקור עומד על 26.1 ועד 27.4 מ”מ, ברווח בר סמך של 95%.\n\n\n\n\n\n\nTip\n\n\n\nהיעזרו בפקודה t.test על מנת לבחון את ההשערה שההבדל בין אורך לעומק המקור עומד על 26.5 מ”מ.\nלשם כך השתמשו במבחן מזווג עם הארגומנט mu (מה צריך להיות ערכו של הארגומנט?).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#מבחן-לשיוויון-שונויות",
    "href": "06-hypothesis-tests.html#מבחן-לשיוויון-שונויות",
    "title": "6  מבחני השערות",
    "section": "6.4 מבחן לשיוויון שונויות",
    "text": "6.4 מבחן לשיוויון שונויות\nהשונות מתארת את פיזור התצפיות, והיא מעניינת ממגוון סיבות. בפרט, כפי שראינו בפקודת t.test לעיתים נרצה להגדיר לפקודה האם להניח שונויות שוות או שונות (וזה משפיע על המבחן, כלומר הנוסחאות, שהפקודה מבצעת). באפשרותנו להשתמש בפקודה var.test על מנת לבחון האם השונויות של שני מדגמים שוות (השערת האפס הינה שיוויון השונויות, וההשערה האלטרנטיבית היא שהשונויות אינן שוות).\nהמבחן שבו נשתמש בוחן את היחס בין השונויות, וכן הוא מניח ששתי השונויות הן של משתנים מקריים הלקוחים מהתפלגות נורמלית. המבחן נקרא מבחן F. נדגים את המבחן על השונות של אורך המקור של Gentoo לעומת אורך המקור של Chinstrap.\n\nchin_gentoo_vartest &lt;- var.test(formula = bill_length_mm ~ species,\n                                data = chin_gentoo)\nchin_gentoo_vartest\n\n\n    F test to compare two variances\n\ndata:  bill_length_mm by species\nF = 1.174, num df = 67, denom df = 122, p-value = 0.4411\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.778208 1.818704\nsample estimates:\nratio of variances \n          1.174017 \n\n\nשימו לב שאופן השימוש בפקודה מאוד דומה לאופן השימוש בפקודה t.test (ראו בחלק של מדגמים לא מזווגים). להלן הסבר על פלט הפקודה:\n\nהשורה הראשונה של הפלט מציינת שמדובר במבחן F.\nבשורה השלישית אנחנו רואים את נתוני המבחן (הסטטיסטי, דרגות חופש במונה ובמכנה, וכן את ה-p-value המחושב) כפי שניתן לראות p-value &gt; 0.05, ולכן לא ניתן לדחות את השערת האפס שהשונויות שוות בין שני המדגמים.\nבשורה הבאה ניתן לראות מה בחן המבחן (ההשערה האלטרנטיבית היא שהיחס בין השונויות שונה מ-1).\nלאחר מכן מופיע רווח בר סמך ליחס בין השונויות \\((0.778, 1.819)\\). ניתן לראות רווח בר הסמך כולל את הערך 1 (שקול לאי-דחיית השערת ה-0).\nבשורה האחרונה הפקודה מספקת לנו אמד ליחס בין השונויות (1.17).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#מבחן-חי-בריבוע-טיב-התאמה-אי-תלות",
    "href": "06-hypothesis-tests.html#מבחן-חי-בריבוע-טיב-התאמה-אי-תלות",
    "title": "6  מבחני השערות",
    "section": "6.5 מבחן חי-בריבוע (טיב התאמה, אי-תלות)",
    "text": "6.5 מבחן חי-בריבוע (טיב התאמה, אי-תלות)\nמבחן חי-בריבוע ($\\Chi^2$) יכול לשמש אותנו לשתי מטרות מרכזיות (שתיהן בוחנות את השונות):\n\nמבחן טיב התאמה\nמבחן אי-תלות\n\nכאמור, אין הכוונה להיכנס בספר זה לתיאוריה העומדת מאחורי המבחן, אך בבסיסה עומד העיקרון של פירוק המדגם לתאים סטטיסטיים, שבכל אחד “ספירה של תצפיות”. הסטטיסטי שמבוסס על ספירה זו של תצפיות הוא סכום של ריבועי משתנים מקריים, ולכן מתפלג חי-בריבוע.\n\n6.5.1 מבחן טיב התאמה\nבמבחן טיב התאמה אנחנו מנסים לראות האם התפלגות מסוימת הנצפית בנתונים האמפיריים תואמת להתפלגות אחרת תיאורתית. השערת האפס הינה שההתפלגות האמפירית לקוחה מתוך התפלגות תיאורתית ידועה, לעומת ההשערה האלטרנטיבית (שאינה לקוחה מהתפלגות זו). לכן מכונה המבחן טיב-התאמה (או באנגלית goodness-of-fit).\nנחזור לדוגמה על זן ה-Adelie ונבחן את ההשערה שהתפלגות אורך המקור לקוחה מהתפלגות נורמלית.\nנלביש את ההתפלגות הנצפית וההתפלגות התיאורתית (עם ממוצע וסטיית תקן לפי הממוצע וסטיית התקן הנאמדים מהנתונים).\n\nlength_mu &lt;- mean(adelie$bill_length_mm)\nlength_sd &lt;- sd(adelie$bill_length_mm)\n\ntheoretical_bill_length &lt;- tibble(x = seq(32, 46, 0.1)) %&gt;% \n  mutate(length_dens = dnorm(x = x,\n                             mean = length_mu,\n                             sd = length_sd))\n\nggplot(adelie, aes(x = bill_length_mm)) + \n  geom_density(color = \"blue\") +\n  geom_line(data = theoretical_bill_length, \n            inherit.aes = FALSE,\n            aes(x = x, y = length_dens), color = \"red\") +\n  ggtitle(\"Density of Adelie bill length with theoretical density\")\n\n\n\n\n\n\n\n\n\n\nהשלבים שבוצעו בקוד כללו ראשית בניית טבלה של צפיפות של ההתפלגות הנורמלית עם ממוצע 38.79, וסטיית תקן 2.66, הם האמדים מהנתונים האמפיריים של תוחלת וסטיית תקן אורך המקור של פינגויינים מזן Adelie. הפונקציה dnorm משמשת לחישוב הצפיפות הנורמלית.\nלאחר מכן השתמשנו בggplot, שאליו הוספנו שכבה נוספת של geom_line אשר לא משתמשת בדאטה הראשי (adelie) אלא בטבלה המשנית שחישבנו בשלב קודם (theoretical_bill_length). השתמשנו בארגומנטים data = theoretical_bill_length וב-inherit.aes = FALSE , על מנת להנחות את הפקודה של geom_line להשתמש בדאטה שונה, ובהגדרות אסטטיקה שונות.\nהתוצאה נראית כמו שני גרפי צפיפויות דומים אחד לשני, עם חריגה מסוימת (באדום הצפיפות התיאורתית ובכחול האמפירית). דומים, אבל לא זהים. האם הם “שונים מספיק” על מנת שנדחה את השערת האפס (שהם אותה ההתפלגות)?\nצעד אחד מקדים לפני שנבצע את מבחן טיב ההתאמה, הוא לבנות תרשים הנותן לנו כלי להשוות בין התפלגויות. תרשים מסוג Q-Q-Plot.\n\n6.5.1.1 תרשים Q-Q-Plot\nבתרשים מסוג Q-Q-Plot המחשב מציב אחוזונים של שתי התפלגויות כנקודות במרחב (התפלגות אחת בציר X והשניה בציר Y). אם הנקודות המוצגות מתלבשות על אלכסון הדבר מעיד על כך שהן מגיעות מאותן התפלגות. ככל שהנקודות מתרחקות מהאלכסון, הדבר מעיד על כך שההתפלגויות אינן זהות. התרשים מהווה כלי ויזואלי שיכול לתמוך את התיאור של מבחן טיב ההתאמה.\n\nadelie %&gt;% \n  ggplot(aes(sample = bill_length_mm)) + \n  geom_qq(distribution = stats::qnorm) + \n  stat_qq_line()\n\n\n\n\n\n\n\n\n\n\nבתרשים אנחנו יכולים לראות שמרבית הנקודות שבמרכז ההתפלגות פחות-או-יותר חופפות עם הקו שמוצג בתרשים, אך בקצוות (במיוחד בקצה התחתון) רואים שלהתפלגות האמפירית (המוצגת בציר y) יש ערכים מעט גבוהים מהמצופה ונשאלת השאלה האם חריגה זו מספיקה על מנת לדחות את ההשערה שאורך המקור מתפלג נורמלית (הנקודות שנמצאות מתחת ל-1- בציר ה-x נמצאות מעל הקו הישר המוצג בתרשים). כעת נפעיל מבחן סטטיסטי על מנת לבחון את טיב ההתאמה של ההתפלגות להתפלגות נורמלית עם הפרמטרים של תוחלת וסטיית תקן, כפי שמחושבים מהנתונים של אורך המקור.\n\n\n6.5.1.2 ביצוע מבחן טיב ההתאמה\nבמבחן טיב ההתאמה עלינו לחלק את ההתפלגות האמפירית לתאים סטטיסטיים (שבדרך כלל מקובל לסמן ב-$O_i$ מלשון Observed), ולהשוות למול תאים בהתפלגות התיאורתית (שמקובל לסמן באות \\(E_i\\) מלשון Expected). אחד התנאים לשימוש במבחן הוא שבכל תא סטטיסטי מספר התצפיות הצפוי יהיה לפחות 5 תצפיות.\n\ndistribution_breaks &lt;- c(0, 35, 37, 39, 41, 50)\n\nobserved_expected_counts &lt;- adelie %&gt;% \n  mutate(length_groups = cut(bill_length_mm, \n                             breaks = distribution_breaks)) %&gt;% \n  count(length_groups, name = \"observed\") %&gt;% \n  mutate(probability_upper = \n           pnorm(q = distribution_breaks[-1], mean = length_mu, sd = length_sd),\n         probability_lower = \n           pnorm(q = distribution_breaks[-6], mean = length_mu, sd = length_sd)\n  ) %&gt;% \n  mutate(expected_prob = (probability_upper - probability_lower)) %&gt;% \n  mutate(expected_counts = expected_prob * sum(observed))\n\nobserved_expected_counts\n\n# A tibble: 5 × 6\n  length_groups observed probability_upper probability_lower expected_prob\n  &lt;fct&gt;            &lt;int&gt;             &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;\n1 (0,35]              11            0.0773          2.36e-48        0.0773\n2 (35,37]             31            0.251           7.73e- 2        0.173 \n3 (37,39]             40            0.531           2.51e- 1        0.281 \n4 (39,41]             36            0.797           5.31e- 1        0.265 \n5 (41,50]             33            1.00            7.97e- 1        0.203 \n# ℹ 1 more variable: expected_counts &lt;dbl&gt;\n\ngoodness_of_fit_chisqtest &lt;- chisq.test(x = observed_expected_counts$observed,\n                                        p = observed_expected_counts$expected_prob,\n                                        rescale.p = TRUE)\ngoodness_of_fit_chisqtest\n\n\n    Chi-squared test for given probabilities\n\ndata:  observed_expected_counts$observed\nX-squared = 1.6432, df = 4, p-value = 0.801\n\n\nראשית נקבעו הגבולות של הקבוצות בהתפלגות (הדיסקרטיזציה, יצירת התפלגות בדידה), כך שההתפלגות תכיל את כל תוצאות ההתפלגות האפשריות מ-0 ועד 1.\nהחלק השני של הקוד מייצר את טבלת התצפיות בפועל ואת מספר התצפיות הצפוי (על ידי חישוב ההסתברות מתוך הממוצע וסטיית התקן של המדגם), והכפלה בסך התצפיות במדגם.\nלאחר מכן אנחנו משתמשים בפקודה chisq.test. שימו לב שלמעשה לא השתמשנו במספר התצפיות הצפוי אלא בהתפלגות שלהם (הארגומנט p), שמעיד מה ההסתברות לקבל דגימות בתאים הסטטיסטיים הנבחנים.\nבמקרה זה קיבלנו p.value=0.801 כלומר לא ניתן לדחות את השערת האפס שההתפלגות הנדונה היא התפלגות נורמלית (לכן נאמר שיש בסיס להתייחס להתפלגות כהתפלגות נורמלית).\n\n\n\n\n\n\nNote\n\n\n\nבמרבית ספרי הסטטיסטיקה תתיקלו בנוסחה הבאה עבור מבחן חי-בריבוע.\nראשית מחשבים את הסטטיסטי:\n\\[\nX=\\sum_{i=1}^l\\frac{\\left(O_i-E_i\\right)^2}{E_i}\n\\]\nכאשר \\(l\\) הוא מספר התאים הסטטיסטיים (בדוגמה הקודמת 5), ומספר דרגות החופש בהתפלגות יהיה \\(df=l-1\\).\nלאחר מכן מחשבים את ה-p-value לפי ערכו של הסטטיסטי:\n\\[\n\\Pr\\left(X&gt;\\chi^2_{df}\\right)\n\\]\nהפקודה שהרצנו למעשה מבצעת חישוב זה בדיוק. ניתן להדגים זאת על ידי ביצוע החישוב באופן ישיר.\n\nX &lt;- ((observed_expected_counts$observed - \n        observed_expected_counts$expected_counts)^2) / \n  observed_expected_counts$expected_counts\n\np.value &lt;- pchisq(q = sum(X), df = 4, \n                  lower.tail = F)\np.value\n\n[1] 0.8010082\n\n\n\n\n\n\n\n6.5.2 מבחן אי-תלות\nמבחן אי-תלות משמש אותנו על מנת להבחין האם שני משתנים מקריים כלשהם הם בעלי תלות מסוימת או לא, כאשר שניהם משתנים קטגוריאליים. נדגים את השימוש במבחן: בנתוני הפינגויינים שעמם אנחנו עובדים בדוגמאות ישנם מספר משתנים קטגוריאליים (זן, אי, מין, ושנת המדידה שחרף היותו מספרי ניתן להתייחס אליו גם כקטגוריה). נרצה לבחון באמצעות מבחן אי-תלות האם יש קשר בין זן הפינגויינים לבין שנת המדידה: כלומר האם החוקרים שאספו את הדאטה נתנו דגשים על איסוף נתונים של זנים מסוימים בשנים מסוימים או שעבדו באופן אחיד בדגימת פינגויינים מכל שלושת הזנים בכל שלושת השנים בדאטה (2007-2009). נתחיל ביצירת תרשים שיציג את התפלגות הזנים בכל שנת דגימה.\n\npenguins %&gt;% \n  count(year, species) %&gt;%\n  group_by(year) %&gt;% \n  mutate(prop = n/sum(n)) %&gt;% \n  ggplot(aes(x = factor(year), y = prop, fill = species)) + \n  geom_col(position = position_fill()) + \n  scale_y_continuous(labels = scales::percent) + \n  ylab(\"Sample distribution\") + xlab(\"\") +\n  ggtitle(\"Sample distribution of species over years\") +\n  geom_text(aes(label = glue::glue(\"{round(prop*100)}%\")),\n            position = position_fill(vjust = 0.5), show.legend = FALSE)\n\n\n\n\n\n\n\n\n\n\nכפי שניתן להבחין בתרשים, ישנם הבדלים מסוימים. לדוגמה, בשנת 2007 רק 31% מהדגימות הם של פינגויינים מזן Gentoo לעומת שנת 2008 שם 40% מהדגימות הן מזן Gentoo. השערת האפס שלנו היא שהמשתנה שנה והמשתנה זן הפינגויין הם בלתי תלויים, וההשערה האלטרנטיבית הינה שהם תלויים.\nגם במקרה זה נשתמש בפונקציה chisq.test. נדגים שתי שיטות להפעיל את הפונקציה, שתיהן מביאות אותה התוצאה. השיטה הראשונה היא להזין את הפונקציה בשני וקטורים של המשתנים:\n\nindependent_chisqtest &lt;- chisq.test(x = penguins$year, y = penguins$species)\nindependent_chisqtest\n\n\n    Pearson's Chi-squared test\n\ndata:  penguins$year and penguins$species\nX-squared = 3.2156, df = 4, p-value = 0.5224\n\n\nהשיטה השניה היא ראשית לבנות מטריצה (בגודל 3 על 3 במקרה שלנו, כי לכל משתנה שלושה ערכים אפשריים), ואז להזין אותה לפונקציה כך:\n\npenguin_species_year_counts &lt;- penguins %&gt;% \n  mutate(year = as.character(year)) %&gt;% \n  count(year, species) %&gt;% \n  pivot_wider(names_from = species, values_from = n) %&gt;% \n  select(-year) %&gt;% \n  as.matrix()\n\nchisq.test(x = penguin_species_year_counts)\n\n\n    Pearson's Chi-squared test\n\ndata:  penguin_species_year_counts\nX-squared = 3.2156, df = 4, p-value = 0.5224\n\n\n\n\n\n\n\n\nלמה התוצאות זהות?\n\n\n\nתוצאות המבחן בשני המקרים כמובן זהות, משום שבוריאציה הראשונה הפונקציה מבצעת באופן פנימי את הספירה שביצענו בוריאציה השניה. הסיבה שהצגנו את שתי האפשרויות היא שלעיתים הנתונים שיש בידינו הם רק הספירות ולא הפקטורים המקוריים (ואז נהיה חייבים להשתמש באפשרות השניה).\n\n\nמבחינת פרשנות- ניתן לראות שערך ה-p.value הינו 0.5224, ולכן לא ניתן לדחות את השערת האפס (כלומר ייתכן שהמשתנים בלתי תלויים).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#מבחן-פרופורציות",
    "href": "06-hypothesis-tests.html#מבחן-פרופורציות",
    "title": "6  מבחני השערות",
    "section": "6.6 מבחן פרופורציות",
    "text": "6.6 מבחן פרופורציות\nבמקרים בהם אנחנו רוצים להשוות פרופורציות בין שתי קבוצות (שני מדגמים), או לבצע מבחן השערות על פרופורציות בקבוצה מסוימת, נשתמש במבחן פרופורציות.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#מבחן-פרופורציות-עם-מדגם-יחיד",
    "href": "06-hypothesis-tests.html#מבחן-פרופורציות-עם-מדגם-יחיד",
    "title": "6  מבחני השערות",
    "section": "6.7 מבחן פרופורציות עם מדגם יחיד",
    "text": "6.7 מבחן פרופורציות עם מדגם יחיד\nראשית נדגים מבחן פרופורציות עם מדגם יחיד: נבצע מבחן סטטיסטי על פרופורצית הפינגויינים ששוקלים מעל 4 ק”ג, ונבחן האם פרופורציה זו שונה באופן מובהק מ-50%.\n\npenguins %&gt;% \n  filter(!is.na(body_mass_g)) %&gt;% \n  mutate(is_above_4kg = body_mass_g &gt;= 4000) %&gt;% \n  summarize(tot_above_4kg = sum(is_above_4kg),\n            tot_under_4kg = sum(!is_above_4kg),\n            total_specimens = n())\n\n# A tibble: 1 × 3\n  tot_above_4kg tot_under_4kg total_specimens\n          &lt;int&gt;         &lt;int&gt;           &lt;int&gt;\n1           177           165             342\n\n\nכפי שניתן לראות יש 165 פרטים עם משקל מתחת ל-4 ק”ג, ו-177 פרטים עם משקל מעל 4 ק”ג. סה”כ 342 פרטים. נשתמש בפקודה prop.test על מנת לבחון את ההשערה של חלוקה שווה (פרופורציה 50%).\n\npenguin_prop &lt;- prop.test(x = 177, n = 342, p = 0.5)\npenguin_prop\n\n\n    1-sample proportions test with continuity correction\n\ndata:  177 out of 342, null probability 0.5\nX-squared = 0.3538, df = 1, p-value = 0.552\nalternative hypothesis: true p is not equal to 0.5\n95 percent confidence interval:\n 0.4632340 0.5714533\nsample estimates:\n        p \n0.5175439 \n\n\nכפי שניתן לראות בפלט הפקודה, ערך ה-p-value הינו 0.552, ולכן לא ניתן לדחות את השערת האפס של חלוקה חצי/חצי. רווח בר סמך לפרופורציה של הפינגויינים בעלי משקל מעל 4 ק”ג עומד על בין 0.463 ועד 0.571.\n\n\n\n\n\n\nנקודות למחשבה\n\n\n\nנסו לבצע את המבחן עם פרופורצית הפרטים מתחת למשקל 4 ק”ג. האם מתקבלת אותה התוצאה? מה שונה ומה דומה בפלט? הסבירו.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#מבחן-פרופורציות-לשני-מדגמים",
    "href": "06-hypothesis-tests.html#מבחן-פרופורציות-לשני-מדגמים",
    "title": "6  מבחני השערות",
    "section": "6.8 מבחן פרופורציות לשני מדגמים",
    "text": "6.8 מבחן פרופורציות לשני מדגמים\nנבצע מבחן המשווה את שיעור הפרטים בעלי משקל מעל 4.5 ק”ג המשווה בין זן ה-Gentoo ליתר הזנים.\n\ngentoo_weight &lt;- penguins %&gt;% \n  mutate(is_gentoo = species == \"Gentoo\") %&gt;% \n  filter(!is.na(body_mass_g)) %&gt;% \n  group_by(is_gentoo) %&gt;% \n  summarize(above_4.5kg = sum(body_mass_g &gt;= 4500),\n            under_4.5kg = sum(body_mass_g &lt; 4500),\n            tot = n())\n\ngentoo_weight\n\n# A tibble: 2 × 4\n  is_gentoo above_4.5kg under_4.5kg   tot\n  &lt;lgl&gt;           &lt;int&gt;       &lt;int&gt; &lt;int&gt;\n1 FALSE              11         208   219\n2 TRUE              107          16   123\n\ntwosample_prop &lt;- prop.test(x = c(11, 107), n = c(219, 123))\ntwosample_prop\n\n\n    2-sample test for equality of proportions with continuity correction\n\ndata:  c(11, 107) out of c(219, 123)\nX-squared = 230.56, df = 1, p-value &lt; 2.2e-16\nalternative hypothesis: two.sided\n95 percent confidence interval:\n -0.8921516 -0.7472291\nsample estimates:\n    prop 1     prop 2 \n0.05022831 0.86991870 \n\n\nכפי שניתן לראות על פי תוצאות המבחן, יש שיעור של כ-5% מהפינגויינים שאינם מזן Gentoo שיש להם משקל מעל 4.5 ק”ג, לעומת 87% מהפינגויינים שהם כן מזן Gentoo ובעלי משקל מעל 4.5 ק”ג. הבדל זה מובהק סטטיסטית עם p-value &lt; 2.2e-16 (כלומר קטן מהמספר הקטן ביותר שהמחשב יכול להציג).\nרווח בר סמך להפרש בין אחוזים אלו עומד על בין 0.747 ועד 0.892 (בשורה בפלט זה מופיע בסימן שלילי משום שהפקודה מחסרת את הפרופורציה הראשונה מהשניה ובמקרה זה הפרופורציה הראשונה נמוכה מהשניה - 11 מתוך 219 לעומת 107 מתוך 123).\n\n\n\n\n\n\nהקשר שבין מבחני פרופורציות ומבחן חי-בריבוע לאי-תלות\n\n\n\nנסו להשתמש במבחן חי-בריבוע chisq.test על מנת לבצע את מבחן הפרופורציות מהסעיף הקודם\nרמז: עליכם לבנות מטריצה 2*2 כאשר השורות הן מעל/מתחת למשקל שנקבע והעמודות הם שני הסוגים של הפינגויינים (כן/לא מסוג Gentoo.\nהאם קיבלתם את אותה התוצאה כמו במבחן הפרופורציות? (מה שונה ומה דומה?)\nהוסיפו ארגומנט למבחן הפרופורציות: correct = FALSE, ארגומנט זה מבטל תיקון (מניפולציה) שמבצעת הפונקציה. האם כעת התוצאות זהות?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#מבחן-קולמוגורוב-סמירנוב-ks-test-להתפלגות",
    "href": "06-hypothesis-tests.html#מבחן-קולמוגורוב-סמירנוב-ks-test-להתפלגות",
    "title": "6  מבחני השערות",
    "section": "6.9 מבחן קולמוגורוב-סמירנוב (KS test) להתפלגות",
    "text": "6.9 מבחן קולמוגורוב-סמירנוב (KS test) להתפלגות\nמבחן קולמוגורוב-סמירנוב משמש להשוואה בין שתי התפלגויות, בדומה למבחן חי-בריבוע לטיב התאמה, אך הוא אינו דורש התפלגויות בדידות (כפי שמבחן חי-בריבוע דורש).\nאפשר להפעיל אותו על מנת להשוות בין שתי התפלגויות רציפות נתונות או בין התפלגות רציפה נתונה לבין התפלגות רציפה תיאורתית. לדוגמה, נשוואה את אורך המקור של פינגויינים מזן Adelie להתפלגות רציפה תיאורתית נורמלית עם תוחלת 38.79, וסטיית תקן 2.66:\n\nks_test_output &lt;- ks.test(adelie$bill_length_mm, \"pnorm\", mean = length_mu, sd = length_sd)\n\nWarning in ks.test(adelie$bill_length_mm, \"pnorm\", mean = length_mu, sd =\nlength_sd): ties should not be present for the Kolmogorov-Smirnov test\n\nks_test_output\n\n\n    One-sample Kolmogorov-Smirnov test\n\ndata:  adelie$bill_length_mm\nD = 0.042489, p-value = 0.948\nalternative hypothesis: two-sided\n\n\nתוצאת המבחן במקרה זה הינה שלא ניתן לדחות את השערת האפס (שההתפלגות הינה התפלגות נורמלית עם תוחלת וסטיית תקן כפי שחושבו מהדאטה). בדומה לממצא שקיבלנו ממבחן טיב ההתאמה מסוג חי-בריבוע.\n\n\n\n\n\n\nהודעת האזהרה של פלט המבחן ks.test\n\n\n\nבמסגרת המבחן שהרצנו קיבלנו הודעת אזהרה:\nties should not be present for the Kolmogorob-Smirnov test.\nמבחן קולמוגורוב-סמירנוב משתמש בסטטיסטי אחר מהסטטיסטיים שהצגנו עד כה (סטטיסטי t וסטטיסטי חי-בריבוע). במסגרת חישוב הסטטיסטי של מבחן קולמוגורוב-סמירנוב מסודרים הערכים שבמדגם. אם מחושבת ההתפלגות האמפירית ומשוות להתפלגות התיאורתית. הודעת האזהרה מעידה על כך שיש ערכים זהים שלא ניתן לסדרם, אך המבחן עדיין עובד ומחזיר את תוצאת החישוב. ככל שבהתפלגות האמפירית ישנם הרבה ערכים זהים, זה מהווה אינדיקציה לכך שההתפלגות אינה רציפה, וייתכן שמבחן טיב התאמה עשוי להיות מתאים יותר (ואשר משווה להתפלגות בדידה).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#סידור-הפלט-של-מבחני-השערות",
    "href": "06-hypothesis-tests.html#סידור-הפלט-של-מבחני-השערות",
    "title": "6  מבחני השערות",
    "section": "6.10 סידור הפלט של מבחני השערות",
    "text": "6.10 סידור הפלט של מבחני השערות\nבכל המקרים שבחנו בפרק זה הזנו למבחנים נתונים בפורמט מסודר של טבלאות (אם הפעלנו את ארגומנט ה-data וה-formula או בפורמט של וקטורים). תוצאות המבחנים הוצגו כפלט טקסטואלי, אך בפועל היו רשימה (list) עם רכיבים שונים שניתן להפריד אותם. לדוגמה במבחן האחרון שהרצנו (ks.test) ניתן היה לקרוא רק לערכו של ה-p-value על ידי שימוש בקוד: ks_test_output$p.value. ישנה חבילה הנקראת broom ובה פקודה הנקראת tidy שמסייעת לנו להפוך את הפלט של הפקודות השונות לטבלה (פחות או יותר אחידה).\nנדגים זאת על חלק מהפלטים שראינו בפרק (כולל סידור של פורמט העמודות בטבלה באמצעות חבילת gt).\n\nlibrary(broom)\nbind_rows(\n  tidy(adeliettest),\n  tidy(paired_ttest),\n  tidy(independent_chisqtest),\n  tidy(penguin_prop),\n  tidy(ks_test_output)\n) %&gt;% \n  gt::gt() %&gt;% \n  gt::fmt_number(columns = c(1:2, 4:6), decimals = 2)\n\n\n\n\n\n\n\n\n\n\nestimate\nstatistic\np.value\nparameter\nconf.low\nconf.high\nmethod\nalternative\n\n\n\n\n38.79\n3.65\n3.598478e-04\n150.00\n38.36\n39.22\nOne Sample t-test\ntwo.sided\n\n\n26.77\n79.51\n3.594279e-222\n341.00\n26.11\n27.43\nPaired t-test\ntwo.sided\n\n\nNA\n3.22\n5.224226e-01\n4.00\nNA\nNA\nPearson's Chi-squared test\nNA\n\n\n0.52\n0.35\n5.519692e-01\n1.00\n0.46\n0.57\n1-sample proportions test with continuity correction\ntwo.sided\n\n\nNA\n0.04\n9.480165e-01\nNA\nNA\nNA\nOne-sample Kolmogorov-Smirnov test\ntwo-sided\n\n\n\n\n\n\n\n\nגישה זו שימושית במיוחד כאשר מריצים הרבה מבחנים זהים על קבוצות שונות, כפי שנדגים ב פרק 9.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "06-hypothesis-tests.html#סיכום",
    "href": "06-hypothesis-tests.html#סיכום",
    "title": "6  מבחני השערות",
    "section": "6.11 סיכום",
    "text": "6.11 סיכום\nבפרק זה בחנו מבחנים סטטיסטיים מסוגים שונים:\nהתחלנו במבחני השערות על תוחלת של מדגם יחיד, מבחני השערות על תוחלת עבור שני מדגמים לא-מזווגים ועבור שני מדגמים מזווגים.\nלמדנו על מבחן לשיוויון שונויות, ומבחני חי-בריבוע לטיב התאמה ולאי-תלות.\nלאחר מכן למדנו להשתמש במבחני פרופורציות (מדגם יחיד, ושני מדגמים), ועל מבחן קולמוגורוב-סמירנוב להתפלגות.\nלבסוף למדנו כיצד ניתן להעביר את הפלט של המבחנים לפלט טבלאי מסודר.\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד\n\n\n\n\n\nWalpole, Ronald E, Raymond H Myers, Sharon L Myers, and Keying Ye. 1993. Probability and Statistics for Engineers and Scientists. Vol. 5. Macmillan New York.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>מבחני השערות</span>"
    ]
  },
  {
    "objectID": "07-linear-regression.html#פלט-הפקודה-lm",
    "href": "07-linear-regression.html#פלט-הפקודה-lm",
    "title": "7  רגרסיה לינארית",
    "section": "7.1 פלט הפקודה lm",
    "text": "7.1 פלט הפקודה lm\nהחלק הראשון בפלט (call) מתאר את הפקודה שבה השתמשנו על מנת לקבל את המודל.\n\n7.1.1 השאריות\nהחלק השני (residuals) מתאר את שאריות המודל. השאריות הן ההפרש בין הערך האמיתי של y לבין תוצאת המודל (במקרה זה הערך של אורך המקור פחות חיזוי המודל לאורך המקור). בפלט המודל ניתן לראות את המינימום, ואת הרבעונים (ביניהם החציון), ואת המקסימום. ניתן גם לחלץ את השאריות עצמן על ידי הקריאה adelie_lm$residuals. באופן כזה ניתן גם להסתכל בהתפלגות עצמה (נבחן זאת בהמשך הפרק).\n\n\n\n\n\n\nNote\n\n\n\nשימו לב שבשאריות לא מופיע ממוצע השגיאות. הסיבה לכך היא שבמודל רגרסיה לינארית ממוצע השגיאות הוא תמיד אפס. למעוניינים, ניתן למצוא הוכחות מתמטיות בספרות, וגם במקורות שונים באינטרנט, לדוגמה בקישור זה.\n\n\nאם נקפוץ רגע לתחתית הפלט, נראה שבשורה השלישית מלמטה יש את ה-Residual standard error, שהיא טעות התקן של השאריות. הערך שמופיע בצמוד (149) הוא מספר דרגות החופש של המודל, קרי מספר התצפיות פחות מספר הפרמטרים של המודל, וניתן לחלץ אותו על ידי קריאה ל-adelie_lm$df.residual.\nנסו לחשב את sqrt(sum(adelie_lm$residuals^2)/adelie_lm$df.residual)) על מנת לשחזר את החישוב המופיע בשורה הזו.\n\n\n7.1.2 טבלת המקדמים\nהטבלה שמתחת לשאריות מציגה את מקדמי הרגרסיה, כאשר ה-Intercept הוא החותך (\\(\\beta_0\\)) והשורות הבאות מתייחסות למקדמים של המשתנים (במקרה הזה המקדם של המשתנה bill_length_mm. העמודה Estimate מתייחסת לערך עצמו של המקדם (למעשה מדובר באמד למקדם), העמודה השניה לטעות התקן של המקדם, ושתי העמודות האחרונות מתייחסות למבחן סטטסטי מסוג T-test הבוחן האם המקדם שווה ל-0 (בהשערת האפשר) או שונה מאפס (השערה אלטרנטיבית). העמודה t value מתייחסת לערך סטטיסטי T והעמודה Pr(&lt;|t|) מתייחסת לערך ה-p-value של המבחן.\nמימין לעמודת ה-p-value ישנו מקרא של ערכי p-value, שמתואר גם מתחת לטבלה, ועוזר לנו לזהות מיידית מקדמים מובהקים (שימושי בטבלאות ארוכות עם הרבה מקדמים).\n\n\n7.1.3 שונות מוסברת\nאחוז השונות המוסברת, המסומן כ-\\(R^2\\) הוא היחס בין השונות של מודל הרגרסיה (השונות של התחזיות \\(\\hat{y}_i\\) שמסומנת כ-\\(\\operatorname{SSR}\\)) לבין השונות הכללית של המשתנה התלוי (\\(y_i\\) המסומנת ב-\\(\\operatorname{SST}\\)). הרעיון הוא שככל שהמודל מכיל יותר שונות, כך הוא מצליח להסביר יותר טוב את המשתנה התלוי, לכן נרצה שהשונות המוסברת תהיה גבוהה ככל הניתן (במסגרת מגבלות של Over-fitting שנדון בהם בפרק הבא). השונות המוסברת חסומה בשונות הכללית (\\(0\\leq\\operatorname{SSR}\\leq\\operatorname{SST}\\)), ולכן \\(0\\leq R^2\\leq1\\).\nבפלט המודל לעיל, ערך השונות המוסברת הינו \\(R^2=0.1533\\). כלומר המשתנה bill_length_mm מצליח להסביר כ-15% מהשונות של המשתנה bill_depth_mm.\nהערך שמסומן בפלט כ-Adjusted R-squared קרוב לערך \\(R^2\\), אך מביא בחשבון את מספר הפרמטרים של המודל (ככל שלמודל יהיו יותר פרמטרים, ערך Adjusted R-squared יהיה נמוך יותר).\n\n\n7.1.4 סטטיסטי F\nבתחתיתו של פלט המודל מופיע ערכו של סטטיסטי F. סטטיסטי זה מתייחס למבחן הסטטיסטי שבו בהשערת האפס כלל המקדמים הינם אפס(\\(\\beta_i=0, \\forall i\\geq1\\)), לעומת ההשערה האלטרנטיבית שבה אחד המקדמים שונה מ-0.\n\n\n\n\n\n\nתרגיל: ערכי p-value במודל רגרסיה\n\n\n\nבמודל שלעיל ערך ה-p-value של סטטיסטי F זהה לערך ה-p-value של מקדם bill_length_mm. למה?\nנסו לבנות מודל רגרסיה עם bill_length_mm וגם עם flipper_length_mm. האם במודל זה ערכי ה-p-values של המקדמים ושל מבחן F זהים? הסבירו מדוע.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>רגרסיה לינארית</span>"
    ]
  },
  {
    "objectID": "07-linear-regression.html#המחשה-של-שגיאות-המודל",
    "href": "07-linear-regression.html#המחשה-של-שגיאות-המודל",
    "title": "7  רגרסיה לינארית",
    "section": "7.2 המחשה של שגיאות המודל",
    "text": "7.2 המחשה של שגיאות המודל\nכעת נמחיש את שגיאות המודל. התרשים הבא מציג מדגם של 25 תצפיות, בציר x המשתנה bill_length_mm ובציר ה-y המשתנה התלוי bill_depth_mm.\n\nset.seed(0)\nadelie_penguins %&gt;% \n  mutate(model_predictions = predict(adelie_lm)) %&gt;% \n  sample_n(25) %&gt;% \n  ggplot() + \n  geom_line(aes(x = bill_length_mm, y = model_predictions)) + \n  geom_point(aes(x = bill_length_mm, y = bill_depth_mm)) + \n  geom_segment(aes(x = bill_length_mm, xend = bill_length_mm,\n                   y = model_predictions, yend = bill_depth_mm),\n               linetype = \"dashed\") + \n  ggtitle(\"Illustration of linear regression residual errors\",\n          subtitle = \"A sample of 25 observations\")\n\n\n\n\n\n\n\n\n\n\nהקווים המקווקים בין הנקודות לקו הרגרסיה מתארים את שגיאות הרגרסיה (השאריות). קו הרגרסיה מביא למינימום את סכום הריבועים של השגיאות הללו.\nלמודל הרגרסיה הלינארית יש שתי הנחות שקשורות לשגיאות:\n\nהנחת הנורמליות של השגיאות: השגיאות מתפלגות נורמלית עם תוחלת 0\nהנחת ההומוסקדסטיות של השגיאות: התפלגות השגיאות (פיזור השגיאות למעשה) לא תלויה במיקום התצפית (במקרה זה, לא תלויה בערך של bill_length_mm.\n\nניתן לחשב מודל רגרסיה גם במקרה שהנחות אלו לא מתקיימות אך המבחנים הסטטיסטיים שמתייחסים למודל ולמקדמי המודל אינם תקפים במידה והנחות הרגרסיה אינן מתקיימות.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>רגרסיה לינארית</span>"
    ]
  },
  {
    "objectID": "07-linear-regression.html#בדיקת-הנחות-הרגרסיה",
    "href": "07-linear-regression.html#בדיקת-הנחות-הרגרסיה",
    "title": "7  רגרסיה לינארית",
    "section": "7.3 בדיקת הנחות הרגרסיה",
    "text": "7.3 בדיקת הנחות הרגרסיה\nכעת נבחן האם הנחות מודל הרגרסיה תקפות עבור מודל הרגרסיה שבנינו.\n\n7.3.1 התפלגות נורמלית\nכפי שראינו בפרק 6, עומדים לרשותנו שני כלים על מנת לבחון התפלגות נורמלית: ויז’ואליזציה (כדוגמת q-q plot), ומבחן השערות (כדוגמת טיב התאמה או קולמוגורוב-סמירנוב). נשתמש ראשית בהמחשה ויזואלית ולאחר מכן במבחן סטטיסטי.\n\ntibble(resid = adelie_lm$residuals) %&gt;% \n  ggplot(aes(sample = resid)) + \n  geom_qq() + \n  ggtitle(\"QQ plot of Adelie linear model residuals\") + \n  geom_qq_line()\n\n\n\n\n\n\n\n\n\n\nכפי שניתן לראות, יש חריגה מסוימת מההתפלגות הנורמלית, בעיקר בקצוות של ההתפלגות: מעבר לציון תקן 1 בציר ה-x ניתן לראות שהשאריות גבוהות מהצפוי (מעל הקו של y=x, בחלק הימני העליון של התרשים), ובאופן דומה (אך פחות בולט) בחלק התחתון-שמאלי של התרשים.\nנשתמש במבחן קולמוגורוב-סמירנוב לבדיקת ההשערה שההתפלגות של השגיאות נורמלית. במסגרת קלט המבחן אנחנו משתמשים בפונקציה scale על מנת לוודא שסטיית התקן של השגיאות מנורמלת ל-1 (כפי שציינו מוקדם יותר בפרק זה, ממוצע השגיאות הוא 0 ממילא). לחילופין, ניתן היה לציין פרמטרים בפקודה אשר מגדירים לפונקציה לאיזה התפלגות נורמלית משווים הנתונים (כפי שהפעלנו אותה בפרק שדן במבחני השערות).\n\nks.test(scale(adelie_lm$residuals)[, 1],\n        \"pnorm\")\n\nWarning in ks.test(scale(adelie_lm$residuals)[, 1], \"pnorm\"): ties should not\nbe present for the Kolmogorov-Smirnov test\n\n\n\n    One-sample Kolmogorov-Smirnov test\n\ndata:  scale(adelie_lm$residuals)[, 1]\nD = 0.066494, p-value = 0.5166\nalternative hypothesis: two-sided\n\n\nעל פי פלט הפקודה, ה-p-value לדחיית השערת האפס הינו 0.5166, ולכן לא ניתן לדחות את השערת האפס שהשאריות מתפלגות נורמלית.\nנשים לב לאזהרה שהפקודה מוציאה, שמתייחסת לכך שיש שתי תצפיות של שאריות שערכן זהה. מכיוון שהתפלגות נורמלית הינה התפלגות רציפה, ההסתברות לשתי תצפיות שוות הינה 0. מכיוון שהתצפיות שאנו משתמשים בהן הינן תצפיות מדידה, ישנן שתי תצפיות זהות עם ערך שארית זהה.\n\n\n\n\n\n\nתרגיל: בחינת נורמליות של השאריות\n\n\n\nהשתמשו בפונקציה unique על מנת להריץ את הפקודה מבלי לקבל את הודעת האזהרה של פקודת ks.test. האם השתנתה התובנה לגבי ההתפלגות הנורמלית של השאריות?\nהשתמשו במבחן טיב-התאמה במקום במבחן קולמוגורוב סמירנוב. האם השתנתה התובנה לגבי ההתפלגות הנורמלית של השאריות?\n\n\n\n\n7.3.2 הומוסקדסטיות\nעל מנת לבחון הומוסקדסטיות, נרצה לראות האם יש הבדל בשונות של שגיאות המודל כפונקציה של המשתנה הבלתי תלוי. במקרים בהם משתמשים ברגרסיה רב משתנית (יותר ממשתנה בלתי תלוי אחד), ניתן לבצע בדיקה זו למול כל משתנה בלתי תלוי (או שלעיתים מבוצעת הבדיקה למול המשתנה התלוי, כקירוב).\n\ntibble(adelie_lm$model) %&gt;% \n  mutate(resid = adelie_lm$residuals) %&gt;% \n  ggplot(aes(x = bill_length_mm, y = resid)) + \n  geom_point() + \n  ggtitle(\"Model residuals against the bill length\")\n\n\n\n\n\n\n\n\n\n\nמהתרשים לא ניתן להבחין בהפרה משמעותית של הנחת ההומוסקדסטיות: הפיזור של התצפיות מסביב לציר ה-y=0 נראה כאחיד. ניתן גם לחלק את המשתנה למספר קבוצות, ולהמחיש את השונות בדרכים נוספות, לדוגמה באמצעות Boxplot. שיטה זו שימושית במיוחד כשמדובר במשתנים קטגוריאליים, אך ניתן להשתמש בה גם במקרה הנוכחי על ידי חלוקת המשתנה הבלתי תלוי לקטגוריות:\n\nhomoscedasticity_test &lt;- tibble(adelie_lm$model) %&gt;% \n  mutate(resid = adelie_lm$residuals) %&gt;% \n  mutate(bill_length_fct = cut(bill_length_mm, \n                               breaks = c(\n                                 31, 37, 40, 42, 50\n                               )))\n\nhomoscedasticity_test %&gt;% \n  ggplot(aes(x = bill_length_fct, y = resid)) + \n  geom_boxplot() + \n  ggtitle(\"Model residual distribution against bill length groups (boxplot)\")\n\n\n\n\n\n\n\n\n\n\nבהסתכלות בתרשים ה-Boxplot נראה שיש הבדל מסוים בין הקבוצות. נשתמש במבחן הומוסקדסטיות לשונות על מנת לבחון את ההשערה להומוסקדסטיות (לעומת השערה אלטרנטיבית של הטרוסקדסטיות).\nיש מספר מבחנים סטטיסטיים בהם ניתן להשתמש (לדוגמה במבחן F לשיוויון שונויות, שבו השתמשנו בפרק שעסק במבחני השערות). נדגים את המבחן הסטטיסטי באמצעות מבחן Bartlett’s test ובאמצעות Levene’s test.\n\nbartlett.test(resid ~ bill_length_fct, \n              data = homoscedasticity_test)\n\n\n    Bartlett test of homogeneity of variances\n\ndata:  resid by bill_length_fct\nBartlett's K-squared = 1.6153, df = 3, p-value = 0.6559\n\ncar::leveneTest(resid ~ bill_length_fct, \n                data = homoscedasticity_test)\n\nLevene's Test for Homogeneity of Variance (center = median)\n       Df F value Pr(&gt;F)\ngroup   3  0.8096 0.4904\n      147               \n\n\nבשני המבחנים קיבלנו ערכי p-value&gt;0.05 ולכן לא ניתן לדחות את השערת האפס שהשונות בין הקבוצות שווה. ככל הנראה, הנחת ההומוסקדסטיות מתקיימת והמודל תקין. ככלל, ניתן להסתפק במבחן אחד מבין השניים.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>רגרסיה לינארית</span>"
    ]
  },
  {
    "objectID": "07-linear-regression.html#סידור-פלט-הפקודה",
    "href": "07-linear-regression.html#סידור-פלט-הפקודה",
    "title": "7  רגרסיה לינארית",
    "section": "7.4 סידור פלט הפקודה",
    "text": "7.4 סידור פלט הפקודה\nנציין שישנה דרך לחלץ את נתוני המקדמים של המודל כאובייקט tibble על ידי שימוש בפקודה broom::tidy באופן הבא (בדומה לשימוש בפקודה זו שראינו בפרק הקודם):\n\nbroom::tidy(adelie_lm)\n\n# A tibble: 2 × 5\n  term           estimate std.error statistic  p.value\n  &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)      11.4      1.34        8.52 1.61e-14\n2 bill_length_mm    0.179    0.0344      5.19 6.67e- 7\n\n\nישנן פקודות שונות שניתן להשתמש בהן על מנת להדפיס את תוצאות הרגרסיה בטבלה מסודרת (כזו שתתאים לפרסום), לדוגמה:\n\n\ngtsummary::tbl_regression(adelie_lm)\n\n\n\n\n\n\n\nCharacteristic\nBeta\n95% CI1\np-value\n\n\n\n\nbill_length_mm\n0.18\n0.11, 0.25\n&lt;0.001\n\n\n\n1 CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nחבילות נוספות הינן stargazer לטבלאות, ו-jtools לויז’ואליזציות.\nלא נדון בחבילות אלו בפרק זה, אך הקורא המעוניין מוזמן להתעמק בחבילות וביכולות.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>רגרסיה לינארית</span>"
    ]
  },
  {
    "objectID": "07-linear-regression.html#רגרסיה-מרובת-משתנים",
    "href": "07-linear-regression.html#רגרסיה-מרובת-משתנים",
    "title": "7  רגרסיה לינארית",
    "section": "7.5 רגרסיה מרובת משתנים",
    "text": "7.5 רגרסיה מרובת משתנים\nעד כה הדגמנו רגרסיה חד-משתנית, כלומר משתנה בלתי תלוי יחיד. כעת נרחיב את ההסתכלות למודל רגרסיה רב משתני: ישנם מספר משתנים בלתי-תלויים (ומשתנה תלוי אחד).\nנשתמש במודל של רגרסיה לינארית לחיזוי ה-bill_depth_mm, באמצעות משתנים נוספים:\n\nadelie_mult_lm &lt;- \n  lm(formula = \n       bill_depth_mm ~ bill_length_mm + flipper_length_mm + body_mass_g + sex,\n     data = adelie_penguins)\n\nsummary(adelie_mult_lm)\n\n\nCall:\nlm(formula = bill_depth_mm ~ bill_length_mm + flipper_length_mm + \n    body_mass_g + sex, data = adelie_penguins)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.9988 -0.6258 -0.0205  0.6169  2.6504 \n\nCoefficients:\n                    Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       13.4808454  2.6455712   5.096  1.1e-06 ***\nbill_length_mm    -0.0024733  0.0379562  -0.065 0.948136    \nflipper_length_mm  0.0088627  0.0138460   0.640 0.523153    \nbody_mass_g        0.0007625  0.0002747   2.776 0.006249 ** \nsexmale            0.9030693  0.2490620   3.626 0.000401 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9571 on 141 degrees of freedom\n  (5 observations deleted due to missingness)\nMultiple R-squared:  0.4009,    Adjusted R-squared:  0.3839 \nF-statistic: 23.58 on 4 and 141 DF,  p-value: 6.06e-15\n\n\nראשית, נשים לב לאופן ההתייחסות של המודל למשתנה sex שהוא משתנה מסוג פקטור (factor). למשתנה זה ישנם שני ערכים אפשריים (male/female). הפקודה הופכת את המשתנה למשתנה דמה (dummy variable), אשר מקבל את הערך 1 כאשר הפרט ממין זכר (ומקבל 0 כאשר הפרט ממין נקבה). לכן בטבלת הפלט בשורה הרלוונטית המתייחסת למשתנה sex, מופיע גם הערך שממופה על ידי הפקודה ל-1 (כ-sexmale).\nפלט הפקודה מלמד אותנו את התכונות הבאות של המודל:\n\nהמודל מסביר כ-40% מהשונות (Multiple R-squared:  0.4009)\nהרגרסיה מובהקת (כלומר לפחות אחד מהמקדמים שונה מאפס), על בסיס ה-p-value שמדווח בתחתית הפלט (p-value: 6.06e-15)\nהמשתנים המובהקים הינם body_mass_g, וכן sex:\n\nכאשר משקל הפרט עולה בגרם, אז עומק המקור (המשתנה התלוי) גדל ב-0.0007625 ס”מ (בהתאם למקדם של המשקל)\nכאשר הפינגויין הינו זכר, אז עומק המקור גדל ב-0.903 (בהתאם למקדם של sex).\n\n\n\n\n\n\n\n\nתרגיל: פקטורים מרובי ערכים ברגרסיה לינארית\n\n\n\nבדוגמה שלהלן ראינו משתנה פקטוריאלי שמקבל שני ערכים אפשריים, ובא לידי ביטוי בפלט הפקודה בשורה של sexmale.\n\nמה צפוי לקרות במקרה של משתנה פקטוריאלי שיש לו יותר ערכים אפשריים?\nכמה משתני דמה נקבל במקרה של משתנה פקטור שיש לו t ערכים מקוריים אפשריים?\nהאם תוכלו ליצור מהנתונים הקיימים (penguins) מודל רגרסיה המכיל משתנה פקטוריאלי עם יותר משני ערכים אפשריים?\n\n\n\n\n\n\n\n\n\nתרגיל: בחינת הנחות מודל הרגרסיה\n\n\n\nהשתמשו בכלים שנידונו בסעיף “בדיקת הנחות הרגרסיה” על מנת לבחון את הנחות הרגרסיה שלעיל:\n\nהאם מתקיימת הנחת הומוסקדסטיות?\nהאם מתקיימת הנחת ההתפלגות הנורמלית של השאריות?\n\n\n\n\n7.5.1 אינטראקציה של משתנים\nרגרסיה לינארית מניחה מודל לינארי (סכום של משתנים המוכפלים במקדמים), אך בפועל ניתן להשתמש בה גם על מנת לבטא קשרים שאינם לינאריים. לדוגמה מכפלה של משתנים, חזקות, ועוד קשרים פונקציונליים. התאמה זו ניתן לבצע על ידי הגדרה של משתנים נוספים שהם טרנספורמציה של משתנים קיימים, או לעיתים על ידי שימוש בארגומנט ה-formula בפונקציה lm. אחת הדוגמאות למקרים כאלו היא אינטראקציה בין משתנים, קרי כאשר היחס בין משתנה תלוי למשתנים הבלתי תלויים תלוי במכפלה בין המשתנים הבלתי תלויים.\nניתן למצוא דוגמה לאינטראקציה גם בנתונים של הפינגויינים, ולמעשה, ראינו דוגמה דומה בפרק קודם שעסק בויז’ואליזציות (פרק 4). נמחיש זאת באמצעות התרשים הבא שמציג את הקשר בין אורך הכנף, סוג הפינגויין, והשפעתם על עומק המקור.\n\npenguins %&gt;% \n  ggplot(aes(color = species, y = bill_depth_mm, x = flipper_length_mm)) + \n  geom_point() + \n  stat_smooth(method = \"lm\", se = FALSE) +\n  ggtitle(\"Illustration of interaction between flipper_lenth_mm and species\")\n\n\n\n\n\n\n\n\n\n\nכפי שניתן לראות בתרשים, לכל סוג פינגויינים קשר שונה בין עומק המקור ואורך הכנף. אם ננסה לבנות מודל שלא מביא בחשבון את האינטראקציה בין סוג הפינגויין לאורך הכנף, נקבל מודל מטעה שיציג קשר שלילי בין עומק המקור ואורך הכנף. למעשה, ניתן לראות שעבור פינגויינים מסוג Adelie ומסוג Chinstrap הקשר דומה, אך פינגויינים מסוג Gentoo ממחישים קשר שונה.\nעל מנת להביא בחשבון את האינטראקציה המתוארת נשתמש בנוסחה הבאה: bill_depth_mm ~ flipper_length_mm * species להלן:\n\ninteraction_lm &lt;- lm(bill_depth_mm ~ flipper_length_mm * species, data = penguins)\n\nsummary(interaction_lm)\n\n\nCall:\nlm(formula = bill_depth_mm ~ flipper_length_mm * species, data = penguins)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2.73455 -0.66057 -0.02039  0.65146  2.92206 \n\nCoefficients:\n                                    Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                          7.47494    2.30556   3.242  0.00131 ** \nflipper_length_mm                    0.05723    0.01213   4.718 3.50e-06 ***\nspeciesChinstrap                    -7.14033    3.99381  -1.788  0.07470 .  \nspeciesGentoo                      -15.71179    3.74181  -4.199 3.44e-05 ***\nflipper_length_mm:speciesChinstrap   0.03513    0.02059   1.706  0.08900 .  \nflipper_length_mm:speciesGentoo      0.04968    0.01820   2.730  0.00667 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9715 on 336 degrees of freedom\n  (2 observations deleted due to missingness)\nMultiple R-squared:  0.7615,    Adjusted R-squared:  0.758 \nF-statistic: 214.6 on 5 and 336 DF,  p-value: &lt; 2.2e-16\n\n\nפרשנות הטבלה כעת תביא בחשבון את האינטראקציה:\n\nעבור פרטים מסוג Adelie, הקשר בין אורך הכנף לבין עומק המקור מתבטא במקדם של flipper_length_mm: כל תוספת של יחידה אחת לאורך הכנף מתבטא בתוספת של 0.05 מ”מ לעומק המקור.\nעבור פרטים מסוג Gentoo, יש להביא בחשבון את המקדם שמסומן בטבלה בשורה האחרונה (flipper_length_mm:speciesGentoo) כאשר כל תוספת של יחידה אחת לאורך הכנף מתבטא בתוספת של 0.11 מ”מ לעומק המקור (0.05723 + 0.04968).\n\nכמובן שלקשרים אלו ולצורך חיזוי עומק המקור, יש להביא בחשבון גם את המקדמים של speciesGentoo (אך זה אינו משפיע על “השיפוע” של הקשר אלא רק על “החותך” של קו הרגרסיה).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>רגרסיה לינארית</span>"
    ]
  },
  {
    "objectID": "07-linear-regression.html#סיכום",
    "href": "07-linear-regression.html#סיכום",
    "title": "7  רגרסיה לינארית",
    "section": "7.6 סיכום",
    "text": "7.6 סיכום\nבפרק זה דנו באחד המודלים היסודיים בסטטיסטיקה - רגרסיה לינארית. למדנו איך נראה המודל כאשר ממחישים אותו בדו-מימד, למדנו איך מפעילים את פקודת lm כדי להריץ רגרסיה לינארית, והעמקנו בפלט הפקודה (מקדמים, שונות מוסברת, סטטיסטי F, ועוד).\nראינו דוגמה לאופן ההמחשה של שאריות המודל באמצעים ויזואליים (כגון QQ plot), והבנו את החשיבות שלהם כאשר אנחנו בוחנים את הנחות מודל הרגרסיה (התפלגות נורמלית של השגיאות, והומוסקדסטיות של השגיאות). כמו כן, ראינו דוגמה לסידור פלט הפקודה.\nלבסוף הדגמנו את השימוש באינטראקציה ומתי הוא עשוי להתאים.\nבפרק הבא נדון במודלים מורכבים יותר, ובפרט נלמד את השימוש בtidymodel כחבילה שמסייעת לנו בבניית “מתכון” ותהליך עבודה סדור בפיתוח ותחקור מודלים.\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד\n\n\n\n\n\nWalpole, Ronald E, Raymond H Myers, Sharon L Myers, and Keying Ye. 1993. Probability and Statistics for Engineers and Scientists. Vol. 5. Macmillan New York.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>רגרסיה לינארית</span>"
    ]
  },
  {
    "objectID": "08-advanced-models.html#הקדמה",
    "href": "08-advanced-models.html#הקדמה",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.1 הקדמה",
    "text": "8.1 הקדמה\nניתן לחלק את עולם המודלים הסטטיסטיים לשני סוגים, המובחנים ביניהם בדרך שבה בונים אותם:\n\nמודלים מונחים (Supervised learning)\nמודלים לא מונחים (Unsupervised learning)\n\nמודלים מונחים הינם מודלים שנבנים תוך שימוש במשתנה תלוי (כפי שראינו בפרק הקודם של רגרסיה לינארית), ולעומת זאת, מודלים לא מונחים הינם מודלים שבהם אין משתנה תלוי (נניח לדוגמה כשרוצים לחלק את מרחב התצפיות לאשכולות שונים).\nבפרק זה נתמקד במידול מונחה, מנקודת מבט מעשית, תוך שימוש בחבילות במשפחה של tidymodels.\n\n\n\n\n\n\nקריאה נוספת לצורך העמקה בתיאוריה\n\n\n\nישנן משפחות רבות של מודלים מונחים, בין המוכרים כלולים גם מודלי שפה (כגון ChatGPT), אך גם מודלים לזיהוי נטישה, זיהוי הונאות, רגרסיות למיניהן, למידה עמוקה, ועוד.\nהספר הנוכחי אינו מתמקד בתיאוריה העומדת בבסיס המודלים השונים, אלא מהווה עזר מעשי להפעלת המודלים. אתם מוזמנים לעיין בספרים הבאים לצורך העמקה תיאורתית:\n\nThe Elements of statistical learning (Hastie, Tibshirani, and Friedman 2009)\nAn Introduction to Statistical Learning (James et al. 2021)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  },
  {
    "objectID": "08-advanced-models.html#תיאור-שלבי-העבודה",
    "href": "08-advanced-models.html#תיאור-שלבי-העבודה",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.2 תיאור שלבי העבודה",
    "text": "8.2 תיאור שלבי העבודה\nכפי שציינו במבוא לספר זה, תהליך ניתוח הנתונים כולל טרנספורמציה על משתנים, וויז’ואליזציות של המשתנים והקשרים שלהם, ומידול. שלב המידול עצמו כולל מספר תתי-שלבים:\n\nחלוקה אקראית של המדגם לקבוצת אימון (training set), קבוצת ולידציה (validation set) וקבוצת מבחן (test set).\nבניית מתכון (recipe) להכנת הדאטה למודל. בניית המתכון משמשת להגדרת כל הטרנספורמציות הדרושות לביצוע על הדאטה, לפני שהוא נכנס למודל.\nהגדרת מודל/ים: בשלב זה מגדירים את המודלים בהם הולכים לעשות שימוש. גם מבחינת האלגוריתם של המודל (סוג המודל) וגם מבחינת מטרת המודל (רגרסיה לעומת סיווג).\nהגדרת תהליך אימון המודל (workflow) ובניית המודל הראשוני (fitting).\nכיוונון המודל (tuning).\nהערכת ביצועי המודל (evaluation).\nשימוש במודל לחיזוי תצפיות חדשות (prediction).\n\nבשלב 1 אנחנו מפרקים את הנתונים לשלוש קבוצות, כאשר מטרת קבוצת האימון הינה לבנות את המודל, מטרת קבוצת הולידציה הינה לכוון את “היפר-פרמטרים” של המודל (hyper-paramters)ומטרת קבוצת המבחן היא לבחון את שגיאת המודל (על דאטה שהמודל לא תלוי בו משום שלא נלמד על בסיסו). קבוצת האימון תשתמש אותנו בשלבים 2-5, קבוצת הולידציה תשמש אותנו בשלב 6, וקבוצת המבחן תשמש אותנו בשלב 7 בלבד. שלבים 2-6 עשויים לחזור על עצמם מספר פעמים במהלך פיתוח מודלים (עם גרסאות שונות למודל או מודלים שונים לגמרי). השלב האחרון הינו השלב שבו אנחנו מפיקים ערך מהמודל, ומשתמשים בו לחיזוי עבור תצפיות חדשות.\nכעת נפרק כל אחד מהשלבים ונסביר עליו בפירוט. על מנת להדגים את השלבים נשתמש בדאטה שמלווה אותנו מתחילת הספר (Palmer penguins), כאשר הבעיה שנפתור בפרק זה היא סיווג של תצפית של פינגויין לזכר או נקבה לפי כל המשתנים האחרים שעומדים לרשותנו.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  },
  {
    "objectID": "08-advanced-models.html#חלוקת-המדגם",
    "href": "08-advanced-models.html#חלוקת-המדגם",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.3 חלוקת המדגם",
    "text": "8.3 חלוקת המדגם\nראשית נחלק את המדגם לשלוש הקבוצות: אימון, ולידציה, ומבחן.\nאנחנו קוראים את החבילות הנדרשות, מגדירים Seed, כך שנוכל להגריל חלוקה אקראית אך עקבית (תמיד כשנריץ את הקוד נקבל את אותה החלוקה האקראית), ונפצל את הדאטה לשלושת הקבוצות.\n\nlibrary(tidymodels) # reading the meta-package tidymodels\nlibrary(palmerpenguins) # reading the palmer penguins data set which include penguins\n\nset.seed(42) # set an initial seed\n\n# Modify the dependent var to a dummy\npenguins_new &lt;- penguins %&gt;% \n  mutate(sex = factor(sex))\n\n# Create the split\npenguin_split &lt;- initial_validation_split(penguins_new, \n                                          prop = c(0.6, 0.2), \n                                          strata = sex)\npenguin_split\n\n&lt;Training/Validation/Testing/Total&gt;\n&lt;205/69/70/344&gt;\n\n\nראשית לפני התחלה, שינינו את המשתנה sex למשתנה פקטור. שינוי זה יקל עלינו בהמשך בהפעלת מודלים לסיווג. משתנים קטגוריאליים אחרים המהווים משתנים בלתי-תלויים (משתנים מסבירים) יטופלו בהמשך.\nכפי שניתן לראות, המדגם חולק לקבוצת אימון בגודל של 205 תצפיות (המהווה כ-60% מהדאטה המקורי), קבוצת ולידציה בגודל 69 תצפיות (המהווה כ-20% מהדאטה המקורי), וקבוצת מבחן בגודל 70 תצפיות (המהווה כ-20%). גודל הקבוצות הוגדר באמצעות שימוש בארגומנט prop. מקובל לקבוע את קבוצת האימון כקבוצה הגדולה ביותר. ערכים מקובלים לקבוצת האימון והולידציה הם בדרך כלל 70-80% במצטבר, כאשר גודל קבוצת המבחן יהווה כ-20-30% מהדאטה בהתאמה. עם זאת, אין הגדרות חד-משמעיות בהיבט זה, וניתן לחרוג ממספרים אלו כתלות בצורך.\nהשתמשנו בארגומנט strata על מנת לבצע את הדגימה באופן ששומר על הפרופורציות של מין התצפיות בתוך כל תת-קבוצה. ארגומנט זה שימושי במיוחד כאשר הקבוצות אינן מאוזנות (קבוצה מסוימת קטנה משמעותית מאחרות).\nעל מנת לחלץ את הדאטאות עצמם של כל אחת מהקבוצות נשתמש בפונקציות הבאות:\n\npenguin_train &lt;- training(penguin_split)\npenguin_valid &lt;- validation(penguin_split)\npenguin_test &lt;- testing(penguin_split)\n\nאת המשך הלמידה על הדאטה, כולל בניית המודל, נבצע על קבוצת האימון בלבד penguin_train.\n\n\n\n\n\n\nתרגיל: הבנת הדאטה לפני צלילה למודל\n\n\n\nבדרך כלל לאחר פיצול הדאטה נבצע ויז’ואליזציות שונות כדי להבין איך משתנים שונים משפיעים על המשתנה התלוי (לפני שרואים את השפעתם במודל עצמו). בשלב זה העבודה שתוארה בפרק 4 תהא משמעותית מאוד. לצורך תרגול, בחנו כיצד המשתנים השונים שבדאטה שלנו (penguin_train) משפיעים על מין התצפית.\n\nהשתמשו בויז’ואליזציות שונות כפי שנלמדו והודגמו בפרק על ויז’ואליזציות. לאור הבדיקה, אילו משתנים הייתם מצפים שיהיו משמעותיים במודלים שנפתח?\nישנן שלוש תצפיות בעלות ערך חסר (ללא מין) בקבוצת האימון. לא נוכל להשתמש בתצפיות אלו לצורך אימון המודל - הסבירו מדוע.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  },
  {
    "objectID": "08-advanced-models.html#בניית-מתכון",
    "href": "08-advanced-models.html#בניית-מתכון",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.4 בניית מתכון",
    "text": "8.4 בניית מתכון\nכפי שמיד תראו, חבילת tidymodels מאמצת ז’רגון של מטבח כמו בניית מתכון - recipe, סחיטת מיצים - juice, אפייה - bake, גזר לבן - parsnip, ועוד.\nבשלב זה נבנה “מתכון” שהמטרה שלו להגדיר את השינויים שעובר הדאטה לפני שהוא נכנס למודל. במובן מסויים, התהליך מאוד דומה לתהליך שתואר בפרק 3 על הכנת נתונים, אך יש הבדל מהותי: מתכון זה יופעל אוטומטית בכל פעם שנרצה להפעיל את המודל מחדש על תצפיות חדשות, וכן הוא יופעל גם במהלך שלב הכיוונים (וגם ניתן יהיה להגדיר היפר-פרמטרים כחלק מהמתכון, ולאפשר לשלב הכיוונון לבדוק גם אותם).\nבבניית המתכון הבא נפעיל מספר צעדים, החל מהפקודה recipe לאתחול המקום ודרך צעדים שונים (step) שמיד נסביר אותם.\n\n# Excuse the pun (for the name...)\npenguin_recipe &lt;- recipe(sex ~ ., data = penguin_train) %&gt;% \n  step_naomit(bill_length_mm:sex) %&gt;% \n  step_normalize(all_numeric_predictors()) %&gt;% \n  step_dummy(species, island) %&gt;% \n  step_select(-year) %&gt;% \n  step_corr(bill_length_mm:body_mass_g)\n\npenguin_recipe\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 7\n\n\n\n\n\n── Operations \n\n\n• Removing rows with NA values in: bill_length_mm:sex\n\n\n• Centering and scaling for: all_numeric_predictors()\n\n\n• Dummy variables from: species, island\n\n\n• Variables selected: -year\n\n\n• Correlation filter on: bill_length_mm:body_mass_g\n\n\nבמתכון שלעיל הגדרנו ארבעה צעדים (פונקציות שמתחילות ב-step_*).\nבצעד הראשון אנחנו משמיטים ערכים חסרים מהדאטה באמצעות step_na_omit. בדאטה שלנו תצפיות בעלות ערך חסר מכילות ערך חסר בכל המשתנים הרלוונטיים, ולכן בחרנו להשמיט אותן לגמרי. באופן כללי, בבעיות אחרות כדאי לנסות לזקוף ערכים חסרים על ידי שימוש בצעדים כגון step_impute_bag, step_impute_knn, step_impute_linear, ועוד לפני שמסירים את התצפיות לגמרי. ביצוע צעד של זקיפת נתונים יאפשר להתמודד עם חיזוי של תצפיות חדשות גם אם הן מגיעות עם ערך חסר, בעוד שצעד הסרה ימנע מאיתנו לספק תחזית.\nהצעד הבא, step_normalize, הופך את כל המשתנים המספריים (all_nominal_predictors()) למשתנים מנורמלים (כלומר בעלי תוחלת 0 וסטיית תקן 1). צעד זה גם ישמור את התוחלת וסטיית התקן המחושבת על קבוצת האימון, וישתמש בהן לנרמול של תצפיות חדשות בשלב החיזוי (חשבו למה).\nהצעד הבא, step_dummy,הופך משתנים מסוג מחרוזת או פקטור למשתני דמי (בעלי ערכי 0 או 1). במקרה שלנו אלו משתני סוג הפינגויין, האי שבו נמדדה התצפית, ומין הפינגויין (שכבר הומר למשתנה פקטור בתחילת הקוד לפני הפיצול הראשוני לקבוצות). ניתן לשים לב שהמשתנה אי התצפית פוצל לשני משתני דמי (במקור ישנן שלוש רמות Dream, Torgersen, ו-Biscoe, כאשר השניים הראשונים הם 0 המשמעות היא שהתצפית הגיעה מהשלישי), וכך גם המשתנה של סוג הפינגויין (שפוצל לשני משתני דמי Chinstrap, Gentoo, והשלישי Adelie אינו בדאטה ומשתמע מהשניים האחרים).\nהצעד step_selectמוריד את משתנה השנה (שמתעד מתי נמדדה התצפית). הנחת העבודה בהסרת המשתנה היא שהשנה שבה נמדדה התצפית ומין הפינגויינים אינם קשורים סטטיסטית (בהנחה שהתפלגות מין הפינגויינים נשארת קבועה בין השנים). הפעלת הפוקנציה מאוד דומה לפונקציה select שבה דנו בפרק הכנת הנתונים.\nהצעד האחרון שבחרנו לבצע הינו step_corr. צעד זה בוחן קורלציות בין המשתנים ובמידה והוא מזהה משתנה שבעל קורלציות גבוהות למשתנים אחרים, הוא מסיר אותו (במקרה זה לצעד זה אין השפעה, ואף משתנה אינו מוסר משום שאין מולטיקולינאריות, כפי שמיד נראה).\nנציין שרשימת הצעדים האפשריים גדולה במיוחד ומבוססת על best practices של הנדסת נתונים (כפי שנקראים בעגה המקצועית - feature engineering). מומלץ להיעזר ברשימת הצעדים המתעדכנת באתר הרשמי. כמו כן, תמיד ניתן להגדיר צעדים חדשים נוספים, לדוגמה על ידי שימוש ב-step_mutate להגדרת משתנה נוסף שהוא תוצאת חישוב של משתנים אחרים, או באופן מתקדם יותר על ידי פיתוח של פונקציה חדשה.\nעל מנת לבחון את תוצאת המתכון, ניתן להשתמש בפונקציות הכנה ואפייה, באופן הבא:\n\npenguin_recipe %&gt;% \n  prep() %&gt;% \n  bake(new_data = NULL) %&gt;% \n  glimpse()\n\nRows: 202\nColumns: 9\n$ bill_length_mm    &lt;dbl&gt; -0.9840664, -0.9096374, -0.7607792, -1.4306408, -0.9…\n$ bill_depth_mm     &lt;dbl&gt; 0.80436289, 0.16292440, 0.45897293, 1.10041142, 1.74…\n$ flipper_length_mm &lt;dbl&gt; -1.4871168, -1.1264954, -0.4773770, -0.6216255, -0.8…\n$ body_mass_g       &lt;dbl&gt; -0.59106931, -0.52806350, -1.22112735, -0.96910413, …\n$ sex               &lt;fct&gt; male, female, female, female, male, female, male, fe…\n$ species_Chinstrap &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ species_Gentoo    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ island_Dream      &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1…\n$ island_Torgersen  &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0…\n\n\nבאמצעות הפונקציה prep אנחנו מנחים את הפעלת הצעדים על בסיס קבוצת האימון, והפונקציה bake מריצה אותם בפועל. אולי זה נראה ככפילות מסוימת אבל בעצם יכלנו להריץ את bake על כל דאטה (כגון קבוצת הולידציה, קבוצת המבחן, או תצפיות חדשות לגמרי). אם מפעילים את bake עם new_data = NULL אז היא פשוט תפעיל הכל על קבוצת האימון.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  },
  {
    "objectID": "08-advanced-models.html#הגדרת-המודל",
    "href": "08-advanced-models.html#הגדרת-המודל",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.5 הגדרת המודל",
    "text": "8.5 הגדרת המודל\nהבעיה עמה אנחנו מתמודדים בפרק זה היא בעיית סיווג (classification), בהתאם לכך, ישנם מודלי סיווג שבאפשרותנו להשתמש בהם, כגון: רגרסיה לוגיסטית, עצי החלטה, יערות אקראיים, boosting, bagging, ועוד. כפי שציינו ניתן להתעמק במודלים השונים, בשני הספרים שצויינו בתחילת הפרק.\nנדגים הגדרה של שלושה מודלים שונים: רגרסיה לוגיסטית, יער אקראי, ו-boosting.\n\n# Logistic regression\npenguin_logistic &lt;- logistic_reg(\n  mode = \"classification\",\n  engine = \"glm\",\n)\n\n# Random forest\npenguin_forest &lt;- rand_forest(\n  mode = \"classification\",\n  engine = \"ranger\",\n  mtry = 3,\n  trees = 50,\n  min_n = 15)\n\n# Boosting\npenguin_boost &lt;- boost_tree(\n  mode = \"classification\",\n  engine = \"xgboost\")\n\nשימו לב לכמה נקודות מעניינות:\n\nעד כה כל הפעולות שעשינו היו זהות לכל המודלים (פיצול והכנת הדאטה), וזו הפעולה הראשונה שבה אנחנו מבחינים בין שלושה מודלים שונים. שלושת המודלים יקבלו את אותו הדאטה בשלב האימון. העוצמה הגדולה של tidymodels היא ביכולת שלה לאפשר לנו ממשק לחבילות מרובות (כפי שמיד נסביר, אנחנו מפעילים פה פונקציות מחבילות stats, ranger, ו-xgboost), תוך שימוש בשפה אחידה. במקור, לכל חבילה שבה אנחנו משתמשים בהגדרה לעיל יש ממשק שונה שצריך ללמוד אותו אם מפעילים ישירות את החבילות, אבל במקרה זה tidymodels מספקת לנו מעטפת אחידה.\nכל מודל מוגדר עם ארגומנט mode שמבחין בין בעיות סיווג לבעיות רגרסיה. במקרה זה אנחנו עובדים עם בעיית סיווג, ולכן הארגומנט הוגדר כ-mode = classification.\nבחבילת parsnip שהינה חבילה בתוך tidymodels ישנם ממשקים שונים להפעלת פונקציות מידול שונות, ובמקרה זה השתמשנו בשלושה ממשקים:\n\nהפונקציה logistic_reg שבאמצעות engine = \"glm\" הנחנו אותה לעבוד עם פונקציית glm (generalized linear models) שנמצאת בחבילת הבסיס stats. מעיון בתיעוד של logistic_reg תוכלו לראות שהיא מספקת ממשקים למעל עשר חבילות שונות של רגרסיה לוגיסטית (הכללות שונות של המודל הבסיסי או אלגוריתמים בעלי יעילות טובה יותר).\nהפונקציה rand_forest גם היא מספקת ממשקים לפוקנציות ואלגוריתמים שונים של יערות אקראיים, ובמקרה זה הנחנו את הפונקציה להוות ממשק לחבילת ranger.\nהפונקציה boost_tree שמייצרת מודלים המורכבים מהרבה תתי מודלים אחרים (ensemble), ובמקרה זה תעבוד כממשק לחבילת xgboost.\n\nכל פונקציית ממשק כזו תפעיל פונקציות מחבילות אחרות (בדוגמה שלנו מחבילת stats, ranger, ו-xgboost), ולכן עלינו לוודא שהתקנו את החבילות הנדרשות.\nפונקציות הממשק יודעות להעביר ארגומנטים שונים שרלוונטיים לפונקציות שהן מפעילות. לדוגמה לחבילת ranger אנחנו מעבירים את הארגומנט mtry = 3 שמסביר מכמה משתנים יש לבנות כל עץ שמשתתף ביער שלנו. עיון בתיעוד הפונקציות בחבילות של האלגוריתמים יראה אילו ארגומנטים קיימים.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  },
  {
    "objectID": "08-advanced-models.html#קריאה-נוספת",
    "href": "08-advanced-models.html#קריאה-נוספת",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.7 קריאה נוספת",
    "text": "8.7 קריאה נוספת\nלצורך קריאה והעמקה נוספת בתהליך המידול, מומלץ לקרוא את (Kuhn and Silge 2022) המפרט על השימוש בחבילת tidymodels עם דוגמאות רבות. הספר זמין באינטרנט.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  },
  {
    "objectID": "08-advanced-models.html#סיכום",
    "href": "08-advanced-models.html#סיכום",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.8 סיכום",
    "text": "8.8 סיכום\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד\n\n\n\n\n\nHastie, Trevor, Robert Tibshirani, and Jerome Friedman. 2009. The Elements of Statistical Learning. Springer New York. https://doi.org/10.1007/978-0-387-84858-7.\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2021. An Introduction to Statistical Learning. Springer US. https://doi.org/10.1007/978-1-0716-1418-1.\n\n\nKuhn, Max, and Julia Silge. 2022. Tidy Modeling with r. \" O’Reilly Media, Inc.\".",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  },
  {
    "objectID": "09-purrr.html#סידור-הדאטה",
    "href": "09-purrr.html#סידור-הדאטה",
    "title": "9  לולאות מיוחדות",
    "section": "9.1 סידור הדאטה",
    "text": "9.1 סידור הדאטה\nראשית ניקח את הדאטה, ונעביר אותו לפורמט עבודה נוח:\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\npenguins_nested &lt;- penguins %&gt;% \n  select(contains(\"mm\"), species, contains(\"mass\"), sex) %&gt;% \n  group_by(species) %&gt;% \n  nest()\n\nglimpse(penguins_nested)\n\nRows: 3\nColumns: 2\nGroups: species [3]\n$ species &lt;fct&gt; Adelie, Gentoo, Chinstrap\n$ data    &lt;list&gt; [&lt;tbl_df[152 x 5]&gt;], [&lt;tbl_df[124 x 5]&gt;], [&lt;tbl_df[68 x 5]&gt;]\n\n\nבעמודה האחרונה שנוצרה לנו בטבלת penguins_nested (שנקראת data), קיבלנו את הדאטה עבור כל אחד מסוגי הפינגויינים (זו למעשה טבלה בת שלוש שורות ושתי עמודות, העמודה השניה מכילה טבלאות עם המשתנים המקוריים שהיו בדאטה, למעט משתנה ה-Species).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>לולאות מיוחדות</span>"
    ]
  },
  {
    "objectID": "09-purrr.html#הדגמה-לבניית-מודלים",
    "href": "09-purrr.html#הדגמה-לבניית-מודלים",
    "title": "9  לולאות מיוחדות",
    "section": "9.2 הדגמה לבניית מודלים",
    "text": "9.2 הדגמה לבניית מודלים\nכעת נבנה מודל רגרסיה לינארית, לחיזוי bill_length_mm על בסיס כל יתר המשתנים:\n\npenguins_nested_lm &lt;- map(penguins_nested$data,\n                          function(x){lm(bill_length_mm ~ ., data = x)})\n\nכעת קיבלנו שלושה מודלים, הנה המודל הראשון:\n\nsummary(penguins_nested_lm[[1]])\n\n\nCall:\nlm(formula = bill_length_mm ~ ., data = x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-6.3921 -1.4294 -0.0276  1.4291  5.3977 \n\nCoefficients:\n                    Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       26.3151542  5.9906398   4.393 2.18e-05 ***\nbill_depth_mm     -0.0121755  0.1868468  -0.065   0.9481    \nflipper_length_mm  0.0388034  0.0305910   1.268   0.2067    \nbody_mass_g        0.0011487  0.0006183   1.858   0.0653 .  \nsexmale            2.1964106  0.5473780   4.013 9.71e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.124 on 141 degrees of freedom\n  (6 observations deleted due to missingness)\nMultiple R-squared:  0.3814,    Adjusted R-squared:  0.3639 \nF-statistic: 21.74 on 4 and 141 DF,  p-value: 5.464e-14\n\n\n\n\n\n\n\n\nתרגיל למחשבה\n\n\n\nנסו להריץ את הפקודה של בניית המודלים על הדאטה אך מבלי שמבוצעת בו הבחירה:\nselect(contains(\"mm\"), species, contains(\"mass\"), sex)\nמתקבלת הודעת שגיאה. איזה משתנה יצר את הבעיה ומדוע?\n\n\n\n\n\n\n\n\nצורות נוספות להגדרת פונקציה\n\n\n\nשימו לב שבתוך פקודת ה-map הגדרנו את הפונקציה בארגומנט השני, בתוך הקוד “inline”.\nניתן היה להגדיר פונקציה מחוץ ל-map ואז פשוט להכניס את השם שלה, כך:\n\ncreate_model &lt;- function(x){lm(bill_length_mm ~ ., data = x)}\npenguins_nested_lm &lt;- map(penguins_nested$data, create_model)\n\nכמו כן, סינטקס נוסף להגדרת פונקציות ב-“inline” הוא שימוש בתו ~, באופן הבא:\n\npenguins_nested_lm &lt;- map(penguins_nested$data,\n                          ~ {lm(bill_length_mm ~ ., data = .x)})\n\nשימו לב בחלק השני לשימוש ב-.x אשר מסמל בהגדרה זו היכן יש להכניס את הרכיב עצמו מתוך האובייקט עליו מבצעים את הלולאה.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>לולאות מיוחדות</span>"
    ]
  },
  {
    "objectID": "09-purrr.html#סידור-תוצאות-המודלים",
    "href": "09-purrr.html#סידור-תוצאות-המודלים",
    "title": "9  לולאות מיוחדות",
    "section": "9.3 סידור תוצאות המודלים",
    "text": "9.3 סידור תוצאות המודלים\nניתן להשתמש בפקודה broom::tidy על מנת לקבל את תוצאות הפקודה באופן מסודר. במקרה זה נשתמש בסינטקס מלא של tidyverse ונטמיע את השימוש בפקודה map בתוך פקודת mutate שמופעלת על עמודת ה-data שראינו קודם.\n\npenguins_nested_lm_tidy &lt;- penguins_nested %&gt;% \n  mutate(linear_model_res = map(data, \n                                function(x){\n                                  lm(bill_length_mm ~ ., data = x) %&gt;% \n                                    broom::tidy()\n                                  })) %&gt;% \n  unnest(linear_model_res)\n\npenguins_nested_lm_tidy\n\n# A tibble: 15 × 7\n# Groups:   species [3]\n   species   data               term        estimate std.error statistic p.value\n   &lt;fct&gt;     &lt;list&gt;             &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n 1 Adelie    &lt;tibble [152 × 5]&gt; (Intercept) 26.3      5.99        4.39   2.18e-5\n 2 Adelie    &lt;tibble [152 × 5]&gt; bill_depth… -0.0122   0.187      -0.0652 9.48e-1\n 3 Adelie    &lt;tibble [152 × 5]&gt; flipper_le…  0.0388   0.0306      1.27   2.07e-1\n 4 Adelie    &lt;tibble [152 × 5]&gt; body_mass_g  0.00115  0.000618    1.86   6.53e-2\n 5 Adelie    &lt;tibble [152 × 5]&gt; sexmale      2.20     0.547       4.01   9.71e-5\n 6 Gentoo    &lt;tibble [124 × 5]&gt; (Intercept)  0.611    8.64        0.0707 9.44e-1\n 7 Gentoo    &lt;tibble [124 × 5]&gt; bill_depth…  0.674    0.339       1.99   4.90e-2\n 8 Gentoo    &lt;tibble [124 × 5]&gt; flipper_le…  0.133    0.0466      2.86   5.11e-3\n 9 Gentoo    &lt;tibble [124 × 5]&gt; body_mass_g  0.00150  0.000727    2.07   4.09e-2\n10 Gentoo    &lt;tibble [124 × 5]&gt; sexmale      0.525    0.731       0.719  4.74e-1\n11 Chinstrap &lt;tibble [68 × 5]&gt;  (Intercept) 29.4     10.8         2.72   8.49e-3\n12 Chinstrap &lt;tibble [68 × 5]&gt;  bill_depth…  0.807    0.410       1.97   5.36e-2\n13 Chinstrap &lt;tibble [68 × 5]&gt;  flipper_le… -0.00532  0.0573     -0.0929 9.26e-1\n14 Chinstrap &lt;tibble [68 × 5]&gt;  body_mass_g  0.00114  0.00106     1.07   2.88e-1\n15 Chinstrap &lt;tibble [68 × 5]&gt;  sexmale      2.75     0.889       3.09   2.94e-3\n\n\nבתוצאת הטבלה ניתן לראות 15 שורות, עבור כל מין של פינגויינים יש חמש שורות כאשר כל שורה מתייחסת לערכיו של משתנה ספציפי (מקדם, טעות תקן, ערך הסטטיסטי, ורמת מובהקות). ניתן לסדר את הטבלה לפורמט רחב באופן הבא, נניח שיציג מקדמים ורמת מובהקות בלבד:\n\npenguins_nested_lm_tidy_wide &lt;- penguins_nested_lm_tidy %&gt;% \n  select(species, term, estimate, p.value) %&gt;% \n  pivot_wider(id_cols = species, names_from = term, values_from = c(estimate, p.value))\n\npenguins_nested_lm_tidy_wide\n\n# A tibble: 3 × 11\n# Groups:   species [3]\n  species   `estimate_(Intercept)` estimate_bill_depth_mm estimate_flipper_len…¹\n  &lt;fct&gt;                      &lt;dbl&gt;                  &lt;dbl&gt;                  &lt;dbl&gt;\n1 Adelie                    26.3                  -0.0122                0.0388 \n2 Gentoo                     0.611                 0.674                 0.133  \n3 Chinstrap                 29.4                   0.807                -0.00532\n# ℹ abbreviated name: ¹​estimate_flipper_length_mm\n# ℹ 7 more variables: estimate_body_mass_g &lt;dbl&gt;, estimate_sexmale &lt;dbl&gt;,\n#   `p.value_(Intercept)` &lt;dbl&gt;, p.value_bill_depth_mm &lt;dbl&gt;,\n#   p.value_flipper_length_mm &lt;dbl&gt;, p.value_body_mass_g &lt;dbl&gt;,\n#   p.value_sexmale &lt;dbl&gt;\n\nglimpse(penguins_nested_lm_tidy_wide)\n\nRows: 3\nColumns: 11\nGroups: species [3]\n$ species                    &lt;fct&gt; Adelie, Gentoo, Chinstrap\n$ `estimate_(Intercept)`     &lt;dbl&gt; 26.3151542, 0.6106378, 29.3903439\n$ estimate_bill_depth_mm     &lt;dbl&gt; -0.01217552, 0.67352164, 0.80659313\n$ estimate_flipper_length_mm &lt;dbl&gt; 0.038803444, 0.133148448, -0.005321531\n$ estimate_body_mass_g       &lt;dbl&gt; 0.001148724, 0.001504786, 0.001138851\n$ estimate_sexmale           &lt;dbl&gt; 2.196411, 0.525357, 2.752421\n$ `p.value_(Intercept)`      &lt;dbl&gt; 2.184163e-05, 9.437902e-01, 8.492353e-03\n$ p.value_bill_depth_mm      &lt;dbl&gt; 0.94813641, 0.04901556, 0.05364594\n$ p.value_flipper_length_mm  &lt;dbl&gt; 0.206723627, 0.005109499, 0.926275133\n$ p.value_body_mass_g        &lt;dbl&gt; 0.06529386, 0.04085049, 0.28771299\n$ p.value_sexmale            &lt;dbl&gt; 9.707824e-05, 4.738359e-01, 2.935314e-03",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>לולאות מיוחדות</span>"
    ]
  },
  {
    "objectID": "09-purrr.html#הדגמה-לויזואליזציות",
    "href": "09-purrr.html#הדגמה-לויזואליזציות",
    "title": "9  לולאות מיוחדות",
    "section": "9.4 הדגמה לויז’ואליזציות",
    "text": "9.4 הדגמה לויז’ואליזציות\nכעת נדגים יצירה של ויז’ואליזציות עבור התפלגות שאריות המודלים, גם תוך שימוש ב-map.\nראשית נגדיר פונקציה אשר מייצרת ויז’ואליזציה לשאריות בהתבסס על המודל. ראינו דוגמה כזו בפרק 7:\n\nplot_residuals &lt;- function(lm_res){\n  ggplot(tibble(resid = lm_res$residuals)) + \n    geom_qq(aes(sample = resid)) + \n    ggtitle(\"Model Residuals qq-plot\")\n}\n\nכעת, נריץ את הפונקציה על כל אחד מהמודלים שקיבלנו, תוך שימוש בפונקציה map:\n\npenguins_nested_resid_plots &lt;- map(penguins_nested_lm,\n                                   plot_residuals)\n\npenguins_nested_resid_plots\n\n[[1]]\n\n\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nתרגיל: הצגת התפלגות השאריות בתרשים אחד\n\n\n\nכתבו קוד, תוך שימוש ב-map לצורך סידור השאריות של המודלים, על מנת לייצר את התרשים הבא:",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>לולאות מיוחדות</span>"
    ]
  },
  {
    "objectID": "09-purrr.html#פונקציות-נוספות-בחבילת-purrr",
    "href": "09-purrr.html#פונקציות-נוספות-בחבילת-purrr",
    "title": "9  לולאות מיוחדות",
    "section": "9.5 פונקציות נוספות בחבילת purrr",
    "text": "9.5 פונקציות נוספות בחבילת purrr\nפונקצית map היא אולי בין הפונקציות השימושיות ביותר בחבילת purrr, אך ישנן מספר פונקציות נוספות שימושיות:\n\nהפונקציה walk שימושית כאשר רוצים להריץ לולאה לא בשביל תוצאת החישוב אלא בשביל הפעולה של הפונקציה. לדוגמה, במקרה שרוצים להפיק דוחות מרובים של RMarkdown, או אם נניח רוצים לשלוח הרבה מיילים באוטומציה (הפונקציה הבסיסית שולחת מייל והוקטור עליו רצים הוא וקטור של כתובות מייל);\nהפונקציה map2 והפונקציה pmap מאפשרות להריץ לולאה על פני מספר רכיבים. הלולאה רצה על השילובים הקיימים של הרכיבים לפי הסדר (אבל לא על ההצלבה ביניהם);\nפונקציה נוספת שימושית היא list_rbind כאשר הפונקציה map מחזירה רשימה שבה רכיבים בודדים ורוצים להפוך אותה לוקטור של ערכים (לדוגמה, כחלק מסינטקס של tidyverse);\nארגומנט נוסף שימושי בפונקציה map הוא progress המאפשר להציג את ההתקדמות של הלולאה (“progress bar”). מספיק להוסיף ארגומנט progress=True והפקודה תציג את ההתקדמות, בהנחה שהפעולה לוקחת מספיק זמן.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>לולאות מיוחדות</span>"
    ]
  },
  {
    "objectID": "09-purrr.html#סיכום",
    "href": "09-purrr.html#סיכום",
    "title": "9  לולאות מיוחדות",
    "section": "9.6 סיכום",
    "text": "9.6 סיכום\nבפרק זה למדנו על השימוש בחבילת purrr ובפרט בפונקציה map בחבילה זו. השימוש בחבילה זו מאפשר לנו לבנות לולאות אשר נראות מסודרות יותר מלולאות for, בעלות פוטנציאל לרוץ מהר יותר, ומשתלבות יפה בסינטקס של tidyverse. בפרק ראיתם “טעימה קטנה” מהשימוש בפונקציות, אך ככל שתיתקלו במקרים כאלו ותנסו את הפונקציות הללו תיווכחו לראות שהן מועילות מאוד. נדרש קצת זמן להתרגל אליהן, אך זה שווה את המאמץ.\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>לולאות מיוחדות</span>"
    ]
  },
  {
    "objectID": "10-hebrew-in-R.html#שימוש-ב-ide",
    "href": "10-hebrew-in-R.html#שימוש-ב-ide",
    "title": "10  עברית ב-R",
    "section": "10.1 שימוש ב-IDE",
    "text": "10.1 שימוש ב-IDE\nה-IDE הנפוץ לשימוש ב-R הוא RStudio IDE (סביבת פיתוח - Integrated Development Environment). שילוב של עברית ב-IDE דורש קצת מיומנות והתרגלות, לדוגמה, כך נראית כתיבת שורות אלו ב-IDE:\n\n\n\nכתיבה בעברית ב-RStudio IDE\n\n\nכפי שניתן לראות, למרות שהשורות עצמן בספר מיושרות לימין (כמו שצריך בעברית), בכעת הכתיבה השורות לא מיושרות, וסדר המשפט מתהפך כאשר משלבים עברית ואנגלית. בחלק השלישי של הפרק נסביר איך “קורה הקסם” שהתוצר עצמו כן מיושר לימין. אבל הנה כמה טיפים שיעזרו לכם לשלב עברית בעבודה השוטפת עם RStudio:\n\nעבודה עם ה-Visual Editor: בכתיבת מסמכים (מסוג RMarkdown או quarto) לעבוד עם ה-Visual editor במקום ה-Source editor (בצד שמאל למעלה בחירה ב-Visual). איכשהו, העורך הויזואלי מצליח לסדר קצת יותר טוב את העברית, ובמקרה ונדרש לערוך מסמך, מצליח לשים את הסמן במקום הנכון. בצילום המסך הבא מוצג עורך קוד המקור (באדום מסומן הכפתור שמאפשר לעבור לעורך הויזואלי). אם תנסו לשים את הסמן במקום המתאים בעורך קוד המקור תראו שהוא מציב את הסמן במקום הלא נכון.\n\n\n\n\nמעבר לעורך ויזואלי\n\n\nלצערנו, העורך הויזואלי זמין רק במסמכים מסוג RMarkdown ו-quarto. בכתיבת סקריפט רגיל (קובץ קוד בלבד עם סיומת .R), חייבים להשתמש בעורך קוד המקור, מה שמוביל אותנו לנקודה השניה:\n\nשימוש בשבירת שורות כשנדרש לשלב עברית בקוד: כאשר כותבים קוד ונדרש לשלב עברית, עדיף לשבור שורה (בכתיבת קוד לרוב שבירת שורה לא משפיעה על הפונקציונליות של הקוד), ואת העברית לשים בשורה נפרדת. זה יקל על עריכת הקוד במידה וצריך. לדוגמה, הקוד הבא מכיל שבירת שורה, ולכן יקל על עריכות במידה ונדרשות:\n\n\nlibrary(tidyverse)\n\n\nmy_table %&gt;% \n  filter(my_var == \n           \"המשתנה שלי\")\n\nבמקום הקוד:\n\nmy_table %&gt;% \n  filter(my_var == \"המשתנה שלי\")\n\n\nשמירת קבצים באנגלית: תעשו לעצמכם ולאחרים טובה, ולכל הקבצים (והתיקיות) תתנו שמות באנגלית ולא בעברית.\nשמות משתנים באנגלית: אם יש לכם קובץ נתונים שבו שמות המשתנים (הכותרות) הם בעברית, מומלץ להעביר את כולם לאנגלית, לעבוד באנגלית, ואם צריך להעביר לעברית בסוף (לצורך דיווח ו/או תרשימים). יש דרכים שונות להחליף שמות, לדוגמה הגדרה בתוך הפקודה שקוראת את הקובץ. הפקודה read_csv ו-readxl::read_excel תומכות שתיהן בארגומנט שנקרא col_names ומאפשר להגדיר שמות (אבל השימוש בארגומנט מניח שסדר העמודות עקבי וידוע מראש). הדוגמה הבאה מחליפה שמות של עמודות באמצעות הפקודה rename, שמגדירה שם של עמודה באופן מדויק, גם אם הסדר שלהן אינו לפי סדר ההגדרה.\n\n\ninit_tbl &lt;- tibble(`שם` = \n                     c(\"איתן\",\n                       \"נעמי\",\n                       \"אביב\"),\n                   `גיל` = \n                     c(11, 9, 5))\n\n\n\ninit_tbl\n\n# A tibble: 3 × 2\n  שם      גיל\n  &lt;chr&gt; &lt;dbl&gt;\n1 איתן     11\n2 נעמי      9\n3 אביב      5\n\n\n\n\ninit_tbl %&gt;% \n  rename(age = `גיל`,\n         name = `שם`)\n\n# A tibble: 3 × 2\n  name    age\n  &lt;chr&gt; &lt;dbl&gt;\n1 איתן     11\n2 נעמי      9\n3 אביב      5\n\n\nשימו לב אגב שבפלט הטקסט בעברית מופיע הפוך, אבל העתיקו את הקוד ונסו. ניתן להשתמש בפקודה View על מנת לראות את התוצר הסופי בצורה מסודרת (פשוט הוסיפו %&gt;% View() בסוף השורה האחרונה של הקוד).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>עברית ב-R</span>"
    ]
  },
  {
    "objectID": "10-hebrew-in-R.html#קידוד-קבצים",
    "href": "10-hebrew-in-R.html#קידוד-קבצים",
    "title": "10  עברית ב-R",
    "section": "10.2 קידוד קבצים",
    "text": "10.2 קידוד קבצים\nקבצי טקסט בפורמטים שונים (כגון txt או csv) יכולים להכיל אינדיקציה לקידוד, שמאפשרת לתוכנות שונות (ביניהן R ו-Excel) להבין איך לפתוח את הקובץ כך שניתן יהיה לקרוא אותו באופן תקין.\n\n10.2.1 קריאת קבצים\nנתייחס לפקודת read_csv (פקודות אחרות בחבילת readr עובדות באופן דומה). כברירת מחדל, הפקודה תצליח לקרוא טוב קבצים ששמורים עם קידוד של UTF-8, ולרוב הקבצים זה מספיק.\nבמידה והקריאה אינה עובדת, ניתן להיעזר בפקודה guess_encoding גם היא מחבילת readr.\nלדוגמה:\n\nguess_encoding(\"files/utf8_encoding_example_file.csv\")\n\n# A tibble: 2 × 2\n  encoding confidence\n  &lt;chr&gt;         &lt;dbl&gt;\n1 UTF-8          1   \n2 KOI8-R         0.98\n\n\nניתן לראות שהפקודה guess_encoding מצליחה לזהות שהקידוד הוא UTF-8, וקריאה “רגילה” של הקובץ (בלי ארגומנטים מיוחדים) תצליח:\n\n\nread_csv(\"files/utf8_encoding_example_file.csv\")\n\n# A tibble: 2 × 1\n  שלום \n  &lt;chr&gt;\n1 יום  \n2 טוב  \n\n\n\nלעומת זאת, הקובץ הבא מקודד בקידוד אחר (קידוד iso8859-8), הפקודה guess_encoding מזהה קידוד שגוי, והשימוש בו לא יניב תוצאות רצויות:\n\nguess_encoding(\"files/iso8859-8_encoding_example_file.csv\")\n\n# A tibble: 1 × 2\n  encoding     confidence\n  &lt;chr&gt;             &lt;dbl&gt;\n1 windows-1251        0.5\n\nread_csv(\"files/iso8859-8_encoding_example_file.csv\", \n         locale = locale(encoding = \"windows-1251\"))\n\n# A tibble: 2 × 1\n  щмен \n  &lt;chr&gt;\n1 йен  \n2 иеб  \n\n\nהקובץ הראשון מקודד ב-UTF-8 ולכן שימוש פשוט בפקודה read_csv קורא אותו באופן תקין. הקובץ השני שמור בפורמט ISO-8859-8 (והפקודה גם לא מצליחה “לנחש” אותו), ולכן יותר מאתגר לקרוא אותו בלי ידע מוקדם על הקידוד. הפעלת פקודת הקריאה על הקובץ השני מבלי הגדרה מתאימה של הקידוד, תציג טקסט שגוי או הודעת שגיאה של Error: Invalid multibyte sequence. הטקסט בעברית בדוגמאות להלן יופיע משמאל לימין (הפוך), אבל אם תנסו להריץ אותו ב-R תראו שהנתונים נקראים באופן תקין, בפקודה הראשונה והשלישית להלן:\n\n\nread_csv(\"files/iso8859-8_encoding_example_file.csv\", \n         locale = locale(encoding = \"ISO-8859-8\"))\n\n# A tibble: 2 × 1\n  שלום \n  &lt;chr&gt;\n1 יום  \n2 טוב  \n\n\n\nלידיעה, יש מספר פורמטים רלוונטיים לקריאת עברית, הראשונים שאני ממליץ לנסות הם UTF-8 (כלומר בלי ארגומנטים מיוחדים), אחריו Windows-1255, ואחריו ISO-8859-8, כמובן תוך שילוב הפקודה guess_encoding שיכולה להיות שימושית לעיתים.\n\n\n10.2.2 שמירת קבצים\nעל מנת לשמור קבצים עם קידוד, מומלץ להשתמש בפקודה write_excel_csv במקום הפקודה write_csv, במיוחד אם מתכננים לקרוא את הקובץ שנשמר באמצעות אקסל. הפקודה של write_excel_csv כוללת “הנחיות קידוד” כך שפתיחה באקסל תציג עברית באופן תקין (התוצר הוא עדיין קובץ טקסט). לעומת זאת, שמירה של write_csv עם נתונים בעברית, תציג ג’יבריש בעת פתיחת אקסל רגילה (אגב, אפשר לייבא נתונים באקסל ולהגדיר UTF-8 כקידוד, ואז ניתן לקרוא גם קבצים כאלו באופן תקין).\n\n\n\n\n\n\nNote\n\n\n\nפורמט אקסל (קובץ xlsx) הוא פורמט נוח מבחינת קידוד, משום שהוא שומר את הקידוד באופן מובנה. עם זאת, הוא פורמט פחות נוח לעבודה בהרבה מקרים. ניתן לקרוא קבצי אקסל באמצעות readxl::read_excel ואז לא צריך להתעסק עם קידוד. שמירה של קבצי אקסל תיעשה באמצעות אחת מהפקודות הבאות openxlsx::write.xlsx או writexl::write_xlsx.\nלא נכביר במילים על הבעיות שיש עם אקסל וקבצי דאטה, אבל לא חסרות כאלו (לדוגמה, ההתייחסות של אקסל לכל דבר שרק “נראה כמו תאריך” כתאריך, הגמישות לתת למשתמשים להפוך את הקובץ ל-untidy כמו לדוגמה על ידי מיזוג תאים, או קידוד משמעויות שונות באמצעות צביעה, מה שכמובן מקשה על עבודת מדען הנתונים).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>עברית ב-R</span>"
    ]
  },
  {
    "objectID": "10-hebrew-in-R.html#יישור-לימין",
    "href": "10-hebrew-in-R.html#יישור-לימין",
    "title": "10  עברית ב-R",
    "section": "10.3 יישור לימין",
    "text": "10.3 יישור לימין\nתוצרים ב-R המבוססים על html, קרי, מסמכים שהם תוצר של RMarkdown, quarto, ואפליקציות shiny, יציגו עברית בכיוון הפוך (משמאל לימין), אלא אם יוגדר להם עיצוב מתאים.\nעיצוב ב-html נשלט על ידי קוד CSS (Cascade Style Sheet). לדוגמה, לספר זה יש עיצוב המוגדר בקובץ style.css ובו מופיע (בין היתר) הקוד הבא:\n\nbody {\n  direction: rtl;\n}\n\nהקוד שולט בכל התגיות שנמצאות בתוך גוף המסמך (תגיות html שמופיעות בין &lt;body&gt; לבין התגית הסוגרת &lt;/body&gt;. התכונה אותה אנחנו רוצים לעדכן נקראת כיוון (direction), והוא יכול לקבל שני ערכים (כברירת מחדל שמאל לימין ltr, ובאמצעות הקוד אנחנו משנים אותו ל-rtl.\nבשביל להטמיע זאת במסמך quarto או RMarkdown רק צריך להוסיף את הקוד הבא במסמך:\n```{css}\nbody {\n   direction: rtl;\n}\n```\nניתן לקרוא מידע נוסף לגבי שילוב CSS במקורות הבאים:\n\nלגבי שימוש ב-CSS במסמכי quarto\n\nquarto.org\n\nשילוב CSS במסמכי RMarkdown\n\n(Xie, Allaire, and Grolemund 2018)\n\nשילוב CSS באפליקציות Shiny\n\n(Wickham 2021)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>עברית ב-R</span>"
    ]
  },
  {
    "objectID": "10-hebrew-in-R.html#סיכום",
    "href": "10-hebrew-in-R.html#סיכום",
    "title": "10  עברית ב-R",
    "section": "10.4 סיכום",
    "text": "10.4 סיכום\nבפרק זה למדנו טיפים וטריקים שיעזרו לנו בפרויקטים בהם עלינו לשלב עברית ואנגלית. בפרט:\n\nשימוש בסביבת הפיתוח RStudio תוך שילוב עברית.\nקידודים של קבצים בעברית (בקריאה ובכתיבה של קבצים).\nיישור לימין בתוצרי ניתוח שכוללים html, באמצעות שימוש ב-CSS.\n\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד\n\n\n\n\n\nWickham, Hadley. 2021. Mastering Shiny. \"O’Reilly Media, Inc.\".\n\n\nXie, Yihui, Joseph J Allaire, and Garrett Grolemund. 2018. R Markdown: The Definitive Guide. CRC Press.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>עברית ב-R</span>"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "על הכותב",
    "section": "",
    "text": "כותב הספר הוא ד”ר עדי שריד, מנכ”ל מכון שריד. לעדי יש דוקטורט מטעם המחלקה להנדסת תעשייה באוניברסיטת תל-אביב, תואר שני בחקר ביצועים מאוניברסיטת תל-אביב, ותואר ראשון במתמטיקה עם סטטיסטיקה וחקר ביצועים מהטכניון.\nעדי לימד ומלמד R במגוון מסגרות: באוניברסיטה במסגרת קורסים כגון מבוא לסטטיסטיקה, ניתוח נתונים, וקורסים פרטיים במכללות ובחברות הייטק. את הניסיון בהכשרה בלימוד R מביא איתו עדי לספר הנוכחי שנועד לתת מענה ללומדים את R ששפת האם שלהם היא עברית.\nלפרטים נוספים adisarid.github.io.\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד",
    "crumbs": [
      "על הכותב"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "מקורות",
    "section": "",
    "text": "Hastie, Trevor, Robert Tibshirani, and Jerome Friedman. 2009. The\nElements of Statistical Learning. Springer New York. https://doi.org/10.1007/978-0-387-84858-7.\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani.\n2021. An Introduction to Statistical Learning. Springer US. https://doi.org/10.1007/978-1-0716-1418-1.\n\n\nKuhn, Max, and Julia Silge. 2022. Tidy Modeling with r. \"\nO’Reilly Media, Inc.\".\n\n\nMurray, Lori L., and John G. Wilson. 2021. “Generating Data Sets\nfor Teaching the Importance of Regression Analysis.” Decision\nSciences Journal of Innovative Education 19 (2): 157–66. https://doi.org/10.1111/dsji.12233.\n\n\nSimpson, E. H. 1951. “The Interpretation of Interaction in\nContingency Tables.” Journal of the Royal Statistical\nSociety: Series B (Methodological) 13 (2): 238–41. https://doi.org/10.1111/j.2517-6161.1951.tb00088.x.\n\n\nWalpole, Ronald E, Raymond H Myers, Sharon L Myers, and Keying Ye. 1993.\nProbability and Statistics for Engineers and Scientists. Vol.\n5. Macmillan New York.\n\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.”\nJournal of Computational and Graphical Statistics 19 (1): 3–28.\nhttps://doi.org/10.1198/jcgs.2009.07098.\n\n\n———. 2021. Mastering Shiny. \"O’Reilly Media, Inc.\".\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. \"O’Reilly\nMedia, Inc.\".\n\n\nXie, Yihui, Joseph J Allaire, and Garrett Grolemund. 2018. R\nMarkdown: The Definitive Guide. CRC Press.\n\n\n\n\n\nהמדריך העברי למשתמש ב-R נכתב על ידי עדי שריד בהוצאת מכון שריד",
    "crumbs": [
      "מקורות"
    ]
  },
  {
    "objectID": "08-advanced-models.html#הגדרת-תהליך-ובניית-המודל",
    "href": "08-advanced-models.html#הגדרת-תהליך-ובניית-המודל",
    "title": "8  מודלים מונחים (Supervised)",
    "section": "8.6 הגדרת תהליך ובניית המודל",
    "text": "8.6 הגדרת תהליך ובניית המודל\nכעת, על מנת להפעיל את האלגוריתמים השונים לצורך בניית המודלים, נגדיר תהליך בניה ונבנה את המודל בפועל באופן הבא:\n\npenguin_workflow &lt;- workflow() %&gt;% \n  add_recipe(penguin_recipe)\n\npenguin_logistic_fit &lt;- penguin_workflow %&gt;% \n  add_model(penguin_logistic) %&gt;% \n  fit(data = penguin_train)\n\npenguin_forest_fit &lt;- penguin_workflow %&gt;% \n  add_model(penguin_forest) %&gt;% \n  fit(data = penguin_train)\n\npenguin_boost_fit &lt;- penguin_workflow %&gt;% \n  add_model(penguin_boost) %&gt;% \n  fit(data = penguin_train)\n\nלפעמים מודל הוא “קופסה שחורה” ולא ניתן להתעמק בו (לדוגמה, מודלי למידה עמוקה, ובפרט מודלי שפה כגון ChatGPT הם קופסה שחורה, בהיבט שקשה לחקור את המודל אך קל לחזות בתוצאותיו).\nעם זאת, לעיתים ההתעמקות בתכונות של מודל יכולה לשפוך אור על הקשר שבין המשתנים (כפי שראינו בפרק 7. לשם כך עומדות לרשותנו פונקציות שונות המאפשרות לחלץ את המודל וללמוד את תכונותיו. נדגים חקירה של מודל הרגרסיה הלוגיסטית ושל מודל ה-Boosting.\n\n8.6.1 חקירה של מודל הרגרסיה הלוגיסטית\n\npenguin_logistic_fit %&gt;% \n  extract_fit_engine() %&gt;% \n  summary()\n\n\nCall:\nstats::glm(formula = ..y ~ ., family = stats::binomial, data = data)\n\nDeviance Residuals: \n     Min        1Q    Median        3Q       Max  \n-2.43129  -0.11622   0.00025   0.08380   1.91482  \n\nCoefficients:\n                  Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)         5.5290     2.0516   2.695 0.007038 ** \nbill_length_mm      3.6218     1.0946   3.309 0.000937 ***\nbill_depth_mm       5.2068     1.1981   4.346 1.39e-05 ***\nflipper_length_mm   1.1352     0.9808   1.157 0.247127    \nbody_mass_g         4.7404     1.1783   4.023 5.75e-05 ***\nspecies_Chinstrap -10.1236     2.8951  -3.497 0.000471 ***\nspecies_Gentoo     -8.4531     3.9707  -2.129 0.033266 *  \nisland_Dream        0.9403     1.2745   0.738 0.460635    \nisland_Torgersen   -1.1217     1.2315  -0.911 0.362387    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 280.012  on 201  degrees of freedom\nResidual deviance:  62.504  on 193  degrees of freedom\nAIC: 80.504\n\nNumber of Fisher Scoring iterations: 8\n\n\nהפלט דומה לפלט הפקודה summary כאשר מריצים אותה על מודל הרגרסיה הלינארית שראינו בפרק הקודם אך עם מספר הבדלים, לדוגמה:\n\nבמקום Residuals אנחנו רואים Deviance Residuals (חישוב שונה של שאריות המבוסס על פונקציית נראות במקום הפרש בין ערך התצפית בפועל לערך החזוי של התצפית).\nבמקום מבחן F וערך של \\(R^2\\) אנחנו רואים ערך של AIC (Akaike Information Criteria) - קריטריון אחר המאפשר להשוות בין מודלים.\nמשמעות המקדמים שונה (Estimate): ברגרסיה לוגיסטית, האקספוננט של המקדם הוא ה-Odds Ratio, כלומר פי כמה שינוי של יחידה במשתנה המסביר מעלה את הסבירות לשינוי הסיווג.\n\nTODO: להוסיף הסבר על משמעות המקדמים.\nמומלץ להעמיק בתכונות הרגרסיה הלוגיסטית, לדוגמה בספר של Hastie, Tibshirani, and Friedman (2009).\n\n\n8.6.2 חקירה של מודל ה-Boosting\nלהלן חקירה של מודל ה-boosting\n\npenguin_boost_fit %&gt;% \n  extract_fit_engine()\n\n##### xgb.Booster\nraw: 23.2 Kb \ncall:\n  xgboost::xgb.train(params = list(eta = 0.3, max_depth = 6, gamma = 0, \n    colsample_bytree = 1, colsample_bynode = 1, min_child_weight = 1, \n    subsample = 1), data = x$data, nrounds = 15, watchlist = x$watchlist, \n    verbose = 0, nthread = 1, objective = \"binary:logistic\")\nparams (as set within xgb.train):\n  eta = \"0.3\", max_depth = \"6\", gamma = \"0\", colsample_bytree = \"1\", colsample_bynode = \"1\", min_child_weight = \"1\", subsample = \"1\", nthread = \"1\", objective = \"binary:logistic\", validate_parameters = \"TRUE\"\nxgb.attributes:\n  niter\ncallbacks:\n  cb.evaluation.log()\n# of features: 8 \nniter: 15\nnfeatures : 8 \nevaluation_log:\n    iter training_logloss\n       1       0.50831836\n       2       0.40351493\n---                      \n      14       0.08797671\n      15       0.08282136\n\npenguin_boost_fit %&gt;% \n  extract_fit_engine()\n\n##### xgb.Booster\nraw: 23.2 Kb \ncall:\n  xgboost::xgb.train(params = list(eta = 0.3, max_depth = 6, gamma = 0, \n    colsample_bytree = 1, colsample_bynode = 1, min_child_weight = 1, \n    subsample = 1), data = x$data, nrounds = 15, watchlist = x$watchlist, \n    verbose = 0, nthread = 1, objective = \"binary:logistic\")\nparams (as set within xgb.train):\n  eta = \"0.3\", max_depth = \"6\", gamma = \"0\", colsample_bytree = \"1\", colsample_bynode = \"1\", min_child_weight = \"1\", subsample = \"1\", nthread = \"1\", objective = \"binary:logistic\", validate_parameters = \"TRUE\"\nxgb.attributes:\n  niter\ncallbacks:\n  cb.evaluation.log()\n# of features: 8 \nniter: 15\nnfeatures : 8 \nevaluation_log:\n    iter training_logloss\n       1       0.50831836\n       2       0.40351493\n---                      \n      14       0.08797671\n      15       0.08282136",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>מודלים מונחים (Supervised)</span>"
    ]
  }
]