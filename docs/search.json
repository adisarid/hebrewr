[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "המדריך העברי למשתמש ב-R",
    "section": "",
    "text": "R שפה נפלאה, היא התחילה כשפה סטטיסטית, וגם כיום זה השימוש המרכזי שלה. בפועל אפשר לעשות בה כמעט הכל. החל מניתוח נתונים ועד בניית אפליקציות ואוטומציות מורכבות. אצלנו בעסק (מכון שריד) אנחנו משתמשים ב-R לניתוח נתונים, הצגת תוצאות עם דשבורדים בזמן אמת, הפקת דוחות Power Point בלחיצת כפתור, אוטומציות של תהליכים שונים בעסק, ועוד הרבה - היא הפכה לכלי עבודה שימושי והחליפה הרבה מאוד מהדברים שהיינו עושים בעבר עם כלים אחרים.\nללומדים את השפה יש מקורות רבים ומגוונים - ספרים, סרטוני YouTube, בלוגים, ועוד. העניין הוא שרוב המקורות שישנם כתובים באנגלית. זה מה שהביא אותי לכתוב את הספר הזה, ולעזור לקהל הקוראים שיותר נוח לו ללמוד R בעברית.\nהתוכן שבספר שלפניכם מבוסס על מספר קורסים שלימדתי בשנים האחרונות, כולל הכשרות מקצועיות בחברות סטארטאפ, וקורסי לימוד לתואר ראשון שנתתי באוניברסיטה.\nלמי מיועד הספר?\nהספר מיועד לאנשים שמתחילים ללמוד את R, סטודנטים או כאלו שעוברים מכלי סטטיסטי אחר.\nהספר מתאים גם לכאלו שיודעים R ברמה בינונית ורוצים לחזק את הבסיס, או כאלו שרוצים להשתפשף בידיעות שלהם על החבילות שנלמדות בספר (כמו tidyverse).\nהספר אינו נועד להחליף ספרי תיאוריה סטטיסטית, הוא אינו מכסה תיאוריה סטטיסטית לעומק, אלא בעיקר מדגים כיצד ניתן לממש כלים סטטיסטיים שונים באמצעות R.\nלמה R ולא Python?\nכמו שמרמזת הכותרת, יש היום שתי שפות שמובילות בתחום ה-Data Science, הן R ו-Python. בנקודה הזו אין שחור ולבן, טוב יותר או פחות. אני עובד בשתי השפות, ולי באופן אישי יש העדפה חזקה לשימוש ב-R, פשוט כי היא מרגישה לי יותר טבעית, זה כנראה נגזרת של העובדה שזה מה שלמדתי בהתחלה, וזה מה שהתמקצעתי בו. בפועל בשתי השפות יש כלים רבים ושימושיים, ובכל הקשור במשימות של ניתוח נתונים, שתי השפות נותנות מענה טוב מאוד.\nמבין שתיהן Python יותר נפוצה משום שהיא נפוצה כשפת תכנות (באופן כללי), בעוד ש-R מוכוונת יותר לתחום הסטטיסטיקה. בפועל, שתיהן עושות את העבודה, וכדאי להתאים את השפה לצורך. לדוגמה R הרבה פעמים נוחה יותר לביצוע ניתוח נתונים, אבל ל-Python עשוי להיות יתרון במעבר ל-Production (הטמעה במערכות).\nהדיון של בחירה בשפה מסוימת צריך להיגזר מהמשימה הנדרשת, ההקשר העסקי, ועוד הרבה שיקולים אחרים. ככלל למי שמשתלב בתוך ארגון כדאי לדעת שיש ב-R חבילות שמאפשרות להפעיל גם קוד Python מתוך R (חבילת reticulate), שתאפשר להשתלב עם R גם בתוך ארגון שעובד מסורתית עם Python.\nמה בספר?\nבפרק 1 נראה מבוא קצר לתהליך ניתוח הנתונים ונלמד מהם הכלים הנדרשים על מנת להתקין את R. לאחר מכן נצלול, בפרק 2 לבסיס של R כשפת תכנות. הפרק מתייחס לחלקים ב-R שמגיעים בגרסה ה”ערומה ביותר” מה שמכונה גם Base R.\nבפרק 3 נלמד את הבסיס של חבילות tidyverse ואיך הן מרחיבות את Base-R והופכות את הקוד שלנו ליותר קריא, ואת הכתיבה ליותר נוחה. אנחנו נתמקד בעיקר בשלבי הכנת הנתונים לקראת ניתוח, ואז בפרק 4 נלמד על ויז’ואליזציות באמצעות חבילת ggplot2.\nלעולם הסטטיסטי ניכנס בפרק 5 עם מבחני השערה, ובפרק 6 עם רגרסיה לינארית.\nלאחר מכן נצלול קצת יותר לעומק עם מודלים מתקדמים מעולם ה-Data Science תוך שימוש בחבילת tidymodels בפרק 7.\nהנוסח שלפניכם הוא טיוטה, ולכן חלקים מסוימים עוד חסרים ממנו, וחלקים מסוימים עוד ישתנו. מי שמוצא טעות בספר, מוזמן לפנות אלי בטוויטר @SaridResearch."
  },
  {
    "objectID": "01-introduction.html",
    "href": "01-introduction.html",
    "title": "1  מבוא",
    "section": "",
    "text": "בספר הזה אני מאמץ את נקודת ההשקפה של (Wickham and Grolemund 2016) שמציגים את אבני הבניין של עבודת מדען הנתונים כפי שמומחש באיור הבא:\n\n\n\n\n\nהמחשה של תהליך ניתוח הנתונים\n\n\nכל תהליך ניתוח נתונים מורכב מיבוא סט הנתונים, סידור שלהם בצורה שנוח לעבוד איתה, לאחר מכן מחקר על הנתונים, שהוא תהליך איטרטיבי (חוזר על עצמו) שמורכב מהתמרות שונות על הנתונים (טרנספורמציות), המחשות בתרשימים (ויז’ואליזציות), ומידול של הנתונים. לבסוף, התהליך עובר למסמך, מצגת או אמצעי אחר, ומוצג למקבלי החלטות.\nבספר זה נדון בשלבים של יבוא הנתונים, סידור, וכלל שלבי המחקר (טרנספורמציות, ויז’ואליזציות, ומידול). אך ראשית, לפני שנתחיל בצעדים הראשונים (למידת בסיס השפה), נראה כיצד להתקין את R."
  },
  {
    "objectID": "01-introduction.html#איך-מתקינים-את-r",
    "href": "01-introduction.html#איך-מתקינים-את-r",
    "title": "1  מבוא",
    "section": "1.2 איך מתקינים את R?",
    "text": "1.2 איך מתקינים את R?\nהתקנת התוכנה פשוטה מאוד. R היא שפה בקוד פתוח (Open Source) מה שאומר שכל אחד יכול להתקין אותה ללא עלות. כמו כן, ישנה סביבת פיתוח, גם היא חינמית ובקוד פתוח, הנקראת RStudio IDE.\nעל מנת להתקין את R עליכם להיכנס לכתובת https://cran.r-project.org/ ולבחור בגרסה המתאימה למערכת ההפעלה שלכם. לאחר מכן, כדי להתקין את RStudio היכנסו לכתובת https://rstudio.com/products/rstudio/download/. הגרסה החינמית של RStudio נקראת RStudio Desktop והיא זמינה לכל צורך (כולל לשימוש במסגרת מסחרית).\nהסיבה שאנחנו מתקינים גם את R וגם את RStudio היא שבהתקנת R בלבד, מקבלים ממשק משתמש בסיסי ביותר, בעוד שלאחר התקנת RStudio ניתן יהיה לעבוד עם ממשק משתמש נוח שיש לו הרבה אפשרויות שיקלו עליכם את הלמידה ואת העבודה השוטפת ב-R."
  },
  {
    "objectID": "01-introduction.html#איך-משתמשים-ב-rstudio",
    "href": "01-introduction.html#איך-משתמשים-ב-rstudio",
    "title": "1  מבוא",
    "section": "1.3 איך משתמשים ב-RStudio?",
    "text": "1.3 איך משתמשים ב-RStudio?\nלאחר ההתקנה, כשתפעילו את RStudio, תראו חלון המפוצל לשלושה (או אולי ארבעה) חלקים. החלק הגדול בצד שמאל הוא ה-Console, הוא סביבת ה-R המריצה את הקוד שלכם. אתם יכולים לנסות לרשום בו קוד ולראות מה קורה, לדוגמה תנסו לרשום 2+2 וללחוץ Enter או לרשום pi וללחוץ Enter.\n\n2+2\n\n[1] 4\n\npi\n\n[1] 3.141593\n\n\nבצד ימין למעלה ישנה חלונית המחולקת לטאבים. בין הטאבים שמופיעים בה תוכלו לראות את:\n\nEnvironment - משתנים או פונקציות שנטענו לסביבה\nHistory - היסטורית הפקודות שהרצתם\nConnections - חיבורים למקורות נתונים\nTutorial - הצגה של מדריכים שונים שמלמדים איך להשתמש בחבילות של R\n\nבצד ימין למטה תופיעה חלונית נוספת המחולקת גם היא לטאבים:\n\nFiles - תוכן התיקייה הנוכחית\nPlots - תרשימים שנכין יופיעו בטאב זה\nPackages - חבילות שזמינות לנו או שנטענו לסביבה (יסומנו ב-V)\nHelp - חלונית עזרה על פקודות\nViewer - צפיה בתכנים שונים שנכין (בעיקר תכנים אינטראקטיביים כמו טבלאות html תרשימים אינטראקטיביים, ואפליקציות).\n\nבתוך משתמשים מתחילים נשתמש בחלק קטן מאלו, אך ככל שיעבור זמן תראו שאתם משתמשים ביותר ויותר אפשרויות, וגם אפשרויות נוספות שכרגע אינן מופיעות לכם.\nעוד כמה פינות חשובות שנמצאות ב-RStudio:\n\nאם תלחצו על Help->Cheat sheets תוכלו לראות רשימה של “שליפים”. דפים שימושיים שמרכזים פקודות שונות של R וחבילות של R. לדוגמה, אחד מהשליפים ששם נקרא RStudio IDE Cheat Sheet, והוא מכיל הרבה הסברים נוספים על הממשק משתמש של RStudio.\nבתפריט File -> New File ישנה אפשרות לפתוח קובץ חדש. מומלץ שתנסו לפתוח קובץ חדש מסוג R Script, שישמש אותנו לפרק הבא.\n\nשימו לב: לאחר שפתחתם Script חדש, וכתבתם בו קוד, על מנת להריץ את הקוד צריך לסמן אותו וללחוץ Ctrl+Enter. זה יגרום ל-R להריץ את כל הקוד המסומן.\nכעת אנחנו מוכנים לפרק הבא, שבו נלמד את בסיס השפה, מה שמכונה גם Base R.\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \"O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "02-base-R.html",
    "href": "02-base-R.html",
    "title": "2  תחביר בסיסי",
    "section": "",
    "text": "בפרק זה נלמד את הבסיס של R, בעיקר נכיר את הפקודות הבסיסיות, אופרטורים (תנאים לוגיים) שונים, התניות, לולאות, סוגי משתנים ובניית פונקציות. בסיס זה נקרא הרבה פעמים גם Base R משום שהוא אינו מכיל חבילות הרחבה כלשהן, ומגיע עם התקנה חדשה של R.\nפרק זה הוא בין הפרקים הבודדים בספר שמתמקד בעקרונות של תכנות כמו התניות, לולאות, ופונקציות. עקרונות אלו יהיו מוכרים מאוד למי שכבר למד תכנות, אך ייתכן שיהיו קצת יותר מאתגרים למישהו שמעולם לא למד תכנות. זה לא נורא, משום שהיכרות בסיסית עם העקרונות ומעט תרגול (כמו בתרגילים שמופיעים בפרק זה) יאפשרו גם למי שאין לו היכרות עם תכנות להתקדם לפרקים הבאים.\nכדי לתרגל את הפקודות שתלמדו בפרק זה (ובפרקים הבאים) מומלץ לפתוח חלון של RStudio ולנסות את הפקודות השונות תוך כדי שאתם קוראים את הפרק."
  },
  {
    "objectID": "02-base-R.html#השמת-משתנים-פעולות-אריתמטיות-ופונקציות",
    "href": "02-base-R.html#השמת-משתנים-פעולות-אריתמטיות-ופונקציות",
    "title": "2  תחביר בסיסי",
    "section": "2.1 השמת משתנים, פעולות אריתמטיות ופונקציות",
    "text": "2.1 השמת משתנים, פעולות אריתמטיות ופונקציות\nניתן להריץ ב-R פעולות אריתמטיות (חיבור, חיסור, כפל, חילוק), פונקציות, ולהגדיר משתנים שונים. לדוגמה, הקוד הבא מגדיר משתנה a משתנה b ומכניס את הסכום שלהם למשתנה חדש שיקרא a_plus_b.\n\na <- 5\nb <- 3\na_plus_b <- a + b\na_plus_b\n\n[1] 8\n\n\nשימו לב שההשמה לתוך משתנה מתבצעת עם האופרטור ->, ניתן גם להשתמש ב= לצורך השמה, כתיב זה פחות נפוץ. לדוגמה:\n\na_plus_b = a + b  # this form of assignment `=` is less common, don't use it (use `<-`)\n\n\n2.1.1 קביעת שמות משתנים\nקודם השתמשנו בשמות a, b , ו-a_plus_b כדי לקבוע משתנים. ככלל, מומלץ להשתמש בשמות קצרים בעלי משמעות. שמות משתנים חייבים להתחיל באות באנגלית, ויכולים להכיל אותיות, מספרים, קו תחתון, ונקודה. לדוגמה gender, age, raw_data, וכו’.\n\n\n2.1.2 סוגי משתנים\nבבסיס השפה יש כמה סוגי משתנים, שקובעים מה סוג הערכים שהמשתנה יכול לקבל:\n\nמספר שלם (Integer)\nמספר רציף (Double)\nמחרוזת (Character)\nמשתנה קטגוריות (Factor)\nתאריך (Date)\nמשתנה לוגי (Logical)\n\nכל משתנה חדש אנחנו מגדירים ב-R הוא למעשה וקטור. אגב, גם כשאנחנו מגדירים משתנה כערך בודד, בעצם הוא וקטור עם איבר אחד. אנחנו יכולים להשתמש בפקודה c (קיצור של המילה combine) כדי לשלב וקטורים שונים.\nנראה דוגמאות להגדרות של וקטורים מסוגים שונים.\n\nsome_integer <- c(1L, 2L, 3L)  # The L sign stands for \"Long integer\"\nsome_integer\n\n[1] 1 2 3\n\nsome_double <- c(1, 2, pi, exp(1))\nsome_double\n\n[1] 1.000000 2.000000 3.141593 2.718282\n\nsome_character <- c(\"This\", \"is\", \"a\", \"character\", \"vector\")\nsome_character\n\n[1] \"This\"      \"is\"        \"a\"         \"character\" \"vector\"   \n\nsome_factor <- factor(c(\"Apples\", \"Oranges\", \"Paers\", \"Mangos\", \"Apples\", \"Oranges\"))\nsome_factor\n\n[1] Apples  Oranges Paers   Mangos  Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\nsome_date <- c(Sys.Date(), as.Date(\"1993-08-01\"))\nsome_date\n\n[1] \"2023-02-13\" \"1993-08-01\"\n\nsome_logical <- c(TRUE, FALSE, FALSE, TRUE) # can also use c(T, F, F, T) is the same\nsome_logical\n\n[1]  TRUE FALSE FALSE  TRUE\n\n\nלמשתני קטגוריות יש שימוש חשוב בסטטיסטיקה שעוד נראה אותו בפרקים הבאים, ולכן הוא מובחן ממשתנה מחרוזת ומקבל מקום של כבוד. כפי שניתן לראות, כאשר מדפיסים אותו, R מדווח גם על הרמות השונות שכלולות בו.\nשימוש בפקודה typeof(some_variable) יציג את סוג המשתנה.\n\ntypeof(some_integer)\n\n[1] \"integer\"\n\ntypeof(some_double)\n\n[1] \"double\"\n\ntypeof(some_character)\n\n[1] \"character\"\n\ntypeof(some_date)\n\n[1] \"double\"\n\ntypeof(some_factor)\n\n[1] \"integer\"\n\ntypeof(some_logical)\n\n[1] \"logical\"\n\n\nניתן לשים לב ש-R מחשיב את המשתנה הקטגוריאלי כמספר שלם (integer) ואת התאריך כמספר רציף (double).\n\n\n\nבאמצעות הפקודה c והפקודה typeof בדקו מה קורה כאשר מחברים משתנים מסוגים שונים אחד לשני. האם התוצאה הגיונית? מה ההיגיון? האם יש מקרים בהם התוצאה של חיבור משתנים עשויה להטעות?\n\n\nבדקו את c(some_factor, some_character) ודוגמאות נוספות.\n\n\n\n\n\n2.1.3 קריאה לתתי וקטורים\nב-R ניתן לקרוא לחלק מסוים מתוך וקטור. לדוגמה, אם אנחנו רוצים רק את שני האיברים הראשונים מתוך הוקטור some_factor או את האיבר הראשון והרביעי מתוך some_character נשתמש בכתיב:\n\nsome_factor[1:2]\n\n[1] Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\nsome_character[c(1,4)]\n\n[1] \"This\"      \"character\""
  },
  {
    "objectID": "02-base-R.html#רשימה-list",
    "href": "02-base-R.html#רשימה-list",
    "title": "2  תחביר בסיסי",
    "section": "2.2 רשימה (list)",
    "text": "2.2 רשימה (list)\nכעת נדון במבנה נתונים שנקרא רשימה (list). רשימה היא אובייקט מרכזי ב-R שמאפשר לנו לאחד משתנים ווקטורים מסוגים שונים, לתוך dataset שיאפשר לנו בהמשך לנתח נתונים. ישנן מספר דרכים להגדיר רשימה, אחת מהן באמצעות הפקודה list. לדוגמה, הרשימה הבאה תכיל את כל הוקטורים שהגדרנו עד כה, מבלי שהם יאבדו מהמשמעות שלהם (כפי שקורה כשמנסים לעשות חיבור רגיל).\n\nmy_list <- list(my_int = some_integer,\n                my_double = some_double,\n                my_character = some_character,\n                my_factor = some_factor,\n                my_date = some_date)\nmy_list\n\n$my_int\n[1] 1 2 3\n\n$my_double\n[1] 1.000000 2.000000 3.141593 2.718282\n\n$my_character\n[1] \"This\"      \"is\"        \"a\"         \"character\" \"vector\"   \n\n$my_factor\n[1] Apples  Oranges Paers   Mangos  Apples  Oranges\nLevels: Apples Mangos Oranges Paers\n\n$my_date\n[1] \"2023-02-13\" \"1993-08-01\"\n\ntypeof(my_list)\n\n[1] \"list\"\n\n\nכדי לקרוא לוקטור מסוים מתוך רשימה ניתן להשתמש ב-$ באופן הבא:\n\nmy_list$my_int\n\n[1] 1 2 3\n\n\nהחלק הסופי בהצגה שלנו הוא רשימה מסוג מאוד מסוים, data.frame. מבנה נתונים זה הוא רשימה שבה כל הוקטורים באותו האורך. הוקטורים יכולים להיות מסוגים שונים כפי שציינו, ומה שחשוב ב-data.frame הוא שהוא הולך להיות אבן הפינה שלנו בכל ניתוח נתונים סטטיסטי. בינתיים נסתפק בהדגמה קצרה של הגדרת data.frame אך נרחיב עליו בפרקים הבאים.\n\nmy_data <- data.frame(name = c(\"Danny\", \"Moshe\", \"Iris\", \"Ronit\"),\n                      favorite_fruit = factor(c(\"Mango\", \"Apple\", \"Apple\", \"Paer\")),\n                      age = c(25L, 32L, 22L, 30L),\n                      height = c(1.8, 1.75, 1.6, 1.68),\n                      married = c(F, T, F, T))\nmy_data\n\n   name favorite_fruit age height married\n1 Danny          Mango  25   1.80   FALSE\n2 Moshe          Apple  32   1.75    TRUE\n3  Iris          Apple  22   1.60   FALSE\n4 Ronit           Paer  30   1.68    TRUE\n\ntypeof(my_data)\n\n[1] \"list\""
  },
  {
    "objectID": "02-base-R.html#שימוש-בפונקציות",
    "href": "02-base-R.html#שימוש-בפונקציות",
    "title": "2  תחביר בסיסי",
    "section": "2.3 שימוש בפונקציות",
    "text": "2.3 שימוש בפונקציות\nניתן גם להפעיל פונקציות שונות, לדוגמה לוגריתם, פונקציות טריגונומטריות. למעשה בסעיף הקודם כבר ראינו מספר פונקציות כגון c ו-typeof. כעת נראה עוד מספר דוגמאות.\nנסו להריץ את הקוד הבא, ולאחר מכן לענות על השאלות שמתחת למקטע הקוד. יש לשים לב שעל מנת להריץ את הפקודות בסוף המקטע (שקשורות ב-my_data נדרש קודם להגדיר את my_data כפי שהוגדר במקטע הקוד הקודם.\n\nlog(100)  # natural logarithm\nlog10(100)  # base 10 logarithm \nsin(pi)  # sin(pi) is 0 but may give you a surprising answer, why?\nsqrt(4)  # square root of 4\nmean(my_data$age)\nsd(my_data$age)\nsummary(my_data)\n\n\n\n\nשאלה למחשבה: בחלק מהמחשבים התשובה שמתקבלת ל-(()) שונה מ-0. למה לדעתך?\n\n\n\n\n\n\nהפקודה האחרונה שהרצנו בדוגמה היא פקודת summary. מה עושה הפקודה summary עבור כל סוג עמודה שהיא מוצאת בdata.frame?\n\n\n\nככלל, הפעלת פונקציה ב-R תיראה כך:\n\n# some code which defines the variable `bar` and then\nsome_result <- some_function(foo = bar)\n\n# or simply\nsome_result <- some_function(bar)\n\nכאשר some_result יחזיק את התוצאה של הפונקציה. הפונקציה עצמה נקראת some_function, היא מקבלת ארגומנט (משתנה) יחיד שנקרא foo ואנחנו משתמשים במשתנה שערכו bar שנכנס לארגומנט.\nכדי להמחיש נראה דוגמה נוספת, הפעם עם פונקציה פשוטה שגם נגדיר בעצמנו. נסו לעיין בקוד ולהבין מה המשמעות של כל שורה בקוד. שלושת השורות הראשונות בקוד מגדירות פונקציה חדשה, וההמשך מריץ אותה.\n\n# define a new function which adds a number\none_plus <- function(number){\n  number + 1\n}\n# use the function:\none_plus(1)\n\n[1] 2\n\none_plus(one_plus(1))\n\n[1] 3"
  },
  {
    "objectID": "02-base-R.html#אופרטורים",
    "href": "02-base-R.html#אופרטורים",
    "title": "2  תחביר בסיסי",
    "section": "2.4 אופרטורים",
    "text": "2.4 אופרטורים\nאופרטורים משמשים כדי להגדיר תנאים לוגיים שונים, לדוגמה אם אנחנו רוצים לבדוק את נכונותם של שני תנאים או יותר. ב-R נשתמש בתו כפול || כדי לציין “או” לוגי (or), ונשתמש בתו כפול && על מנת לציין “וגם” לוגי (and).\n\na <- 5\nb <- 6\n\n(a < 3) && (b >= 3)\n\n[1] FALSE\n\n(a >= 5) || (b > 10)\n\n[1] TRUE\n\n\nישנם גם פעולות לוגיות וקטוריות: כמו שניתן לחבר שני וקטורים, ניתן גם לבצע פעולות לוגיות איבר-איבר. פעולות אלו מבוצעות על ידי תו בודד: | או &.\n\nv1 <- c(T, T, F, F)\nv2 <- c(T, F, T, F)\n\nv1 | v2\n\n[1]  TRUE  TRUE  TRUE FALSE\n\nv1 & v2\n\n[1]  TRUE FALSE FALSE FALSE\n\n\n\n\n\nנסו לבחון מה קורה במקרה של v1 || v2 או v1 && v2. מה החוקיות?\n\n\n\nאופרטור נוסף הוא אופרטור השלילה (not), נשתמש בתו ! על מנת לייצג אותו. לדוגמה:\n\n!c(T, F)\n\n[1] FALSE  TRUE\n\n!v1\n\n[1] FALSE FALSE  TRUE  TRUE\n\na==5\n\n[1] TRUE\n\n!(a==5)\n\n[1] FALSE\n\n\nשימו לב שבדוגמה האחרונה השתמשנו באופרטור נוסף אשר בודק אם שני אובייקטים הם בעלי אותו הערך. אופרטור זו מצויין עם שיוויון כפול ==. ניתן גם להשוות שני משתנים זה לזה או להשוות שני וקטורים (איבר-איבר) באופן הבא:\n\na == b\n\n[1] FALSE\n\nc(1, 2, 3) == c(2, 1 , 3)\n\n[1] FALSE FALSE  TRUE\n\n\nישנם אופרטורים נוספים ב-R, אך בינתיים נסתפק באופרטורים שצוינו לעיל. כעת, לאחר שלמדנו על אופרטורים לוגיים, באפשרותנו ללמוד על התניות (if cluases) ועל לולאות (loops)."
  },
  {
    "objectID": "02-base-R.html#התניות",
    "href": "02-base-R.html#התניות",
    "title": "2  תחביר בסיסי",
    "section": "2.5 התניות",
    "text": "2.5 התניות\nבמקרים רבים אנחנו רוצים להתנות פעולות מסוימות בקיומו של תנאי כלשהו. ניתן לבצע התניה זו באמצעות הפקודות if, else if, else.\nהמבנה הכללי של התניות יראה כך:\n\nif (condition1) {\n  # some code which evaluates if condition1 == TRUE\n} else if (condition2) {\n  # some code which evaluates if condition1 == FALSE and condition2 == TRUE\n} else {\n  # some code which evaluates if condition1 == FALSE and condition2 == FALSE\n}\n\nעל מנת להדגים, נשתמש בדוגמה הבאה: נניח שאנחנו רוצים לבדוק אם ערך מסוים הוא מספר או לא. נוכל להשתמש בשילוב של if והפונקציה is.numeric:\n\nsome_value <- 100\n\nif (is.numeric(some_value)) {\n  cat(\"This is indeed a numeric value!\")\n} else {\n  cat(\"This is not a numeric value!\")\n}\n\nThis is indeed a numeric value!\n\nsome_value <- \"foobar\"\n\nif (is.numeric(some_value)) {\n  cat(\"This is indeed a numeric value!\")\n} else {\n  cat(\"This is not a numeric value!\")\n}\n\nThis is not a numeric value!\n\n\nאפשר גם להשתמש בהתניות בתוך התניות, כלומר בתוך פקודת if להגדיר פקודת if נוספת.\n\n\n\nנסו להרחיב את הדוגמה הקודמת, כך שבמידה ו-some_value הוא מספר המתחלק ב-2 אז יודפס “some_value is even” ובמידה ואינו מתחלק ב-2 יודפס “some_value is odd”.\n\n\nנסו למצוא יותר מדרך אחת לביצוע הרחבה זו."
  },
  {
    "objectID": "02-base-R.html#לולאות",
    "href": "02-base-R.html#לולאות",
    "title": "2  תחביר בסיסי",
    "section": "2.6 לולאות",
    "text": "2.6 לולאות\nלולאות הן דרך נוחה כדי לגרום למחשב לעשות הרבה חזרות של אותה הפעולה (רק בשינוי ערכים מסוימים). ב-R ישנם סוגים שונים של לולאות, המתאפיינים בפקודות שונות אבל גם בזמן ריצה (יעילות) שונה.\n\nלולאות for\nלולאות while\nלולאות repeat break next\nלולאות באמצעות תכנות פונקציונלי (כדוגמת פקודת lapply, או פקודות מחבילות אחרות כמו map שנמצאת בחבילת purrr)\n\nעדיף להימנע ככל שניתן משימוש בכל סוגי הלולאות for, while, ו-repeat בעבודה עם R. לולאות אלו מאוד לא יעילות וזמן הריצה שלהן ארוך. תכנות פונקציונלי הוא יותר יעיל, אך דורש קצת יותר “התרגלות”. בכל זאת, נדגים את אופן הפעולה של לולאת for.\nעל מנת להגדיר לולאת for עלינו להגדיר ראשית את טווח הפעולה של הלולאה. לדוגמה, לולאה שרצה על המספרים 1 עד 100 תוגדר באופן הבא:\n\nfor (i in 1:100){\n  # do some action\n  # you can use i for that but don't have to\n}\n\nטווח הפעולה של הלולאה לא חייב להיות מספרי, אפשר גם להשתמש באובייקטים נוספים. לדוגמה נשתמש בלולאה על סוגי פירות. בדוגמה הבאה נשלב גם שימוש בהתניות, כפי שלמדנו בסעיף הקודם. השילוב של לולאות והתניות די נפוץ בתכנות.\n\nfruits <- c(\"Mango\", \"Bannana\", \"Pineapple\", \"Orange\", \"Apple\", \"Prune\", \"Lemon\", \"Loquat\")\nmy_garden <- c(\"Mango\", \"Orange\", \"Lemon\", \"Loquat\")\n\nfor (current_fruit in fruits) {\n  if (current_fruit %in% my_garden) {\n    cat(\"\\nI grow\", current_fruit)\n  } else {\n    cat(\"\\nI don't grow\", current_fruit)\n  }\n}\n\n\nI grow Mango\nI don't grow Bannana\nI don't grow Pineapple\nI grow Orange\nI don't grow Apple\nI don't grow Prune\nI grow Lemon\nI grow Loquat\n\n\n\n\n\nבדוגמה הקודמת השתמשנו ב-in וגם ב-%in%.\n\n\nin נחשבת מילת מפתח, בעוד ש-%in% נחשבת אופרטור. עמדו על ההבדלים ביניהן וכתבו מה המשמעות של כל אחת, ומה התפקיד שלה בקוד.\n\n\n\nנדגים גם כיצד ניתן להחליף לולאה באמצעות פעולה וקטורית, ובאמצעות נוסחה מתמטית. נניח שאנחנו רוצים לחשב סכום של טור הנדסי, כלומר הסכום של \\(1, q, q^2, q^3, \\ldots\\) כאשר \\(q<1\\). נציג שלוש דרכים לבצע את הפעולה הזו: לולאה (הדרך הכי פחות יעילה), פעולה וקטורית (להיעזר בוקטור, כלומר מערך של מספרים), והדרך היעילה ביותר שהיא כמובן פשוט להשתמש בנוסחה של טור הנדסי (\\(\\frac{1}{1-q}\\)).\n\nq <- 1/2\n\nseries_sum_loop <- 0\n\nfor (element_i in 0:50){\n  series_sum_loop <- series_sum_loop + q^element_i\n}\n\nseries_sum_loop\n\n[1] 2\n\nseries_sum_vector <- sum(q^(0:50))\n\nseries_sum_vector\n\n[1] 2\n\nseries_sum_analytic <- 1/(1-q)\n\nseries_sum_analytic\n\n[1] 2\n\n\nחישוב של טור הנדסי הוא כמובן פעולה פשוטה, אבל לא בכל פעולה שנרצה לעשות תהיה נוסחה סגורה כמו שיש שלנו במקרה של טור הנדסי, וגם לא תמיד יהיה אפשר לבצע את הפעולה כפעולה וקטורית.\nסדרת פיבונצ’י היא סדרה של מספרים שבה כל איבר הוא הסכום של שני האיברים שקדמו לו. שני האיברים הראשונים מקבלים את הערך 1, ולכן האיברים הראשונים של הסדרה נראים כך:\n\\[\n1, 1, 2, 3, 5, 8, 13, 21, 34,\\ldots\n\\]\n\n\n\nהיעזרו בקוד הבא על מנת לבנות לולאה שתדפיס את 50 האיברים הראשונים של סדרת פיבונצ’י. עליכם להשלים את הקוד במקומות בהם מופיע סימן שאלה.\n\n\n\n\n# Fibonachi code exercise, fill in the blanks (where you see `?`)\ntotal <- ?\n\nelement_i_minus1 <- 1\nelement_i_minus2 <- 1\n\nfor (? in 3:total){\n  next_element <- element_i_minus1 + ?\n  element_i_minus2 <- element_i_minus1\n  ? <- next_element\n  \n  cat(\"\\n\", ?)\n}"
  },
  {
    "objectID": "03-data-munging-tidyverse.html",
    "href": "03-data-munging-tidyverse.html",
    "title": "3  הכנת נתונים",
    "section": "",
    "text": "הכנת נתונים, או כמו שהיא מכונה באנגלית, Data Munging, היא סדר הפעולות שיש לעשות לנתונים על מנת שאפשר יהיה להשתמש בהם בכלל שלבי המחקר, כגון הצגת נתונים (ויז’ואליזציה), מידול, ובפעולות נוספות במהלך המחקר. בספר זה, אנחנו עושים שימוש רב בחבילת tidyverse על מנת להכין את הנתונים.\nראשית, נעמוד על הפילוסופיה מאחורי tidyverse."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#הפילוסופיה-מאחורי-tidyverse",
    "href": "03-data-munging-tidyverse.html#הפילוסופיה-מאחורי-tidyverse",
    "title": "3  הכנת נתונים",
    "section": "3.1 הפילוסופיה מאחורי tidyverse",
    "text": "3.1 הפילוסופיה מאחורי tidyverse\nהחבילה ב-R שנקראת tidyverse היא למעשה “חבילה של חבילות”.\nהיא מכילה מקבץ חבילות לעבודה עם נתונים כמו dplyr, וכמו tidyr שהן חבילות מאוד שימושיות במניפולציה על נתונים, וסידור נתונים, אבל היא מכילה גם חבילות שממוקדות סביב עולמות תוכן אחרים, כמו stringr לעבודה עם מחזורות, lubridate לעבודה עם תאריכים, ו-forcats לעבודה עם פקטורים. כפי שחדי העין ישימו לב, לרוב שם של חבילה ירמוז לגבי מהות החבילה (לעיתים עם האות r איפשהו, ולעיתים עם קורטוב של הומור). הפירוט המלא של תוכן החבילה tidyverseוהחבילות שמוכלות בה זמין בקישור.\nעל מנת להתקין את החבילה נשתמש בפקודה install.packages(\"tidyverse\"), ועל מנת לטעון אותה לאחר ההתקנה, נשתמש בפקודה library(tidyverse). שימו לב שבהתקנה צריך להשתמש במרכאות אבל בקריאה לאחר מכן אין צורך במרכאות. את ההתקנה צריך לעשות רק פעם אחת (והיא לוקחת המון זמן), ואת הקריאה לספריה צריך לעשות כל פעם שמפעילים מחדש את R.\nכשלב יסודי, מה שחשוב להבין בעבודה עם נתונים זה שהשאיפה היא שתמיד נשאף להגיע ולעבוד במבנה מסודר שבו:\n\nכל עמודה היא משתנה.\nכל שורה היא תצפית.\nכל תא הוא ערך של משתנה עבור תצפית מסוימות.\n\nאם הדאטה המקורי שלנו לא במבנה הזה - אז כהכנה נרצה להביא אותו למבנה כזה, ואם הוא כבר במבנה המסודר הזה, אז כל פעולה שנעשה, עדיין תשמור את הדאטה במבנה מסודר. המבנה הזה מכונה באנגלית tidy (ומכאן השם tidyverse). אנחנו פשוט נכנה אותו פה מבנה “מסודר”.\nניתן שתי דוגמאות לדאטה, אחד מסודר ואחר לא מסודר. נתחיל בדוגמה לדאטה לא מסודר.\n\n3.1.1 דוגמה לדאטה לא מסודר\nהלשכה המרכזית לסטטיסטיקה מנגישה הרבה נתונים לציבור באמצעות האתר שלה https://www.cbs.gov.il\nמרבית הנתונים שמונגשים לציבור דרך האתר בקבצי אקסל הינם בפורמט לא מסודר. לדוגמה, קובץ שהורדתי מהכתובת הזו והוא עוסק בנפח תנועה מסביב לכנרת בחג הפסח וסוכות.\nזה קובץ אקסל, והוא נראה כך:\n\n\n\nדאטה לא-מסודר מאתר הלשכה המרכזית לסטטיסטיקה\n\n\nאיפה הבעיות עם הדאטה? נראה מה הסעיפים שאינם מתקיימים:\n\nכל עמודה היא משתנה - מתקיים באופן חלקי. משום שיש עמודות מסוימות כמו עמודות H-K שהן ממוזגות מה שהופך אותם ל”לא בדיוק משתנה יחיד”. מדובר בקבוצת משתנים ותכונה שמתארת אותם. בפרט, היינו מצפים לראות שורת כותרת אחת שמתארת את שמות המשתנים (מה שמכונה באנגלית headers), אבל בפועל יש פה הרבה שורות כותרות.\nכל שורה היא תצפית - לא מתקיים בכלל. יש שורות ריקות (כמו שורה 5), ויש שורות שאינן תצפית אלא מתארות תכונות של מקבץ תצפיות (כגון שורה 6 ושורה 14).\nכל תא הוא ערך של משתנה עבור תצפית מסוימת - לא מתקיים. ראו סעיף קודם - מדובר בתאים שמכילים ערכים שמתארים מקבץ תצפיות.\n\nכמו כן, יש עוד כל מיני חריגות לא ברורות בקובץ כגון תאים שמודגשים במסגרת גבול שחורה (מבלי שברור מה המסגרת אומרת), יש תאים שמכילים שתי נקודות (לא ברור מה זה, האם ערך חסר?), שמות המשתנים לעיתים מפוצלים על פני שתי שורות (כמו לדוגמה “ערב פסח” בעמודה F), ועוד בעיות.\nבסיכומו של עניין - אילו היינו רוצים לקלוט קובץ כזה לתוך R על מנת לחלץ את המספרים שבו, היינו צריכים להתאמץ רבות על מנת להפוך את הקובץ למסודר. באופן כללי, ניתן לומר שקבצי אקסל הם מתכון לאסון כי הם מעודדים את המשתמשים לבנות קבצים לא-מסודרים על ידי ביצוע פעולות כמו מיזוג תאים, צביעה של תאים (שזה אינדיקציה לקידוד מידע כלשהו, אבל קידוד שקשה להבין אותו ב”שפת הנתונים”), ועוד שאר בעיות שאין זה המקום לתאר.\n\n\n3.1.2 דוגמה לדאטה מסודר\nהנה דוגמה לדאטה מסודר מתוך חבילת palmerpenguins. חבילה זו מכילה נתונים של שלושה זנים של פינגוינים, ואנחנו עוד נשתמש בה בהמשך הספר. לכרגע רק נראה איך נראות עשרת השורות הראשונות בטבלת הנתונים (הסבר על הקוד והתוצר שרואים מצורף מטה):\n\npalmerpenguins::penguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n# ℹ Use `print(n = ...)` to see more rows\n\n\nאנחנו רואים שהאובייקט הוא מסוג tibble (טבלה שהיא גרסה מודרנית יותר של ה-data.frame הבסיסי ב-R). לטבלה הזו יש 344 תצפיות (פינגוינים), ויש לה 8 עמודות (משתנים) שכוללים את הזן של הפינגוין, מאיזה אי הוא, אורך ועומד המקור, אורך הכנף, מסה, מין, והשנה שבה נצפתה הדגימה. הדאטה הזה מסודר ועומד בכללים שהגדרנו.\nלגבי הקוד עצמו שבו השתמשנו: השימוש בנקודותיים :: אומר ל-R לקחת את האובייקט penguins שנמצא בתוך חבילת palmerpenguins (אפשר גם היה לפצל את הקוד וקודם להשתמש ב-library(palmerpenguins) ואז להריץ את head(penguins).\nאם תרצו להריץ את הקוד הזה אצלכם במחשב, יכול להיות שתצטרכו קודם להתקין את החבילה על ידי שימוש בפקודה install.packages(\"palmerpenguins\").\nכעת לאחר שלמדנו קצת על מה הוא דאטה מסודר, נראה איך אפשר לקרוא נתונים ו”להציץ” בנתונים, כדי לקבל מושג מה יש בנתונים ואיך לגשת אליהם."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#הצצה-ראשונית-על-הנתונים",
    "href": "03-data-munging-tidyverse.html#הצצה-ראשונית-על-הנתונים",
    "title": "3  הכנת נתונים",
    "section": "3.2 הצצה ראשונית על הנתונים",
    "text": "3.2 הצצה ראשונית על הנתונים\nבדרך כלל לפני הצצה ראשונית על הנתונים, אנחנו נידרש לקרוא אותם. קריאת הנתונים יכולה להתבצע ממגוון פורמטים. לדוגמה:\n\nקריאה מפורמט של CSV (Comma Separated Values, קרי קובץ טקסט המפריד ערכים באמצעות פסיקים), באמצעות פונקציות כגון read.csv, readr::read_csv.\nקריאה מפורמט של אקסל באמצעות פונקציה כגון: readxl::read_excel.\nקריאה מפורמט של תוכנות סטטיסטיות אחרות כגון SPSS או SAS באמצעות פקודות מחבילת haven.\nפורמטים וכלים נוספים.\n\nנתמקד בקבצי CSV, הפקודה המועדפת עלי היא readr::read_csv (בהשוואה ל-read.csv שנמצאת ב-Base R). הפקודה read_csv מעט מהירה ונוחה יותר מבחינת השליטה שהיא מאפשרת בקריאת הנתונים.\n\nקראו את התיעוד של read.csv ושל read_csv. איזה הבדלים אתם מזהים בין הפקודות?\nלצורך קריאת התיעוד ניתן לכתוב ב-Console ?read.csv, ?readr::read_csv.\n\nנקרא כעת את טבלת הPenguins שראינו בחלק הקודם. שימו לב שאנחנו משתמשים במיקום קובץ באינטרנט, אבל ניתן גם לקרוא קבצים שנמצאים מקומית על המחשב.\n\nlibrary(readr)\npenguins <- read_csv(\"https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv\")\n\nRows: 344 Columns: 8── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (5): bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nעל מנת להציץ בדאטה יש מספר פקודות שניתן להשתמש בהן:\n\nהפקודה View (עם V גדולה) - פקודה זו מתאימה לדאטה בגודל קטן עד בינוני, והיא מציגה טבלה עם הנתונים.\nהפקודה glimpse תציג את הערכים הראשונים של כל אחד מהמשתנים, כמו גם את שמות המשתנים, ואת סוגם.\nהפקודה head תציג טבלה המוגבלת לשש התצפיות הראשונות. אפשר להשתמש בארגומנט של הפונקציה על מנת להציג יותר שורות. הפקודה tail עובדת באופן דומה (רק מתחתית הטבלה).\nלכתוב ב-Console את שם הטבלה וללחוץ על Enter פשוט יציג את הטבלה (אם מדובר בtibble אז היא תוצג בפורמט קומפקטי ונוח).\n\n\nlibrary(tidyverse)\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <dbl> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\nhead(penguins)\n\n# A tibble: 6 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <chr>   <chr>              <dbl>         <dbl>       <dbl>   <dbl> <chr> <dbl>\n1 Adelie  Torgersen           39.1          18.7         181    3750 male   2007\n2 Adelie  Torgersen           39.5          17.4         186    3800 fema…  2007\n3 Adelie  Torgersen           40.3          18           195    3250 fema…  2007\n4 Adelie  Torgersen           NA            NA            NA      NA <NA>   2007\n5 Adelie  Torgersen           36.7          19.3         193    3450 fema…  2007\n6 Adelie  Torgersen           39.3          20.6         190    3650 male   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\nhead(penguins, 10)\n\n# A tibble: 10 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <chr>   <chr>              <dbl>         <dbl>      <dbl>   <dbl> <chr> <dbl>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <chr>   <chr>              <dbl>         <dbl>      <dbl>   <dbl> <chr> <dbl>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n# ℹ Use `print(n = ...)` to see more rows\n\n\n\nעברו על הפלט וודאו שאתם מצליחים להבין אילו חלקים בכל אחד מהפלטים מספק את המידע: סוג המשתנה, שם המשתנה, גודל הטבלה.\n\nבמבט על הפלט של כל אחת מהפקודות להלן ניתן כבר להבין את הפרטים הבאים:\n\nהאובייקט שאנחנו בוחנים הוא טבלה מסוג tibble, בגודל של 344 שורות (תצפיות), ו-8 עמודות (משתנים).\nסוגי המשתנים הם מחרוזות (character - chr), מספרים ממשיים (double - dbl).\n\nמחרוזות: species, island, sex\nמספרים ממשיים: bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year.\n\n\nכעת, לאחר שלמדנו איך להבין את מבנה הדאטה באופן ראשוני, נציג פונקציות שמשמשות לשינוי משתנים (טרנספורמציות)."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#פעולות-שמשנות-ערכים-טרנספורמציות",
    "href": "03-data-munging-tidyverse.html#פעולות-שמשנות-ערכים-טרנספורמציות",
    "title": "3  הכנת נתונים",
    "section": "3.3 פעולות שמשנות ערכים (טרנספורמציות)",
    "text": "3.3 פעולות שמשנות ערכים (טרנספורמציות)\nטרנספורמציה היא פעולה (פונקציה) על משתנה או צירוף של משתנים המניבה משתנה עם ערך חדש. היא יכולה להיות פעולה מתמטית פשוטה כמו לוגריתם, פונקציה טריגונומטרית, או מכפלה בסקלר (ערך כלשהו).\nגם פעולה על מחרוזת היא טרנספורמציה, כגון החזרת אורך המחרוזת או חלק ממחרוזת.\nטרנספורמציות ב-R יבוצעו באמצעות הפקודה mutate, והן יכולות לדרוס ערך קיים או להוסיף משתנה חדש לטבלה. התוצאה תוחזר בטבלה חדשה לגמרי (ולא תדרוס את הטבלה שהוזנה לתוך הפונציה mutate.\nבנוסף, על מנת להפעיל את הטרנספורמציה עם פקודת mutate (ובאופן כללי בשימוש ב-tidyverse) נשתמש באופרטור הנקרא pipe (מקטרת או צינור) ומטרתו להפוך את הקוד ליותר ברור. ישנם שני אופרטורים מסוג pipe: %>% ו-|>. בספר זה נשתמש בנוסח הראשון (הנוסח השני נמצא ב-Base R החל מגרסה 4.0.0).\nלהלן דוגמה המייצרת משתנה חדש (עמודה נוספת) ל-penguins, של משקל בקילוגרמים.\n\nnew_penguins <- penguins %>% \n  mutate(body_mass_kg = body_mass_g/1000)\n\nglimpse(new_penguins)\n\nRows: 344\nColumns: 9\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <dbl> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      <dbl> 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…\n\n\nכפי שניתן לראות האובייקט new_penguins דומה מאוד לאובייקט המקורי penguins (שלא השתנה). האובייקט החדש מכיל עמודה נוספת שהיא המשקל של התצפית בק”ג.\nהאופרטור pipe מסמן ל-R להכניס את הדאטה penguins כארגומנט ראשון בפונקציה mutate. זה שקול לכתיב הבא: mutate(penguins, body_mass_kg = body_mass_g/1000). היתרון בשימוש ב-pipe יבוא לידי ביטוי כאשר נרצה לשרשר מספר רב של פקודות, וללא שימוש ב-pipe נצטרך להכניס פונקציה בתוך פונקציה או להגדיר הרבה אובייקטי ביניים.\nלהלן דוגמה נוספת, הפעם עם טרנספורמציה של מחרוזת, באמצעות פונקציה str_sub (מחבילת stringr) אשר דורסת את המשתנה sex והופכת male ל-m ו-female ל-f. המשתנה נדרס משום שהשם שהגדרנו בתוך הפקודה mutate הינו השם של המשתנה הקיים במקום שם משתנה חדש כפי שעשינו בדוגמה של משקל התצפית.\n\nnew_gender_penguin <- new_penguins %>% \n  mutate(sex = str_sub(sex, start = 1, end = 1))\n\nglimpse(new_gender_penguin)\n\nRows: 344\nColumns: 9\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <dbl> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"m\", \"f\", \"f\", NA, \"f\", \"m\", \"f\", \"m\", NA, NA, NA, N…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n$ body_mass_kg      <dbl> 3.750, 3.800, 3.250, NA, 3.450, 3.650, 3.625, 4.675,…"
  },
  {
    "objectID": "03-data-munging-tidyverse.html#בחירת-ושינוי-שם-משתנים-עמודות",
    "href": "03-data-munging-tidyverse.html#בחירת-ושינוי-שם-משתנים-עמודות",
    "title": "3  הכנת נתונים",
    "section": "3.4 בחירת ושינוי שם משתנים (עמודות)",
    "text": "3.4 בחירת ושינוי שם משתנים (עמודות)\nבחירת ושינוי שם משתנים היא פעולה שקוראת הרבה במהלך ניתוח נתונים, ובפרט אם הקובץ המקורי שלנו הוא עם כותרות (headers) בעברית, אז אחד הדברים הראשונים שנרצה לעשות הוא לשנות את שמות העמודות לאנגלית, על מנת שיהיה יותר קל לעבוד עם הנתונים.\nעל מנת לבחור משתנים ניתן להשתמש בפונקציה select ועל מנת לשנות שמות של משתנים ניתן להשתמש בפונקציה rename, לדוגמה, הקוד הבא משנה את שם המשתנה sex ל-gender ואז בוחר אותו.\n\npenguin_gender <- new_gender_penguin %>% \n  select(sex) %>% \n  rename(gender = sex)\n\nglimpse(penguin_gender)\n\nRows: 344\nColumns: 1\n$ gender <chr> \"m\", \"f\", \"f\", NA, \"f\", \"m\", \"f\", \"m\", NA, NA, NA, NA, \"f\", \"m\"…\n\n\nכאשר עובדים עם קובץ שבו כותרות המקור היו בעברית, נצטרך להשתמש ב-Back ticks (המרכאה שנמצאת מעל מקש ה-Tab) על מנת לבחור או לשנות את שם המשתנה. לדוגמה נניח שיש לנו שם של משתנה שנקרא”מגדר” ואנחנו רוצים לשנות אותו ל-gender\n\nmy_hebrew_data %>% \n  rename(gender = `מגדר`)\n\nלאחר שינוי השם ל-gender ניתן יהיה לוותר על ה-Back ticks."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#בחירת-משתנים-מתקדמת",
    "href": "03-data-munging-tidyverse.html#בחירת-משתנים-מתקדמת",
    "title": "3  הכנת נתונים",
    "section": "3.5 בחירת משתנים מתקדמת",
    "text": "3.5 בחירת משתנים מתקדמת\nישנן פונקציות עזר שמאפשרות לנו לבחור בצורה חכמה את המשתנים שעליהם ברצוננו להכיל פעולות מסוימות (כגון טרנספורמציות, שינוי שם, או אפילו רק לבחור משתנים בצורה חכמה). הפונקציות המרכזיות שישמשו אותנו בבחירת משתנים מתקדמת הינן:\n\nwhere כדי להכיל תנאים על סוג המשתנה, לדוגמה משתנה שהוא מספרי או תווים;\nends_with, starts_with, contains, any_of, matches כדי לבחור משתנים לפי תת-מחרוזת שמופיעה בהם;\nacross על מנת להחיל טרנספורמציות על כל המשתנים שעונים על קריטריונים שהוגדרו עם הפונקציות לעיל.\n\nנמחיש באמצעות שתי דוגמאות.\nדוגמה ראשונה: נניח שברצוננו לחלק ב-10 את כל המשתנים שמסתיימים ב-“mm” (בעצם להחליף מיחידות של מילימטר ליחידות של ס”מ). אז ניעזר בפונקציה ends_with(\"mm\") בשביל לזהות את המשתנים הללו, ובפונקציה across על מנת להפעיל עליהם את הטרנספורמציה ~{.x/10} (שזו דרך סימבולית לבנות פונקציה שמחלקת מספר ב-10). התוצאה הסופית תיראה כך. לבסוף נרצה לשנות את “mm” ל- ”cm”.\n\npenguin_cm <- penguins %>% \n  mutate(across(ends_with(\"mm\"), ~{.x/10})) %>% \n  rename_with(~str_replace(.x, \"mm\", \"cm\"),\n              ends_with(\"mm\"))\n\nglimpse(penguin_cm)\n\nRows: 344\nColumns: 8\n$ species           <chr> \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            <chr> \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_cm    <dbl> 3.91, 3.95, 4.03, NA, 3.67, 3.93, 3.89, 3.92, 3.41, …\n$ bill_depth_cm     <dbl> 1.87, 1.74, 1.80, NA, 1.93, 2.06, 1.78, 1.96, 1.81, …\n$ flipper_length_cm <dbl> 18.1, 18.6, 19.5, NA, 19.3, 19.0, 18.1, 19.5, 19.3, …\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nשימו לב שהשתמשנו בפונקציה rename_with שמאפשרת להגדיר שינוי של קבוצת משתנים בבת אחת במקום משתנים ספציפיים אחד-אחד (המתבצע באמצעות rename).\nדוגמה שניה: נניח שברצוננו לחתוך את כל המשתנים שהן מחרוזות רק לשלושת התווים הראשונים שלהם. הפונקציה באמצעותה חותכים מחרוזות היא str_sub ונשתמש ב-where(is.character) בשביל לאתר את כל המשתנים שהם מחרוזות. נפעיל זאת על התוצאה של החישוב מהדוגמה הקודמת (על מנת לקבל טבלה חדשה שמכילה את כל השינויים במצטבר), באופן הבא:\n\npenguin_short <- penguin_cm %>% \n  mutate(across(where(is.character),\n                ~str_sub(.x, start = 1L, end = 3L)))\n\nglimpse(penguin_short)\n\nRows: 344\nColumns: 8\n$ species           <chr> \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ade\", \"Ad…\n$ island            <chr> \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"Tor\", \"To…\n$ bill_length_cm    <dbl> 3.91, 3.95, 4.03, NA, 3.67, 3.93, 3.89, 3.92, 3.41, …\n$ bill_depth_cm     <dbl> 1.87, 1.74, 1.80, NA, 1.93, 2.06, 1.78, 1.96, 1.81, …\n$ flipper_length_cm <dbl> 18.1, 18.6, 19.5, NA, 19.3, 19.0, 18.1, 19.5, 19.3, …\n$ body_mass_g       <dbl> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <chr> \"mal\", \"fem\", \"fem\", NA, \"fem\", \"mal\", \"fem\", \"mal\",…\n$ year              <dbl> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\nעדכנו את הטבלה כך שלכל המשתנים שהינם מסוג מחרוזת תתווסף הסיומת “_chr”.\nבצעו זאת בשתי דרכים:\n\nבאמצעות rename;\nבבת אחת על ידי שימוש ב-where, וב-paste0, בתוך פקודת rename_with.\n\nכעת השתמשו בפונקציה mutate על מנת להמיר את המשתנה body_mass_g מגרמים לקילוגרמים. בצעו זאת בשתי דרכים:\n\nבאמצעות mutate על ידי רשימת הטרנספורמציה ישירות על המשתנה;\nבאמצעות mutate על ידי שימוש בפונקציות בחירה (לדוגמה ends_with(\"_g\"), ביחד עם across)."
  },
  {
    "objectID": "03-data-munging-tidyverse.html#פעולות-על-שורות-סינון",
    "href": "03-data-munging-tidyverse.html#פעולות-על-שורות-סינון",
    "title": "3  הכנת נתונים",
    "section": "3.6 פעולות על שורות (סינון)",
    "text": "3.6 פעולות על שורות (סינון)"
  },
  {
    "objectID": "03-data-munging-tidyverse.html#פעולות-לפי-קיבוצים-סיכום",
    "href": "03-data-munging-tidyverse.html#פעולות-לפי-קיבוצים-סיכום",
    "title": "3  הכנת נתונים",
    "section": "3.7 פעולות לפי קיבוצים (סיכום)",
    "text": "3.7 פעולות לפי קיבוצים (סיכום)"
  },
  {
    "objectID": "03-data-munging-tidyverse.html#חיבור-בין-טבלאות",
    "href": "03-data-munging-tidyverse.html#חיבור-בין-טבלאות",
    "title": "3  הכנת נתונים",
    "section": "3.8 חיבור בין טבלאות",
    "text": "3.8 חיבור בין טבלאות"
  },
  {
    "objectID": "04-visualizations-ggplot2.html",
    "href": "04-visualizations-ggplot2.html",
    "title": "4  ויז’ואליזציות",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "05-hypothesis-tests.html",
    "href": "05-hypothesis-tests.html",
    "title": "5  מבחני השערות",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "06-linear-regression.html",
    "href": "06-linear-regression.html",
    "title": "6  רגרסיה לינארית",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "07-advanced-models.html",
    "href": "07-advanced-models.html",
    "title": "7  מודלים",
    "section": "",
    "text": "TBD"
  },
  {
    "objectID": "08-about.html",
    "href": "08-about.html",
    "title": "על הכותב",
    "section": "",
    "text": "עדי לימד ומלמד R במגוון מסגרות: באוניברסיטה במסגרת קורסים כגון מבוא לסטטיסטיקה, ניתוח נתונים, וקורסים פרטיים במכללות ובחברות הייטק. את הניסיון בהכשרה בלימוד R מביא איתו עדי לספר הנוכחי שנועד לתת מענה ללומדים את R ששפת האם שלהם היא עברית.\nלפרטים נוספים adisarid.github.io."
  },
  {
    "objectID": "09-references.html",
    "href": "09-references.html",
    "title": "מקורות",
    "section": "",
    "text": "Wickham, Hadley, and Garrett Grolemund. 2016. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. \"O’Reilly\nMedia, Inc.\"."
  }
]