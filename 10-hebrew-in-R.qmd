# עברית ב-R {#sec-hebrew-tips}

השילוב בין קידוד ב-R לבין השפה העברית טומן בחובו מספר אתגרים. מטרת הפרק לתת כמה טיפים שיעזרו לכם לייעל את העבודה ב-R, גם כשצריך לשלב עברית, בין אם בכותרות של גרפים, בכתיבת דוחות ומסמכים, בקידודי קבצים, בשמות משתנים, ועוד.

הפרק מתחלק לשלושה חלקים:

-   שימוש ב-RStudio IDE עם עברית

-   קידוד קבצים: קריאה וכתיבה של קבצים הכוללים עברית

-   יישור לימין: באפליקציות shiny, מסמכי quarto/rmarkdown, ובגרפים

## שימוש ב-IDE

ה-IDE הנפוץ לשימוש ב-R הוא RStudio IDE (סביבת פיתוח - Integrated Development Environment). שילוב של עברית ב-IDE דורש קצת מיומנות והתרגלות, לדוגמה, כך נראית כתיבת שורות אלו ב-IDE:

![כתיבה בעברית ב-RStudio IDE](images/Hebrew-in-rstudio1.png)

כפי שניתן לראות, למרות שהשורות עצמן בספר מיושרות לימין (כמו שצריך בעברית), בכעת הכתיבה השורות לא מיושרות, וסדר המשפט מתהפך כאשר משלבים עברית ואנגלית. בחלק השלישי של הפרק נסביר איך "קורה הקסם" שהתוצר עצמו כן מיושר לימין. אבל הנה כמה טיפים שיעזרו לכם לשלב עברית בעבודה השוטפת עם RStudio:

1.  **עבודה עם ה-Visual Editor:** בכתיבת מסמכים (מסוג RMarkdown או quarto) לעבוד עם ה-Visual editor במקום ה-Source editor (בצד שמאל למעלה בחירה ב-Visual). איכשהו, העורך הויזואלי מצליח לסדר קצת יותר טוב את העברית, ובמקרה ונדרש לערוך מסמך, מצליח לשים את הסמן במקום הנכון. בצילום המסך הבא מוצג עורך קוד המקור (באדום מסומן הכפתור שמאפשר לעבור לעורך הויזואלי). אם תנסו לשים את הסמן במקום המתאים בעורך קוד המקור תראו שהוא מציב את הסמן במקום הלא נכון.

![מעבר לעורך ויזואלי](images/Hebrew-in-rstudio2.png)

לצערנו, העורך הויזואלי זמין רק במסמכים מסוג RMarkdown ו-quarto. בכתיבת סקריפט רגיל (קובץ קוד בלבד עם סיומת .R), חייבים להשתמש בעורך קוד המקור, מה שמוביל אותנו לנקודה השניה:

2.  **שימוש בשבירת שורות כשנדרש לשלב עברית בקוד:** כאשר כותבים קוד ונדרש לשלב עברית, עדיף לשבור שורה (בכתיבת קוד לרוב שבירת שורה לא משפיעה על הפונקציונליות של הקוד), ואת העברית לשים בשורה נפרדת. זה יקל על עריכת הקוד במידה וצריך. לדוגמה, הקוד הבא מכיל שבירת שורה, ולכן יקל על עריכות במידה ונדרשות:

```{r setup, warning=FALSE, message=FALSE}
library(tidyverse)
```

```{r line breaking for hebrew}
#| eval: false

my_table %>% 
  filter(my_var == 
           "המשתנה שלי")
```

במקום הקוד:

```{r no line breaks}
#| eval: false

my_table %>% 
  filter(my_var == "המשתנה שלי")
```

3.  **שמירת קבצים באנגלית:** תעשו לעצמכם ולאחרים טובה, ולכל הקבצים (והתיקיות) תתנו שמות באנגלית ולא בעברית.
4.  **שמות משתנים באנגלית:** אם יש לכם קובץ נתונים שבו שמות המשתנים (הכותרות) הם בעברית, מומלץ להעביר את כולם לאנגלית, לעבוד באנגלית, ואם צריך להעביר לעברית בסוף (לצורך דיווח ו/או תרשימים). יש דרכים שונות להחליף שמות, לדוגמה הגדרה בתוך הפקודה שקוראת את הקובץ. הפקודה `read_csv` ו-`readxl::read_excel` תומכות שתיהן בארגומנט שנקרא `col_names` ומאפשר להגדיר שמות (אבל השימוש בארגומנט מניח שסדר העמודות עקבי וידוע מראש). הדוגמה הבאה מחליפה שמות של עמודות באמצעות הפקודה `rename`, שמגדירה שם של עמודה באופן מדויק, גם אם הסדר שלהן אינו לפי סדר ההגדרה.

```{r renaming hebrew to english example}
init_tbl <- tibble(`שם` = 
                     c("איתן",
                       "נעמי",
                       "אביב"),
                   `גיל` = 
                     c(11, 9, 5))
init_tbl
init_tbl %>% 
  rename(age = `גיל`,
         name = `שם`)
```

שימו לב אגב שבפלט הטקסט בעברית מופיע הפוך, אבל העתיקו את הקוד ונסו. ניתן להשתמש בפקודה `View` על מנת לראות את התוצר הסופי בצורה מסודרת (פשוט הוסיפו `%>% View()` בסוף השורה האחרונה של הקוד).

## קידוד קבצים

קבצי טקסט בפורמטים שונים (כגון txt או csv) יכולים להכיל אינדיקציה לקידוד, שמאפשרת לתוכנות שונות (ביניהן R ו-Excel) להבין איך לפתוח את הקובץ כך שניתן יהיה לקרוא אותו באופן תקין.

נתייחס לפקודת `read_csv` (פקודות אחרות בחבילת `readr` עובדות באופן דומה). כברירת מחדל, הפקודה תצליח לקרוא טוב קבצים ששמורים עם קידוד של UTF-8, ולרוב הקבצים זה מספיק.

במידה והקריאה אינה עובדת, ניתן להיעזר בפקודה `guess_encoding` גם היא מחבילת `readr`.

לדוגמה:

```{r reading csv example}
guess_encoding("files/utf8_encoding_example_file.csv")
guess_encoding("files/iso8859-8_encoding_example_file.csv")
```

הקובץ הראשון מקודד ב-UTF-8 ולכן שימוש פשוט בפקודה `read_csv` יקרא אותו באופן תקין. הקובץ השני שמור בפורמט ISO-8859-8 (והפקודה גם לא מצליחה "לנחש" אותו), ולכן יהיה קצת יותר מאתגר לקרוא אותו בלי ידע מוקדם על הקידוד. הפעלת פקודת הקריאה על הקובץ השני מבלי הגדרה מתאימה של הקידוד, תציג טקסט שגוי או הודעת שגיאה של <span style="color: red;">Error: Invalid multibyte sequence</span>. הטקסט בעברית בדוגמאות להלן יופיע משמאל לימין (הפוך), אבל אם תנסו להריץ אותו ב-R תראו שהנתונים נקראים באופן תקין, בפקודה הראשונה והשלישית להלן:

```{r reading examples with specified encoding}
read_csv("files/utf8_encoding_example_file.csv")
read_csv("files/iso8859-8_encoding_example_file.csv", 
         locale = locale(encoding = "windows-1251"))
read_csv("files/iso8859-8_encoding_example_file.csv", 
         locale = locale(encoding = "ISO-8859-8"))
```

על מנת לשמור קבצים עם קידוד, מומלץ להשתמש בפקודה `write_excel_csv` במקום הפקודה `write_csv`, במיוחד אם מתכננים לקרוא את הקובץ שנשמר באמצעות אקסל. הפקודה של `write_excel_csv` כוללת "הנחיות קידוד" כך שפתיחה באקסל תציג עברית באופן תקין (התוצר הוא עדיין קובץ טקסט). לעומת זאת, שמירה של `write_csv` עם נתונים בעברית, תציג ג'יבריש בעת פתיחת אקסל רגילה (אגב, אפשר לייבא נתונים באקסל ולהגדיר UTF-8 כקידוד, ואז ניתן לקרוא גם קבצים כאלו באופן תקין).

<div class="note">

פורמט אקסל (קובץ xlsx) הוא פורמט נוח מבחינת קידוד, משום שהוא שומר את הקידוד באופן מובנה. עם זאת, הוא פורמט פחות נוח לעבודה בהרבה מקרים. ניתן לקרוא קבצי אקסל באמצעות `readxl::read_excel` ואז לא צריך להתעסק עם קידוד. שמירה של קבצי אקסל תיעשה באמצעות אחת מהפקודות הבאות `openxlsx::write.xlsx` או `writexl::write_xlsx`.

</div>

## יישור לימין
