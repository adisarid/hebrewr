# הכנת נתונים {#sec-data-munging-tidyverse}

הכנת נתונים, או כמו שהיא מכונה באנגלית, Data Munging, היא סדר הפעולות שיש לעשות לנתונים על מנת שאפשר יהיה להשתמש בהם בכלל שלבי המחקר, כגון הצגת נתונים (ויז'ואליזציה), מידול, ובפעולות נוספות במהלך המחקר. בספר זה, אנחנו עושים שימוש רב בחבילת `tidyverse` על מנת להכין את הנתונים.

ראשית, נעמוד על הפילוסופיה מאחורי `tidyverse`.

## הפילוסופיה מאחורי `tidyverse`

החבילה ב-R שנקראת `tidyverse` היא למעשה "חבילה של חבילות".\
היא מכילה מקבץ חבילות לעבודה עם נתונים כמו `dplyr`, וכמו `tidyr` שהן חבילות מאוד שימושיות במניפולציה על נתונים, וסידור נתונים, אבל היא מכילה גם חבילות שממוקדות סביב עולמות תוכן אחרים, כמו `stringr` לעבודה עם מחזורות, `lubridate` לעבודה עם תאריכים, ו-`forcats` לעבודה עם פקטורים. כפי שחדי העין ישימו לב, לרוב שם של חבילה ירמוז לגבי מהות החבילה (לעיתים עם האות r איפשהו, ולעיתים עם קורטוב של הומור). הפירוט המלא של תוכן החבילה `tidyverse`והחבילות שמוכלות בה זמין [בקישור](https://www.tidyverse.org/).

על מנת להתקין את החבילה נשתמש בפקודה `install.packages("tidyverse")`, ועל מנת לטעון אותה לאחר ההתקנה, נשתמש בפקודה `library(tidyverse)`. שימו לב שבהתקנה צריך להשתמש במרכאות אבל בקריאה לאחר מכן אין צורך במרכאות. את ההתקנה צריך לעשות רק פעם אחת (והיא לוקחת המון זמן), ואת הקריאה לספריה צריך לעשות כל פעם שמפעילים מחדש את R.

כשלב יסודי, מה שחשוב להבין בעבודה עם נתונים זה שהשאיפה היא שתמיד נשאף להגיע ולעבוד במבנה מסודר שבו:

1.  כל עמודה היא משתנה.
2.  כל שורה היא תצפית.
3.  כל תא הוא ערך של משתנה עבור תצפית מסוימות.

אם הדאטה המקורי שלנו לא במבנה הזה - אז כהכנה נרצה להביא אותו למבנה כזה, ואם הוא כבר במבנה המסודר הזה, אז כל פעולה שנעשה, עדיין תשמור את הדאטה במבנה מסודר. המבנה הזה מכונה באנגלית tidy (ומכאן השם tidyverse). אנחנו פשוט נכנה אותו פה מבנה "מסודר".

ניתן שתי דוגמאות לדאטה, אחד מסודר ואחר לא מסודר. נתחיל בדוגמה לדאטה לא מסודר.

### דוגמה לדאטה לא מסודר

הלשכה המרכזית לסטטיסטיקה מנגישה הרבה נתונים לציבור באמצעות האתר שלה https://www.cbs.gov.il\
מרבית הנתונים שמונגשים לציבור דרך האתר בקבצי אקסל הינם בפורמט לא מסודר. לדוגמה, קובץ שהורדתי מהכתובת [הזו](https://www.cbs.gov.il/he/publications/Pages/2016/%D7%A1%D7%A4%D7%99%D7%A8%D7%95%D7%AA-%D7%AA%D7%A0%D7%95%D7%A2%D7%94-%D7%91%D7%93%D7%A8%D7%9B%D7%99%D7%9D-%D7%9C%D7%90-%D7%A2%D7%99%D7%A8%D7%95%D7%A0%D7%99%D7%95%D7%AA-2015-2010.aspx) והוא עוסק בנפח תנועה מסביב לכנרת בחג הפסח וסוכות.

זה קובץ אקסל, והוא נראה כך:

![דאטה לא-מסודר מאתר הלשכה המרכזית לסטטיסטיקה](images/cbs_untidy_data.png){fig-alt="דאטה לא-מסודר מאתר הלשכה המרכזית לסטטיסטיקה" fig-align="center"}

איפה הבעיות עם הדאטה? נראה מה הסעיפים שאינם מתקיימים:

1.  כל עמודה היא משתנה - מתקיים באופן חלקי. משום שיש עמודות מסוימות כמו עמודות H-K שהן ממוזגות מה שהופך אותם ל"לא בדיוק משתנה יחיד". מדובר בקבוצת משתנים ותכונה שמתארת אותם. בפרט, היינו מצפים לראות שורת כותרת אחת שמתארת את שמות המשתנים (מה שמכונה באנגלית headers), אבל בפועל יש פה הרבה שורות כותרות.
2.  כל שורה היא תצפית - לא מתקיים בכלל. יש שורות ריקות (כמו שורה 5), ויש שורות שאינן תצפית אלא מתארות תכונות של מקבץ תצפיות (כגון שורה 6 ושורה 14).
3.  כל תא הוא ערך של משתנה עבור תצפית מסוימת - לא מתקיים. ראו סעיף קודם - מדובר בתאים שמכילים ערכים שמתארים מקבץ תצפיות.

כמו כן, יש עוד כל מיני חריגות לא ברורות בקובץ כגון תאים שמודגשים במסגרת גבול שחורה (מבלי שברור מה המסגרת אומרת), יש תאים שמכילים שתי נקודות (לא ברור מה זה, האם ערך חסר?), שמות המשתנים לעיתים מפוצלים על פני שתי שורות (כמו לדוגמה "ערב פסח" בעמודה F), ועוד בעיות.

בסיכומו של עניין - אילו היינו רוצים לקלוט קובץ כזה לתוך R על מנת לחלץ את המספרים שבו, היינו צריכים להתאמץ רבות על מנת להפוך את הקובץ למסודר. באופן כללי, ניתן לומר שקבצי אקסל הם מתכון לאסון כי הם מעודדים את המשתמשים לבנות קבצים לא-מסודרים על ידי ביצוע פעולות כמו מיזוג תאים, צביעה של תאים (שזה אינדיקציה לקידוד מידע כלשהו, אבל קידוד שקשה להבין אותו ב"שפת הנתונים"), ועוד שאר בעיות שאין זה המקום לתאר.

### דוגמה לדאטה מסודר

הנה דוגמה לדאטה מסודר מתוך חבילת `palmerpenguins`. חבילה זו מכילה נתונים של שלושה זנים של פינגוינים, ואנחנו עוד נשתמש בה בהמשך הספר. לכרגע רק נראה איך נראות עשרת השורות הראשונות בטבלת הנתונים (הסבר על הקוד והתוצר שרואים מצורף מטה):

```{r showing palmer penguins}
palmerpenguins::penguins
```

אנחנו רואים שהאובייקט הוא מסוג tibble (טבלה שהיא גרסה מודרנית יותר של ה-`data.frame` הבסיסי ב-R). לטבלה הזו יש 344 תצפיות (פינגוינים), ויש לה 8 עמודות (משתנים) שכוללים את הזן של הפינגוין, מאיזה אי הוא, אורך ועומד המקור, אורך הכנף, מסה, מין, והשנה שבה נצפתה הדגימה. הדאטה הזה מסודר ועומד בכללים שהגדרנו.

לגבי הקוד עצמו שבו השתמשנו: השימוש בנקודותיים `::` אומר ל-R לקחת את האובייקט `penguins` שנמצא בתוך חבילת `palmerpenguins` (אפשר גם היה לפצל את הקוד וקודם להשתמש ב-`library(palmerpenguins)` ואז להריץ את `head(penguins)`.

אם תרצו להריץ את הקוד הזה אצלכם במחשב, יכול להיות שתצטרכו קודם להתקין את החבילה על ידי שימוש בפקודה `install.packages("palmerpenguins")`.

כעת לאחר שלמדנו קצת על מה הוא דאטה מסודר, נראה איך אפשר לקרוא נתונים ו"להציץ" בנתונים, כדי לקבל מושג מה יש בנתונים ואיך לגשת אליהם.

## הצצה ראשונית על הנתונים

בדרך כלל לפני הצצה ראשונית על הנתונים, אנחנו נידרש לקרוא אותם. קריאת הנתונים יכולה להתבצע ממגוון פורמטים. לדוגמה:

-   קריאה מפורמט של CSV (Comma Separated Values, קרי קובץ טקסט המפריד ערכים באמצעות פסיקים), באמצעות פונקציות כגון `read.csv`, `readr::read_csv`.

-   קריאה מפורמט של אקסל באמצעות פונקציה כגון: `readxl::read_excel`.

-   קריאה מפורמט של תוכנות סטטיסטיות אחרות כגון SPSS או SAS באמצעות פקודות מחבילת `haven`.

-   פורמטים וכלים נוספים.

נתמקד בקבצי CSV, הפקודה המועדפת עלי היא `readr::read_csv` (בהשוואה ל-`read.csv` שנמצאת ב-Base R). הפקודה `read_csv` מעט מהירה ונוחה יותר מבחינת השליטה שהיא מאפשרת בקריאת הנתונים.

::: question
קראו את התיעוד של `read.csv` ושל `read_csv`. איזה הבדלים אתם מזהים בין הפקודות?

לצורך קריאת התיעוד ניתן לכתוב ב-Console `?read.csv`, `?readr::read_csv`.
:::

נקרא כעת את טבלת הPenguins שראינו בחלק הקודם. שימו לב שאנחנו משתמשים במיקום קובץ באינטרנט, אבל ניתן גם לקרוא קבצים שנמצאים מקומית על המחשב.

```{r reading penguins, cache=TRUE}
library(readr)
penguins <- read_csv("https://raw.githubusercontent.com/allisonhorst/palmerpenguins/main/inst/extdata/penguins.csv")
```

על מנת להציץ בדאטה יש מספר פקודות שניתן להשתמש בהן:

-   הפקודה `View` (עם V גדולה) - פקודה זו מתאימה לדאטה בגודל קטן עד בינוני, והיא מציגה טבלה עם הנתונים.

-   הפקודה `glimpse` תציג את הערכים הראשונים של כל אחד מהמשתנים, כמו גם את שמות המשתנים, ואת סוגם.

-   הפקודה `head` תציג טבלה המוגבלת לשש התצפיות הראשונות. אפשר להשתמש בארגומנט של הפונקציה על מנת להציג יותר שורות. הפקודה `tail` עובדת באופן דומה (רק מתחתית הטבלה).

-   לכתוב ב-Console את שם הטבלה וללחוץ על Enter פשוט יציג את הטבלה (אם מדובר בtibble אז היא תוצג בפורמט קומפקטי ונוח).

```{r view data set examples}
#| warning: false
#| message: false
library(tidyverse)
glimpse(penguins)
head(penguins)
head(penguins, 10)
penguins
```

::: question
עברו על הפלט וודאו שאתם מצליחים להבין אילו חלקים בכל אחד מהפלטים מספק את המידע: סוג המשתנה, שם המשתנה, גודל הטבלה.
:::

במבט על הפלט של כל אחת מהפקודות להלן ניתן כבר להבין את הפרטים הבאים:

-   האובייקט שאנחנו בוחנים הוא טבלה מסוג tibble, בגודל של 344 שורות (תצפיות), ו-8 עמודות (משתנים).

-   סוגי המשתנים הם מחרוזות (character - chr), מספרים ממשיים (double - dbl).

    -   מחרוזות: species, island, sex

    -   מספרים ממשיים: bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year.

כעת, לאחר שלמדנו איך להבין את מבנה הדאטה באופן ראשוני, נציג פונקציות שמשמשות לשינוי משתנים (טרנספורמציות).

## פעולות שמשנות ערכים (טרנספורמציות)

טרנספורמציה היא פעולה (פונקציה) על משתנה או צירוף של משתנים המניבה משתנה עם ערך חדש. היא יכולה להיות פעולה מתמטית פשוטה כמו לוגריתם, פונקציה טריגונומטרית, או מכפלה בסקלר (ערך כלשהו).

גם פעולה על מחרוזת היא טרנספורמציה, כגון החזרת אורך המחרוזת או חלק ממחרוזת.

טרנספורמציות ב-R יבוצעו באמצעות הפקודה `mutate`, והן יכולות לדרוס ערך קיים או להוסיף משתנה חדש לטבלה. התוצאה תוחזר בטבלה חדשה לגמרי (ולא תדרוס את הטבלה שהוזנה לתוך הפונציה `mutate`.

בנוסף, על מנת להפעיל את הטרנספורמציה עם פקודת mutate (ובאופן כללי בשימוש ב-tidyverse) נשתמש באופרטור הנקרא pipe (מקטרת או צינור) ומטרתו להפוך את הקוד ליותר ברור. ישנם שני אופרטורים מסוג pipe: `%>%` ו-`|>`. בספר זה נשתמש בנוסח הראשון (הנוסח השני נמצא ב-Base R החל מגרסה 4.0.0).

להלן דוגמה המייצרת משתנה חדש (עמודה נוספת) ל-penguins, של משקל בקילוגרמים.

```{r penguin kg weight}
new_penguins <- penguins %>% 
  mutate(body_mass_kg = body_mass_g/1000)

glimpse(new_penguins)
```

כפי שניתן לראות האובייקט `new_penguins` דומה מאוד לאובייקט המקורי `penguins` (שלא השתנה). האובייקט החדש מכיל עמודה נוספת שהיא המשקל של התצפית בק"ג.

האופרטור pipe מסמן ל-R להכניס את הדאטה penguins כארגומנט ראשון בפונקציה `mutate`. זה שקול לכתיב הבא: `mutate(penguins, body_mass_kg = body_mass_g/1000)`. היתרון בשימוש ב-pipe יבוא לידי ביטוי כאשר נרצה לשרשר מספר רב של פקודות, וללא שימוש ב-pipe נצטרך להכניס פונקציה בתוך פונקציה או להגדיר הרבה אובייקטי ביניים.

להלן דוגמה נוספת, הפעם עם טרנספורמציה של מחרוזת, באמצעות פונקציה `str_sub` (מחבילת `stringr`) אשר **דורסת** את המשתנה sex והופכת male ל-m ו-female ל-f. המשתנה נדרס משום שהשם שהגדרנו בתוך הפקודה `mutate` הינו השם של המשתנה הקיים במקום שם משתנה חדש כפי שעשינו בדוגמה של משקל התצפית.

```{r penguin gender transformation}
new_gender_penguin <- new_penguins %>% 
  mutate(sex = str_sub(sex, start = 1, end = 1))

glimpse(new_gender_penguin)
```

## בחירת ושינוי שם משתנים (עמודות)

בחירת ושינוי שם משתנים היא פעולה שקוראת הרבה במהלך ניתוח נתונים, ובפרט אם הקובץ המקורי שלנו הוא עם כותרות (headers) בעברית, אז אחד הדברים הראשונים שנרצה לעשות הוא לשנות את שמות העמודות לאנגלית, על מנת שיהיה יותר קל לעבוד עם הנתונים.

על מנת לבחור משתנים ניתן להשתמש בפונקציה `select` ועל מנת לשנות שמות של משתנים ניתן להשתמש בפונקציה `rename`, לדוגמה, הקוד הבא משנה את שם המשתנה `sex` ל-`gender` ואז בוחר אותו.

```{r penguin select and rename sex}
penguin_gender <- new_gender_penguin %>% 
  select(sex) %>% 
  rename(gender = sex)

glimpse(penguin_gender)
```

כאשר עובדים עם קובץ שבו כותרות המקור היו בעברית, נצטרך להשתמש ב-Back ticks (המרכאה שנמצאת מעל מקש ה-Tab) על מנת לבחור או לשנות את שם המשתנה. לדוגמה נניח שיש לנו שם של משתנה שנקרא"מגדר" ואנחנו רוצים לשנות אותו ל-`gender`

```{r, eval=FALSE}

my_hebrew_data %>% 
  rename(gender = `מגדר`)
```

לאחר שינוי השם ל-gender ניתן יהיה לוותר על ה-Back ticks.

## בחירת משתנים מתקדמת

ישנן פונקציות עזר שמאפשרות לנו לבחור בצורה חכמה את המשתנים שעליהם ברצוננו להכיל פעולות מסוימות (כגון טרנספורמציות, שינוי שם, או אפילו רק לבחור משתנים בצורה חכמה). הפונקציות המרכזיות שישמשו אותנו בבחירת משתנים מתקדמת הינן:

-   `where` כדי להכיל תנאים על סוג המשתנה, לדוגמה משתנה שהוא מספרי או תווים;

-   `ends_with`, `starts_with`, `contains`, `any_of`, `matches` כדי לבחור משתנים לפי תת-מחרוזת שמופיעה בהם;

-   `across` על מנת להחיל טרנספורמציות על כל המשתנים שעונים על קריטריונים שהוגדרו עם הפונקציות לעיל.

נמחיש באמצעות שתי דוגמאות.

**דוגמה ראשונה:** נניח שברצוננו לחלק ב-10 את כל המשתנים שמסתיימים ב-"mm" (בעצם להחליף מיחידות של מילימטר ליחידות של ס"מ). אז ניעזר בפונקציה `ends_with("mm")` בשביל לזהות את המשתנים הללו, ובפונקציה `across` על מנת להפעיל עליהם את הטרנספורמציה `~{.x/10}` (שזו דרך סימבולית לבנות פונקציה שמחלקת מספר ב-10). התוצאה הסופית תיראה כך. לבסוף נרצה לשנות את "mm*"* ל- *"*cm".

```{r divide by ten}
penguin_cm <- penguins %>% 
  mutate(across(ends_with("mm"), ~{.x/10})) %>% 
  rename_with(~str_replace(.x, "mm", "cm"),
              ends_with("mm"))

glimpse(penguin_cm)
```

שימו לב שהשתמשנו בפונקציה `rename_with` שמאפשרת להגדיר שינוי של קבוצת משתנים בבת אחת במקום משתנים ספציפיים אחד-אחד (המתבצע באמצעות `rename`).

**דוגמה שניה:** נניח שברצוננו לחתוך את כל המשתנים שהן מחרוזות רק לשלושת התווים הראשונים שלהם. הפונקציה באמצעותה חותכים מחרוזות היא `str_sub` ונשתמש ב-`where(is.character)` בשביל לאתר את כל המשתנים שהם מחרוזות. נפעיל זאת על התוצאה של החישוב מהדוגמה הקודמת (על מנת לקבל טבלה חדשה שמכילה את כל השינויים במצטבר), באופן הבא:

```{r cutting strings}
penguin_short <- penguin_cm %>% 
  mutate(across(where(is.character),
                ~str_sub(.x, start = 1L, end = 3L)))

glimpse(penguin_short)
```

::: question
עדכנו את הטבלה כך שלכל המשתנים שהינם מסוג מחרוזת תתווסף הסיומת "\_chr".

בצעו זאת בשתי דרכים:

1.  באמצעות `rename`;
2.  בבת אחת על ידי שימוש ב-`where`, וב-`paste0`, בתוך פקודת `rename_with`.

כעת השתמשו בפונקציה `mutate` על מנת להמיר את המשתנה `body_mass_g` מגרמים לקילוגרמים. בצעו זאת בשתי דרכים:

1.  באמצעות `mutate` על ידי רשימת הטרנספורמציה ישירות על המשתנה;
2.  באמצעות `mutate` על ידי שימוש בפונקציות בחירה (לדוגמה `ends_with("_g")`, ביחד עם `across`).
:::

## פעולות על שורות (סינון)

## פעולות לפי קיבוצים (סיכום)

## חיבור בין טבלאות
